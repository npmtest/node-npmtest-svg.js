{"/home/travis/build/npmtest/node-npmtest-svg.js/test.js":"/* istanbul instrument in package npmtest_svg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg.js/lib.npmtest_svg.js.js":"/* istanbul instrument in package npmtest_svg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_svg_js = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_svg_js = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-svg.js/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-svg.js && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_svg_js */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_svg_js\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_svg_js.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_svg_js.rollup.js'] =\n            local.assetsDict['/assets.npmtest_svg_js.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_svg_js.__dirname + '/lib.npmtest_svg_js.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/dist/svg.js":"/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.6.0\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Fri Apr 21 2017 12:48:06 GMT+0200 (Mitteleuropäische Sommerzeit)\n*/;\n(function(root, factory) {\r\n  /* istanbul ignore next */\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function(){\r\n      return factory(root, root.document)\r\n    })\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\nvar pathHandlers = {\r\n  M: function(c, p, p0) {\r\n    p.x = p0.x = c[0]\r\n    p.y = p0.y = c[1]\r\n\r\n    return ['M', p.x, p.y]\r\n  },\r\n  L: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['L', c[0], c[1]]\r\n  },\r\n  H: function(c, p) {\r\n    p.x = c[0]\r\n    return ['H', c[0]]\r\n  },\r\n  V: function(c, p) {\r\n    p.y = c[0]\r\n    return ['V', c[0]]\r\n  },\r\n  C: function(c, p) {\r\n    p.x = c[4]\r\n    p.y = c[5]\r\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\r\n  },\r\n  S: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['S', c[0], c[1], c[2], c[3]]\r\n  },\r\n  Q: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['Q', c[0], c[1], c[2], c[3]]\r\n  },\r\n  T: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['T', c[0], c[1]]\r\n  },\r\n  Z: function(c, p, p0) {\r\n    p.x = p0.x\r\n    p.y = p0.y\r\n    return ['Z']\r\n  },\r\n  A: function(c, p) {\r\n    p.x = c[5]\r\n    p.y = c[6]\r\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\r\n  }\r\n}\r\n\r\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('')\r\n\r\nfor(var i = 0, il = mlhvqtcsa.length; i < il; ++i){\r\n  pathHandlers[mlhvqtcsa[i]] = (function(i){\r\n    return function(c, p, p0) {\r\n      if(i == 'H') c[0] = c[0] + p.x\r\n      else if(i == 'V') c[0] = c[0] + p.y\r\n      else if(i == 'A'){\r\n        c[5] = c[5] + p.x,\r\n        c[6] = c[6] + p.y\r\n      }\r\n      else\r\n        for(var j = 0, jl = c.length; j < jl; ++j) {\r\n          c[j] = c[j] + (j%2 ? p.y : p.x)\r\n        }\r\n\r\n      return pathHandlers[i](c, p, p0)\r\n    }\r\n  })(mlhvqtcsa[i].toUpperCase())\r\n}\r\n\r\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n    var arr = []\r\n      , p = new SVG.Point()\r\n      , p0 = new SVG.Point()\r\n      , index = 0\r\n      , len = array.length\r\n\r\n    do{\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[index])){\r\n        s = array[index]\r\n        ++index\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      arr.push(pathHandlers[s].call(null,\r\n          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),\r\n          p, p0\r\n        )\r\n      )\r\n\r\n    }while(len > index)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        // The condition is because some methods return a normal number instead\r\n        // of a SVG.Number\r\n        if(s.animations[i] instanceof SVG.Number)\r\n          source = new SVG.Number(source)\r\n\r\n        s.animations[i] = source.morph(s.animations[i])\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n          this.active = false\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, len, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n\r\n      if(!isEased)pos = this.situation.ease(pos)\r\n\r\n      this.situation.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable plot\r\n, plot: function() {\r\n    // We use arguments here since SVG.Line's plot method can be passed 4 parameters\r\n    return this.add('plot', arguments.length > 1 ? [].slice.call(arguments) : arguments[0])\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw.instance).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, a, o != null ? o : a)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding, options) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, options || false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n    , namespace = ''\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding, options) {\r\n    SVG.on(this.node, event, listener, binding, options)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\r\n\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function(spof) {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node)\r\n      }\r\n\r\n      return this\r\n    }\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      // add back parser\r\n      if(!SVG.parser.draw.parentNode)\r\n        this.node.appendChild(SVG.parser.draw)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hy¡n\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create path for text to run on\r\n    path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));\r","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/gulpfile.js":"var del     = require('del')\r\n  , gulp    = require('gulp')\r\n  , chmod   = require('gulp-chmod')\r\n  , concat  = require('gulp-concat')\r\n  , header  = require('gulp-header')\r\n  , rename  = require('gulp-rename')\r\n  , size    = require('gulp-size')\r\n  , trim    = require('gulp-trimlines')\r\n  , uglify  = require('gulp-uglify')\r\n  , wrapUmd = require('gulp-wrap')\r\n  , request = require('request')\r\n  , fs      = require('fs')\r\n  , pkg     = require('./package.json')\r\n\r\n\r\nvar headerLong = ['/*!'\r\n  , '* <%= pkg.name %> - <%= pkg.description %>'\r\n  , '* @version <%= pkg.version %>'\r\n  , '* <%= pkg.homepage %>'\r\n  , '*'\r\n  , '* @copyright <%= pkg.author %>'\r\n  , '* @license <%= pkg.license %>'\r\n  , '*'\r\n  , '* BUILT: <%= pkg.buildDate %>'\r\n  , '*/;'\r\n  , ''].join('\\n')\r\n\r\nvar headerShort = '/*! <%= pkg.name %> v<%= pkg.version %> <%= pkg.license %>*/;'\r\n\r\n// all files in the right order (currently we don't use any dependency management system)\r\nvar parts = [\r\n  'src/svg.js'\r\n, 'src/regex.js'\r\n, 'src/utilities.js'\r\n, 'src/default.js'\r\n, 'src/color.js'\r\n, 'src/array.js'\r\n, 'src/pointarray.js'\r\n, 'src/patharray.js'\r\n, 'src/number.js'\r\n, 'src/element.js'\r\n, 'src/fx.js'\r\n, 'src/boxes.js'\r\n, 'src/matrix.js'\r\n, 'src/point.js'\r\n, 'src/attr.js'\r\n, 'src/transform.js'\r\n, 'src/style.js'\r\n, 'src/parent.js'\r\n, 'src/ungroup.js'\r\n, 'src/container.js'\r\n, 'src/viewbox.js'\r\n, 'src/event.js'\r\n, 'src/defs.js'\r\n, 'src/group.js'\r\n, 'src/arrange.js'\r\n, 'src/mask.js'\r\n, 'src/clip.js'\r\n, 'src/gradient.js'\r\n, 'src/pattern.js'\r\n, 'src/doc.js'\r\n, 'src/shape.js'\r\n, 'src/bare.js'\r\n, 'src/symbol.js'\r\n, 'src/use.js'\r\n, 'src/rect.js'\r\n, 'src/ellipse.js'\r\n, 'src/line.js'\r\n, 'src/poly.js'\r\n, 'src/pointed.js'\r\n, 'src/path.js'\r\n, 'src/image.js'\r\n, 'src/text.js'\r\n, 'src/textpath.js'\r\n, 'src/nested.js'\r\n, 'src/hyperlink.js'\r\n, 'src/marker.js'\r\n, 'src/sugar.js'\r\n, 'src/set.js'\r\n, 'src/data.js'\r\n, 'src/memory.js'\r\n, 'src/selector.js'\r\n, 'src/helpers.js'\r\n, 'src/polyfill.js'\r\n]\r\n\r\ngulp.task('clean', function() {\r\n  return del([ 'dist/*' ])\r\n})\r\n\r\n/**\r\n * Compile everything in /src to one unified file in the order defined in the MODULES constant\r\n * wrap the whole thing in a UMD wrapper (@see https://github.com/umdjs/umd)\r\n * add the license information to the header plus the build time stamp‏\r\n */\r\ngulp.task('unify', ['clean'], function() {\r\n  pkg.buildDate = Date()\r\n  return gulp.src(parts)\r\n    .pipe(concat('svg.js', { newLine: '\\n' }))\r\n    // wrap the whole thing in an immediate function call\r\n    .pipe(wrapUmd({ src: 'src/umd.js'}))\r\n    .pipe(header(headerLong, { pkg: pkg }))\r\n    .pipe(trim({ leading: false }))\r\n    .pipe(chmod(0o644))\r\n    .pipe(gulp.dest('dist'))\r\n    .pipe(size({ showFiles: true, title: 'Full' }))\r\n})\r\n\r\n/**\r\n ‎* uglify the file and show the size of the result\r\n * add the license info\r\n * show the gzipped file size\r\n */\r\ngulp.task('minify', ['unify'], function() {\r\n  return gulp.src('dist/svg.js')\r\n    .pipe(uglify())\r\n    .pipe(rename({ suffix:'.min' }))\r\n    .pipe(size({ showFiles: true, title: 'Minified' }))\r\n    .pipe(header(headerShort, { pkg: pkg }))\r\n    .pipe(chmod(0o644))\r\n    .pipe(gulp.dest('dist'))\r\n    .pipe(size({ showFiles: true, gzip: true, title: 'Gzipped' }))\r\n})\r\n\r\n\r\ngulp.task('default', ['clean', 'unify', 'minify'])","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/bench/svg.bench.js":";( function() {\r\n\r\n  SVG.bench = {\r\n    // Initalize test store\r\n    _chain:  []\r\n  , _before: function() {}\r\n  , _after:  function() {}\r\n  , draw:    SVG('draw')\r\n  , snap:    Snap(100, 100)\r\n  , raw:     document.getElementById('native')\r\n\r\n    // Add descriptor\r\n  , describe: function(name, closure) {\r\n      this._chain.push({\r\n        name: name\r\n      , run:  closure\r\n      })\r\n\r\n      return this\r\n    }\r\n\r\n    // Add test\r\n  , test: function(name, run) {\r\n      // run test\r\n      var start = ( new Date ).getTime()\r\n      run()\r\n      this.write( name, ( new Date ).getTime() - start )\r\n\r\n      // clear everything\r\n      this.clear()\r\n    }\r\n\r\n    // Skip test\r\n  , skip: function(name, run) {\r\n      this.write( name, false )\r\n    }\r\n\r\n    // Run tests\r\n  , run: function() {\r\n      this.pad()\r\n      \r\n      for (var h, i = 0, il = this._chain.length; i < il; i++) {\r\n        var h = document.createElement('h1')\r\n        h.innerHTML = this._chain[i].name\r\n\r\n        this.pad().appendChild(h)\r\n\r\n        this._chain[i].run(this)\r\n      }\r\n    }\r\n    \r\n    // Write result\r\n  , write: function(name, ms) {\r\n      var test = document.createElement('div')\r\n\r\n      if (typeof ms === 'number') {\r\n        test.className = 'test'\r\n        test.innerHTML = '<span class=\"name\">' + name + '</span> completed in <span class=\"ms\">' + ms + 'ms</span>'\r\n      } else {\r\n        test.className = 'test skipped'\r\n        test.innerHTML = name + ' (skipped)'\r\n      }\r\n      \r\n      this.pad().appendChild(test)\r\n\r\n      return this\r\n    }\r\n\r\n    // Reference writable element\r\n  , pad: function() {\r\n      var pad = document.getElementById('pad')\r\n\r\n      if (!pad) {\r\n        pad = document.createElement('div')\r\n        document.getElementsByTagName('body')[0].appendChild(pad)\r\n      }\r\n\r\n      return pad\r\n    }\r\n\r\n    // Clear canvasses\r\n  , clear: function() {\r\n      while(this.raw.hasChildNodes())\r\n        this.raw.removeChild(this.raw.lastChild)\r\n      this.draw.clear()\r\n      this.snap.clear()\r\n    }\r\n  }\r\n\r\n})();","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/.config/karma.conf.js":"// Karma configuration\r\n// Generated on Tue Oct 04 2016 13:53:46 GMT+0200 (CEST)\r\n\r\nmodule.exports = function(config) {\r\n  config.set({\r\n\r\n    // base path that will be used to resolve all patterns (eg. files, exclude)\r\n    basePath: '../',\r\n\r\n\r\n    // frameworks to use\r\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\r\n    frameworks: ['jasmine'],\r\n\r\n\r\n    // list of files / patterns to load in the browser\r\n    files: [\r\n      '.config/pretest.js',\r\n      {\r\n        pattern: 'spec/fixture.css',\r\n        included: false,\r\n        served: true\r\n      },\r\n      {\r\n        pattern: 'spec/fixture.svg',\r\n        included: false,\r\n        served: true\r\n      },\r\n      {\r\n        pattern: 'spec/fixtures/pixel.png',\r\n        included: false,\r\n        served: true\r\n      },\r\n      'dist/svg.js',\r\n      'spec/spec/**/*.js'\r\n    ],\r\n    \r\n    proxies: {\r\n      '/fixtures/': '/base/spec/fixtures/'\r\n    },\r\n\r\n\r\n    // list of files to exclude\r\n    exclude: [],\r\n\r\n\r\n    // preprocess matching files before serving them to the browser\r\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\r\n    preprocessors: {\r\n      'dist/svg.js': ['coverage']\r\n    },\r\n\r\n\r\n    // test results reporter to use\r\n    // possible values: 'dots', 'progress'\r\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\r\n    reporters: ['progress', 'coverage'],\r\n\r\n\r\n    // configure the coverage reporter\r\n    coverageReporter: {\r\n      // Specify a reporter type.\r\n      type: 'lcov',\r\n      dir: 'coverage/',\r\n      subdir: function(browser) {\r\n        // normalization process to keep a consistent browser name accross different OS\r\n        return browser.toLowerCase().split(/[ /-]/)[0]; // output the results into: './coverage/firefox/'\r\n      }\r\n    },\r\n\r\n\r\n    // web server port\r\n    port: 9876,\r\n\r\n\r\n    // enable / disable colors in the output (reporters and logs)\r\n    colors: true,\r\n\r\n\r\n    // level of logging\r\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\r\n    logLevel: config.LOG_INFO,\r\n\r\n\r\n    // enable / disable watching file and executing tests whenever any file changes\r\n    autoWatch: false,\r\n\r\n\r\n    // start these browsers\r\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\r\n    browsers: ['Firefox'],\r\n\r\n    // Continuous Integration mode\r\n    // if true, Karma captures browsers, runs the tests and exits\r\n    singleRun: false,\r\n\r\n    // Concurrency level\r\n    // how many browser should be started simultaneous\r\n    concurrency: Infinity\r\n  })\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/.config/karma.quick.js":"// Karma configuration\r\n// Generated on Tue Oct 04 2016 13:53:46 GMT+0200 (CEST)\r\n\r\nmodule.exports = function(config) {\r\n  config.set({\r\n\r\n    // base path that will be used to resolve all patterns (eg. files, exclude)\r\n    basePath: '../',\r\n\r\n\r\n    // frameworks to use\r\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\r\n    frameworks: ['jasmine'],\r\n\r\n\r\n    // list of files / patterns to load in the browser\r\n    files: [\r\n      '.config/pretest.js',\r\n      {\r\n        pattern: 'spec/fixture.css',\r\n        included: false,\r\n        served: true\r\n      },\r\n      {\r\n        pattern: 'spec/fixture.svg',\r\n        included: false,\r\n        served: true\r\n      },\r\n      'dist/svg.js',\r\n      'spec/spec/**/*.js'\r\n    ],\r\n\r\n\r\n    // list of files to exclude\r\n    exclude: [],\r\n\r\n\r\n    // preprocess matching files before serving them to the browser\r\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\r\n    preprocessors: {},\r\n\r\n\r\n    // test results reporter to use\r\n    // possible values: 'dots', 'progress'\r\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\r\n    reporters: ['progress'],\r\n\r\n\r\n    // configure the coverage reporter\r\n    coverageReporter: {},\r\n\r\n\r\n    // web server port\r\n    port: 9875,\r\n\r\n\r\n    // enable / disable colors in the output (reporters and logs)\r\n    colors: true,\r\n\r\n\r\n    // level of logging\r\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\r\n    logLevel: config.LOG_ERROR,\r\n\r\n\r\n    // enable / disable watching file and executing tests whenever any file changes\r\n    autoWatch: false,\r\n\r\n\r\n    // start these browsers\r\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\r\n    browsers: ['PhantomJS'],\r\n\r\n    // Continuous Integration mode\r\n    // if true, Karma captures browsers, runs the tests and exits\r\n    singleRun: true,\r\n\r\n    // Concurrency level\r\n    // how many browser should be started simultaneous\r\n    concurrency: 1\r\n  })\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/.config/pretest.js":"'use strict'\r\n\r\nfunction get(uri) {\r\n\tvar xhr = new XMLHttpRequest()\r\n\txhr.open('GET', uri, false)\r\n\txhr.send()\r\n\tif(xhr.status !== 200)\r\n\t\tconsole.error('SVG.js fixture could not be loaded. Tests will fail.')\r\n\treturn xhr.responseText\r\n}\r\n\r\nfunction main() {\r\n\tvar style = document.createElement(\"style\")\r\n\tdocument.head.appendChild(style)\r\n\tstyle.sheet.insertRule( get('/base/spec/fixture.css'), 0 )\r\n\r\n\tdocument.body.innerHTML = get('/base/spec/fixture.svg')\r\n}\r\n\r\nmain()\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/arrange.js":"// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n    \r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n    \r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n    \r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n    \r\n    var i = this.position()\r\n    \r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/array.js":"// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/attr.js":"SVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n      \r\n      return a\r\n      \r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n      \r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n      \r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ? \r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n    \r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n      \r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n      \r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n      \r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n    \r\n    return this\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/bare.js":"\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/boxes.js":"SVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw.instance).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/clip.js":"SVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements \r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets \r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent \r\n      this.parent().removeElement(this)\r\n      \r\n      return this\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one \r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask \r\n    this.clipper.targets.push(this)\r\n    \r\n    // apply mask \r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/color.js":"// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n  \r\n  // initialize defaults \r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n  \r\n  if(!color) return\r\n  \r\n  // parse color \r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values \r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n      \r\n      // parse numeric values \r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n      \r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values \r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values \r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n    \r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n    \r\n  }\r\n    \r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined \r\n    if (!this.destination) return this\r\n\r\n    // normalise pos \r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color \r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n  \r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/container.js":"SVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/data.js":"\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n      \r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n    \r\n    return this\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/default.js":"\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke \r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position \r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size   \r\n  , width:              0\r\n  , height:             0\r\n    // radius   \r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient   \r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text \r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n  \r\n}","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/defs.js":"\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/element.js":"\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/ellipse.js":"SVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/event.js":"// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding, options) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, options || false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n    , namespace = ''\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding, options) {\r\n    SVG.on(this.node, event, listener, binding, options)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/fx.js":"SVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        // The condition is because some methods return a normal number instead\r\n        // of a SVG.Number\r\n        if(s.animations[i] instanceof SVG.Number)\r\n          source = new SVG.Number(source)\r\n\r\n        s.animations[i] = source.morph(s.animations[i])\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n          this.active = false\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, len, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n\r\n      if(!isEased)pos = this.situation.ease(pos)\r\n\r\n      this.situation.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable plot\r\n, plot: function() {\r\n    // We use arguments here since SVG.Line's plot method can be passed 4 parameters\r\n    return this.add('plot', arguments.length > 1 ? [].slice.call(arguments) : arguments[0])\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/gradient.js":"SVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n    \r\n    // store type \r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops \r\n      this.clear()\r\n      \r\n      // invoke passed block \r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n      \r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n  \r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes \r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/group.js":"SVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/helpers.js":"function pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) { \r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex \r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n    \r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n  \r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n  \r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/hyperlink.js":"SVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/image.js":"SVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n      \r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n        \r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n        \r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/line.js":"SVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/marker.js":"SVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content \r\n      this.clear()\r\n      \r\n      // invoke passed block \r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n      \r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n  \r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n    \r\n    return this.attr(attr, marker)\r\n  }\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/mask.js":"SVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements \r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets \r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent \r\n      this.parent().removeElement(this)\r\n      \r\n      return this\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one \r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask \r\n    this.masker.targets.push(this)\r\n    \r\n    // apply mask \r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n  \r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/matrix.js":"SVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, a, o != null ? o : a)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/memory.js":"SVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually \r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory \r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory \r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/nested.js":"SVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n    \r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/number.js":"// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/parent.js":"SVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n      \r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n    \r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n      \r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n      \r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n  \r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/patharray.js":"var pathHandlers = {\r\n  M: function(c, p, p0) {\r\n    p.x = p0.x = c[0]\r\n    p.y = p0.y = c[1]\r\n\r\n    return ['M', p.x, p.y]\r\n  },\r\n  L: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['L', c[0], c[1]]\r\n  },\r\n  H: function(c, p) {\r\n    p.x = c[0]\r\n    return ['H', c[0]]\r\n  },\r\n  V: function(c, p) {\r\n    p.y = c[0]\r\n    return ['V', c[0]]\r\n  },\r\n  C: function(c, p) {\r\n    p.x = c[4]\r\n    p.y = c[5]\r\n    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]\r\n  },\r\n  S: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['S', c[0], c[1], c[2], c[3]]\r\n  },\r\n  Q: function(c, p) {\r\n    p.x = c[2]\r\n    p.y = c[3]\r\n    return ['Q', c[0], c[1], c[2], c[3]]\r\n  },\r\n  T: function(c, p) {\r\n    p.x = c[0]\r\n    p.y = c[1]\r\n    return ['T', c[0], c[1]]\r\n  },\r\n  Z: function(c, p, p0) {\r\n    p.x = p0.x\r\n    p.y = p0.y\r\n    return ['Z']\r\n  },\r\n  A: function(c, p) {\r\n    p.x = c[5]\r\n    p.y = c[6]\r\n    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]\r\n  }\r\n}\r\n\r\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('')\r\n\r\nfor(var i = 0, il = mlhvqtcsa.length; i < il; ++i){\r\n  pathHandlers[mlhvqtcsa[i]] = (function(i){\r\n    return function(c, p, p0) {\r\n      if(i == 'H') c[0] = c[0] + p.x\r\n      else if(i == 'V') c[0] = c[0] + p.y\r\n      else if(i == 'A'){\r\n        c[5] = c[5] + p.x,\r\n        c[6] = c[6] + p.y\r\n      }\r\n      else\r\n        for(var j = 0, jl = c.length; j < jl; ++j) {\r\n          c[j] = c[j] + (j%2 ? p.y : p.x)\r\n        }\r\n\r\n      return pathHandlers[i](c, p, p0)\r\n    }\r\n  })(mlhvqtcsa[i].toUpperCase())\r\n}\r\n\r\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n    var arr = []\r\n      , p = new SVG.Point()\r\n      , p0 = new SVG.Point()\r\n      , index = 0\r\n      , len = array.length\r\n\r\n    do{\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[index])){\r\n        s = array[index]\r\n        ++index\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      arr.push(pathHandlers[s].call(null,\r\n          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),\r\n          p, p0\r\n        )\r\n      )\r\n\r\n    }while(len > index)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/path.js":"SVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/pattern.js":"SVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n      \r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n      \r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/pointarray.js":"// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/pointed.js":"// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height) \r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/point.js":"SVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/polyfill.js":"// Add CustomEvent to IE9 and IE10 \r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n  \r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n \r\n  w.requestAnimationFrame = w.requestAnimationFrame || \r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n      \r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n      \r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n \r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/poly.js":"SVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/rect.js":"SVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n    \r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/regex.js":"// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/selector.js":"// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/set.js":"SVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n      \r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n      \r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n  \r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/shape.js":"SVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/style.js":"SVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style \r\n      return this.node.style.cssText || ''\r\n    \r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed \r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n      \r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string \r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually \r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object \r\n        return this.node.style[camelCase(s)]\r\n      }\r\n    \r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n    \r\n    return this\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/sugar.js":"// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) : \r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/svg.js":"// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n    \r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n      \r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/symbol.js":"SVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/text.js":"SVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n  \r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n        \r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hy¡n\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/textpath.js":"SVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create path for text to run on\r\n    path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/transform.js":"SVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix, bbox\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      if(o.flip == 'x' || o.flip == 'y') {\r\n        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      } else {\r\n        if(o.offset == null) {\r\n          bbox = target.bbox()\r\n          o.flip = bbox.cx\r\n          o.offset = bbox.cy\r\n        } else {\r\n          o.flip = o.offset\r\n        }\r\n      }\r\n\r\n      matrix = new SVG.Matrix().flip(o.flip, o.offset)\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/umd.js":"(function(root, factory) {\r\n  /* istanbul ignore next */\r\n  if (typeof define === 'function' && define.amd) {\r\n    define(function(){\r\n      return factory(root, root.document)\r\n    })\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n<%= contents %>\r\n\r\nreturn SVG\r\n\r\n}));\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/ungroup.js":"SVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n    \r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n  \r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/use.js":"SVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element \r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n  \r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/utilities.js":"SVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n    \r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n    \r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n    \r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n    \r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/src/viewbox.js":"\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/adopter.js":"describe('Adopter', function() {\r\n  var path, polyline, polygon, linearGradient, radialGradient\r\n\r\n  beforeEach(function() {\r\n    path      = SVG.get('lineAB')\r\n    polyline  = SVG.get('inlineSVG').select('polyline').first()\r\n    polygon   = SVG.get('inlineSVG').select('polygon').first()\r\n    linearGradient   = SVG.get('inlineSVG').select('linearGradient').first()\r\n    radialGradient   = SVG.get('inlineSVG').select('radialGradient').first()\r\n  })\r\n\r\n  describe('with SVG.Doc instance', function() {\r\n    it('adopts the main svg document when parent() method is called on first level children', function() {\r\n      expect(path.parent() instanceof SVG.Doc).toBeTruthy()\r\n    })\r\n    it('defines a xmlns attribute', function() {\r\n      expect(path.parent().node.getAttribute('xmlns')).toBe(SVG.ns)\r\n    })\r\n    it('defines a version attribute', function() {\r\n      expect(path.parent().node.getAttribute('version')).toBe('1.1')\r\n    })\r\n    it('defines a xmlns:xlink attribute', function() {\r\n      expect(path.parent().node.getAttribute('xmlns:xlink')).toBe(SVG.xlink)\r\n    })\r\n    it('initializes a defs node', function() {\r\n      expect(path.parent()._defs).toBe(path.parent().defs())\r\n    })\r\n  })\r\n\r\n  describe('with SVG.Path instance', function() {\r\n    it('adopts an exiting path element', function() {\r\n      expect(path instanceof SVG.Path).toBeTruthy()\r\n    })\r\n    it('modifies an adopted element', function() {\r\n      path.fill('#f06')\r\n      expect(path.node.getAttribute('fill')).toBe('#ff0066')\r\n    })\r\n    it('parses d attribute to SVG.PathArray', function() {\r\n      expect(path.array() instanceof SVG.PathArray).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('with SVG.Polyline instance', function() {\r\n    it('parses points attribute to SVG.PointArray', function() {\r\n      expect(polyline.array() instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('with SVG.Polygon instance', function() {\r\n    it('parses points attribute to SVG.PointArray', function() {\r\n      expect(polygon.array() instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n  })\r\n  \r\n  describe('with linear SVG.Gradient instance', function() {\r\n    it('is instance of SVG.Gradient', function() {\r\n      expect(linearGradient instanceof SVG.Gradient).toBeTruthy()\r\n    })\r\n    it('has type of linear', function() {\r\n      expect(linearGradient.type).toBe('linearGradient') // actually it should be 'linear'. see #606\r\n    })\r\n  })\r\n\r\n  describe('with radial SVG.Gradient instance', function() {\r\n    it('is instance of SVG.Gradient', function() {\r\n      expect(radialGradient instanceof SVG.Gradient).toBeTruthy()\r\n    })\r\n    it('has type of radial', function() {\r\n      expect(radialGradient.type).toBe('radialGradient') // actually it should be 'radial'. see #606\r\n    })\r\n  })\r\n\r\n  describe('with node that has no matching svg.js class', function() {\r\n    it('wraps the node in the base SVG.Element class', function() {\r\n      var desc = SVG.get('inlineSVG').select('desc').first()\r\n      expect(desc instanceof SVG.Element).toBeTruthy()\r\n    })\r\n  })\r\n\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/arrange.js":"describe('Arrange', function() {\r\n  var e1, e2, e3\r\n\r\n  beforeEach(function() {\r\n    draw.clear()\r\n\r\n    e1 = draw.rect(100,100).move(10,10).attr('id', 'e1')\r\n    e2 = draw.ellipse(100,100).move(20,20).attr('id', 'e2')\r\n    e3 = draw.line(0,0,100,100).move(30,30).attr('id', 'e3')\r\n  })\r\n\r\n  describe('siblings()', function() {\r\n    it('returns all siblings of targeted element', function() {\r\n      expect(e1.siblings().length).toBe(3+parserInDoc)\r\n      expect(parser.concat([e1,e2,e3])).toEqual(e2.siblings())\r\n    })\r\n  })\r\n\r\n  describe('position()', function() {\r\n    it('returns the index position within it\\'s parent', function() {\r\n      expect(e1.siblings().length).toBe(3+parserInDoc)\r\n      expect(e1.position()).toBe(0+parserInDoc)\r\n      expect(e2.position()).toBe(1+parserInDoc)\r\n      expect(e3.position()).toBe(2+parserInDoc)\r\n    })\r\n  })\r\n\r\n  describe('next()', function() {\r\n    it('returns the next sibling within the parent element', function() {\r\n      expect(e1.next()).toBe(e2)\r\n      expect(e2.next()).toBe(e3)\r\n      expect(e3.next()).toBe(undefined)\r\n    })\r\n  })\r\n\r\n  describe('previous()', function() {\r\n    it('returns the previous sibling within the parent element', function() {\r\n      expect(e1.previous()).toBe(parser[0])\r\n      expect(e2.previous()).toBe(e1)\r\n      expect(e3.previous()).toBe(e2)\r\n    })\r\n  })\r\n\r\n  describe('forward()', function() {\r\n    it('returns the element itself', function() {\r\n      expect(e1.forward()).toBe(e1)\r\n    })\r\n    it('moves the element one step forward within its parent', function() {\r\n      e1.forward()\r\n      expect(e1.position()).toBe(1+parserInDoc)\r\n      expect(e2.position()).toBe(0+parserInDoc)\r\n      expect(e3.position()).toBe(2+parserInDoc)\r\n    })\r\n    it('keeps the last element at the same position', function() {\r\n      e3.forward()\r\n      expect(e3.position()).toBe(2+parserInDoc)\r\n    })\r\n    it('keeps the defs on top of the stack', function() {\r\n      draw.defs()\r\n      e3.forward()\r\n      expect(draw.node.childNodes[2+parserInDoc]).toBe(e3.node)\r\n      expect(draw.node.childNodes[3+parserInDoc]).toBe(draw.defs().node)\r\n    })\r\n  })\r\n\r\n  describe('backward()', function() {\r\n    it('returns the element itself', function() {\r\n      if(parserInDoc){\r\n        expect(parser[0].backward()).toBe(parser[0])\r\n      }else{\r\n        expect(e1.backward()).toBe(e1)\r\n      }\r\n    })\r\n    it('moves the element one step backwards within its parent', function() {\r\n      e3.backward()\r\n      expect(e1.position()).toBe(0+parserInDoc)\r\n      expect(e2.position()).toBe(2+parserInDoc)\r\n      expect(e3.position()).toBe(1+parserInDoc)\r\n    })\r\n    it('keeps the first element at the same position', function() {\r\n      e3.backward()\r\n      expect(e1.position()).toBe(0+parserInDoc)\r\n    })\r\n  })\r\n\r\n  describe('front()', function() {\r\n    it('returns the element itself', function() {\r\n      expect(e3.front()).toBe(e3)\r\n    })\r\n    it('moves the element to the top of the stack within its parent', function() {\r\n      e1.front()\r\n      expect(e1.position()).toBe(2+parserInDoc)\r\n      expect(e2.position()).toBe(0+parserInDoc)\r\n      expect(e3.position()).toBe(1+parserInDoc)\r\n    })\r\n    it('keeps the last element at the same position', function() {\r\n      e3.front()\r\n      expect(e3.position()).toBe(2+parserInDoc)\r\n    })\r\n    it('keeps the defs on top of the stack', function() {\r\n      e1.front()\r\n      expect(draw.node.childNodes[2+parserInDoc]).toBe(e1.node)\r\n      expect(draw.node.childNodes[3+parserInDoc]).toBe(draw.defs().node)\r\n    })\r\n  })\r\n\r\n  describe('back()', function() {\r\n    it('returns the element itself', function() {\r\n      expect(e3.back()).toBe(e3)\r\n    })\r\n    it('moves the element to the bottom of the stack within its parent', function() {\r\n      e3.back()\r\n      expect(e1.position()).toBe(1+parserInDoc)\r\n      expect(e2.position()).toBe(2+parserInDoc)\r\n      expect(e3.position()).toBe(0)\r\n    })\r\n    it('keeps the first element at the same position', function() {\r\n      e1.back()\r\n      expect(e1.position()).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('before()', function() {\r\n    it('returns the targeted element itself', function() {\r\n      expect(e3.before(e1)).toBe(e3)\r\n    })\r\n    it('inserts a given element before the targeted element', function() {\r\n      e3.before(e1)\r\n      expect(e1.position()).toBe(1+parserInDoc)\r\n      expect(e2.position()).toBe(0+parserInDoc)\r\n      expect(e3.position()).toBe(2+parserInDoc)\r\n    })\r\n    it('moves elements between containers', function() {\r\n      var group = draw.group()\r\n        , e4 = group.rect(80,120)\r\n        , e5 = group.rect(80,120)\r\n        , e6 = group.rect(80,120)\r\n\r\n      e2.before(e5)\r\n      expect(e1.position()).toBe(0+parserInDoc)\r\n      expect(e2.position()).toBe(2+parserInDoc)\r\n      expect(e3.position()).toBe(3+parserInDoc)\r\n      expect(e5.position()).toBe(1+parserInDoc)\r\n    })\r\n  })\r\n\r\n  describe('after()', function() {\r\n    it('returns the targeted element itself', function() {\r\n      expect(e3.after(e1)).toBe(e3)\r\n    })\r\n    it('inserts a given element after the targeted element', function() {\r\n      e3.after(e1)\r\n      expect(e1.position()).toBe(2+parserInDoc)\r\n      expect(e2.position()).toBe(0+parserInDoc)\r\n      expect(e3.position()).toBe(1+parserInDoc)\r\n    })\r\n    it('moves elements between containers', function() {\r\n      var group = draw.group()\r\n        , e4 = group.rect(80,120)\r\n        , e5 = group.rect(80,120)\r\n        , e6 = group.rect(80,120)\r\n\r\n      e2.after(e5)\r\n      expect(e1.position()).toBe(0+parserInDoc)\r\n      expect(e2.position()).toBe(1+parserInDoc)\r\n      expect(e3.position()).toBe(3+parserInDoc)\r\n      expect(e5.position()).toBe(2+parserInDoc)\r\n    })\r\n  })\r\n\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/array.js":"describe('Array', function () {\r\n  var array, arr1, arr2\r\n\r\n  it('parses a matrix array correctly to string', function() {\r\n    array = new SVG.Array([ .343,  .669, .119, 0,   0\r\n                          , .249, -.626, .130, 0,   0\r\n                          , .172,  .334, .111, 0,   0\r\n                          , .000,  .000, .000, 1,  -0 ])\r\n\r\n    expect(array + '').toBe('0.343 0.669 0.119 0 0 0.249 -0.626 0.13 0 0 0.172 0.334 0.111 0 0 0 0 0 1 0')\r\n  })\r\n  it('parses space seperated string and converts it to array', function() {\r\n    expect((new SVG.Array('1 2 3 4')).value).toEqual([1,2,3,4])\r\n  })\r\n  it('parses comma seperated string and converts it to array', function() {\r\n    expect((new SVG.Array('1,2,3,4')).value).toEqual([1,2,3,4])\r\n  })\r\n  describe('reverse()', function() {\r\n    it('reverses the array', function() {\r\n      array = new SVG.Array([1 ,2 ,3, 4, 5]).reverse()\r\n      expect(array.value).toEqual([5, 4, 3, 2, 1])\r\n    })\r\n    it('returns itself', function() {\r\n      array = new SVG.Array()\r\n      expect(array.reverse()).toBe(array)\r\n    })\r\n  })\r\n  describe('clone()', function() {\r\n    it('creates a deep clone of the array', function() {\r\n      array = new SVG.Array([1, 2, 3, 4, 5])\r\n\r\n      clone = array.clone()\r\n\r\n      expect(array).toEqual(clone)\r\n      expect(array).not.toBe(clone)\r\n\r\n      array = new SVG.Array([[1,2], [3, 4], [5]])\r\n      clone = array.clone()\r\n\r\n      expect(array).toEqual(array)\r\n      for(var i = 0, len = array.value.length; i; ++i){\r\n        expect(array[i]).not.toBe(clone[i])\r\n      }\r\n    })\r\n    it('also works with PointArray', function() {\r\n      array = new SVG.PointArray([1,2,3,4,5,6])\r\n      clone = array.clone()\r\n\r\n      expect(array).toEqual(clone)\r\n      expect(array).not.toBe(clone)\r\n\r\n      for(var i = 0, len = array.value.length; i; ++i){\r\n        expect(array[i]).not.toBe(clone[i])\r\n      }\r\n    })\r\n    it('also works with PathArray', function() {\r\n      array = new SVG.PathArray([['M',1,2],['L',3,4],['L',5,6]])\r\n      clone = array.clone()\r\n\r\n      expect(array).toEqual(clone)\r\n      expect(array).not.toBe(clone)\r\n\r\n      for(var i = 0, len = array.value.length; i; ++i){\r\n        expect(array[i]).not.toBe(clone[i])\r\n      }\r\n    })\r\n  })\r\n  describe('morph()', function() {\r\n    it('adds entries so that destination array has equal length', function() {\r\n\r\n      arr1 = new SVG.Array([1,2,3,4,5])\r\n      arr2 = new SVG.Array([1,2,3,4])\r\n\r\n      arr1.morph(arr2)\r\n\r\n      expect(arr1.destination.length).toBe(arr1.value.length)\r\n    })\r\n    it('does the same the other way round', function() {\r\n\r\n      arr1 = new SVG.Array([1,2,3,4])\r\n      arr2 = new SVG.Array([1,2,3,4,5])\r\n\r\n      arr1.morph(arr2)\r\n\r\n      expect(arr1.destination.length).toBe(arr1.value.length)\r\n    })\r\n  })\r\n  describe('settle()', function() {\r\n    it('cleans up any duplicate value', function() {\r\n      array = new SVG.Array([1,2,3,4,5,4,3,2,1])\r\n      expect(array.settle().sort()).toEqual([1,2,3,4,5].sort())\r\n    })\r\n  })\r\n  describe('at()', function() {\r\n    beforeEach(function() {\r\n      arr1 = new SVG.Array([1,2,3,4])\r\n      arr2 = new SVG.Array([2,3,4,5])\r\n    })\r\n\r\n    it('returns a new array instance', function() {\r\n      arr1.morph(arr2)\r\n\r\n      start = arr1.at(0)\r\n      end = arr1.at(1)\r\n\r\n      expect(start instanceof SVG.Array).toBeTruthy()\r\n      expect(start).not.toBe(arr1)\r\n\r\n      expect(end instanceof SVG.Array).toBeTruthy()\r\n      expect(end).not.toBe(arr2)\r\n    })\r\n    it('morphs all values of the array', function() {\r\n      arr1.morph(arr2)\r\n      expect(arr1.at(0.5).value).toEqual([1.5, 2.5, 3.5, 4.5])\r\n    })\r\n    it('returns itself if no destination was specified', function() {\r\n      expect(arr1.at(0.5)).toBe(arr1)\r\n    })\r\n  })\r\n})\r\n\r\n\r\ndescribe('PointArray', function () {\r\n  it('parses a string to a point array', function() {\r\n    var array = new SVG.PointArray('0,1 -.05,7.95 1000.0001,-200.222')\r\n\r\n    expect(array.valueOf()).toEqual([[0, 1], [-0.05, 7.95], [1000.0001, -200.222]])\r\n  })\r\n  it('parses a points array correctly to string', function() {\r\n    var array = new SVG.PointArray([[0,.15], [-100,-3.141592654], [50,100]])\r\n\r\n    expect(array + '').toBe('0,0.15 -100,-3.141592654 50,100')\r\n  })\r\n  it('parses a flat array of x/y coordinates to a point array', function() {\r\n    var array = new SVG.PointArray([1,4, 5,68, 12,24])\r\n\r\n    expect(array.value).toEqual([[1,4], [5,68], [12,24]])\r\n  })\r\n  it('parses points with space delimitered x/y coordinates', function() {\r\n    var array = new SVG.PointArray('221.08 191.79 0.46 191.79 0.46 63.92 63.8 0.46 284.46 0.46 284.46 128.37 221.08 191.79')\r\n\r\n    expect(array + '').toBe('221.08,191.79 0.46,191.79 0.46,63.92 63.8,0.46 284.46,0.46 284.46,128.37 221.08,191.79')\r\n  })\r\n  it('parses points with comma delimitered x/y coordinates', function() {\r\n    var array = new SVG.PointArray('221.08,191.79,0.46,191.79,0.46,63.92,63.8,0.46,284.46,0.46,284.46,128.37,221.08,191.79')\r\n\r\n    expect(array + '').toBe('221.08,191.79 0.46,191.79 0.46,63.92 63.8,0.46 284.46,0.46 284.46,128.37 221.08,191.79')\r\n  })\r\n  it('parses points with comma and space delimitered x/y coordinates', function() {\r\n    var array = new SVG.PointArray('221.08, 191.79, 0.46, 191.79, 0.46, 63.92, 63.8, 0.46, 284.46, 0.46, 284.46, 128.37, 221.08, 191.79')\r\n\r\n    expect(array + '').toBe('221.08,191.79 0.46,191.79 0.46,63.92 63.8,0.46 284.46,0.46 284.46,128.37 221.08,191.79')\r\n  })\r\n  it('parses points with space and comma delimitered x/y coordinates', function() {\r\n    var array = new SVG.PointArray('221.08 ,191.79 ,0.46 ,191.79 ,0.46 ,63.92 ,63.8 ,0.46 ,284.46 ,0.46 ,284.46 ,128.37 ,221.08 ,191.79')\r\n\r\n    expect(array + '').toBe('221.08,191.79 0.46,191.79 0.46,63.92 63.8,0.46 284.46,0.46 284.46,128.37 221.08,191.79')\r\n  })\r\n  it('parses points with redundant spaces at the end', function() {\r\n    var array = new SVG.PointArray('2176.6,1708.8 2176.4,1755.8 2245.8,1801.5 2297,1787.8  ')\r\n\r\n    expect(array + '').toBe('2176.6,1708.8 2176.4,1755.8 2245.8,1801.5 2297,1787.8')\r\n  })\r\n  it('parses points with space delimitered x/y coordinates - even with leading or trailing space', function() {\r\n    var array = new SVG.PointArray('  1 2 3 4  ')\r\n\r\n    expect(array + '').toBe('1,2 3,4')\r\n  })\r\n  it('parses odd number of points with space delimitered x/y coordinates and silently remove the odd point', function() {\r\n    // this  is according to spec: https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n\r\n    var array = new SVG.PointArray('1 2 3')\r\n\r\n    expect(array + '').toBe('1,2')\r\n  })\r\n  it('parses odd number of points in a flat array of x/y coordinates and silently remove the odd point', function() {\r\n    // this  is according to spec: https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n\r\n    var array = new SVG.PointArray([1, 2, 3])\r\n\r\n    expect(array.value).toEqual([[1,2]])\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('correctly sizes the points over the whole area', function() {\r\n      var array = new SVG.PointArray([10, 10, 20, 20, 30, 30])\r\n      expect(array.size(60, 60).valueOf()).toEqual([[10,10], [40, 40], [70, 70]])\r\n    })\r\n\r\n    it('let coordinates untouched when width/height is zero', function() {\r\n      var array = new SVG.PointArray([10, 10, 10, 20, 10, 30])\r\n      expect(array.size(60, 60).valueOf()).toEqual([[10,10], [10, 40], [10, 70]])\r\n\r\n      array = new SVG.PointArray([10, 10, 20, 10, 30, 10])\r\n      expect(array.size(60, 60).valueOf()).toEqual([[10,10], [40, 10], [70, 10]])\r\n    })\r\n\r\n  })\r\n\r\n  describe('at()', function() {\r\n    var arr1, arr2\r\n\r\n    beforeEach(function() {\r\n      arr1 = new SVG.PointArray([[1,2],[3,4]])\r\n      arr2 = new SVG.Array([[2,3],[4,5]])\r\n    })\r\n\r\n    it('returns a new array instance', function() {\r\n      arr1.morph(arr2)\r\n\r\n      start = arr1.at(0)\r\n      end = arr1.at(1)\r\n\r\n      expect(start instanceof SVG.PointArray).toBeTruthy()\r\n      expect(start).not.toBe(arr1)\r\n\r\n      expect(end instanceof SVG.PointArray).toBeTruthy()\r\n      expect(end).not.toBe(arr2)\r\n    })\r\n    it('morphs all values of the array', function() {\r\n      arr1.morph(arr2)\r\n      expect(arr1.at(0.5).value).toEqual([[1.5, 2.5], [3.5, 4.5]])\r\n    })\r\n    it('returns itself if no destination was specified', function() {\r\n      expect(arr1.at(0.5)).toBe(arr1)\r\n    })\r\n  })\r\n})\r\n\r\ndescribe('PathArray', function () {\r\n  var p1, p2, p3, p4, p5, p6, p7\r\n\r\n  beforeEach(function() {\r\n    p1 = new SVG.PathArray('m10 10 h 80 v 80 h -80 l 300 400 z')\r\n    p2 = new SVG.PathArray('m10 80 c 40 10 65 10 95 80 s 150 150 180 80 t 300 300 q 52 10 95 80 z')\r\n    p3 = new SVG.PathArray('m80 80 A 45 45, 0, 0, 0, 125 125 L 125 80 z')\r\n    p4 = new SVG.PathArray('M215.458,245.23c0,0,77.403,0,94.274,0S405,216.451,405,138.054S329.581,15,287.9,15c-41.68,0-139.924,0-170.688,0C86.45,15,15,60.65,15,134.084c0,73.434,96.259,112.137,114.122,112.137C146.984,246.221,215.458,245.23,215.458,245.23z')\r\n    p5 = new SVG.PathArray(\r\n      'M10 10-45-30.5.5 .89L2e-2.5.5.5-.5C.5.5.5.5.5.5L-3-4z'\r\n    )\r\n\r\n  })\r\n\r\n  it('converts to absolute values', function() {\r\n    expect(p1.toString()).toBe('M10 10H90V90H10L310 490Z ')\r\n    expect(p2.toString()).toBe('M10 80C50 90 75 90 105 160S255 310 285 240T585 540Q637 550 680 620Z ')\r\n    expect(p3.toString()).toBe('M80 80A45 45 0 0 0 125 125L125 80Z ')\r\n    expect(p4.toString()).toBe('M215.458 245.23C215.458 245.23 292.861 245.23 309.73199999999997 245.23S405 216.451 405 138.054S329.581 15 287.9 15C246.21999999999997 15 147.97599999999997 15 117.21199999999999 15C86.45 15 15 60.65 15 134.084C15 207.518 111.259 246.221 129.122 246.221C146.984 246.221 215.458 245.23 215.458 245.23Z ')\r\n  })\r\n\r\n  it('parses difficult syntax correctly', function() {\r\n    expect(p5.toString()).toBe('M10 10L-45 -30.5L0.5 0.89L0.02 0.5L0.5 -0.5C0.5 0.5 0.5 0.5 0.5 0.5L-3 -4Z ')\r\n  })\r\n  \r\n  it('parses flat arrays correctly', function() {\r\n    p6 = new SVG.PathArray([ 'M', 0, 0, 'L', 100, 100, 'z' ])\r\n    expect(p6.toString()).toBe('M0 0L100 100Z ')\r\n  })  \r\n  \r\n  it('parses nested arrays correctly', function() {\r\n    p7 = new SVG.PathArray([ ['M', 0, 0], ['L', 100, 100], ['z'] ])\r\n    expect(p7.toString()).toBe('M0 0L100 100Z ')\r\n  })\r\n\r\n  // this test is designed to cover a certain line but it doesnt work because of #608\r\n  it('returns the valueOf when PathArray is given', function() {\r\n    var p = new SVG.PathArray('m10 10 h 80 v 80 h -80 l 300 400 z')\r\n\r\n    expect((new SVG.PathArray(p)).value).toEqual(p.value)\r\n  })\r\n\r\n  it('can handle all formats which can be used', function() {\r\n    // when no command is specified after move, line is used automatically (specs say so)\r\n    expect(new SVG.PathArray('M10 10 80 80 30 30 Z').toString()).toBe('M10 10L80 80L30 30Z ')\r\n\r\n    // parsing can handle 0.5.3.3.2 stuff\r\n    expect(new SVG.PathArray('M10 10L.5.5.3.3Z').toString()).toBe('M10 10L0.5 0.5L0.3 0.3Z ')\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('moves all points in a straight path', function() {\r\n      expect(p1.move(100,200).toString()).toBe('M100 200H180V280H100L400 680Z ')\r\n    })\r\n    it('moves all points in a curved path', function() {\r\n      expect(p2.move(100,200).toString()).toBe('M100 200C140 210 165 210 195 280S345 430 375 360T675 660Q727 670 770 740Z ')\r\n    })\r\n    it('moves all points in a arc path', function() {\r\n      expect(p3.move(100,200).toString()).toBe('M100 200A45 45 0 0 0 145 245L145 200Z ')\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('resizes all points in a straight path', function() {\r\n      expect(p1.size(600,200).toString()).toBe('M10 10H170V43.333333333333336H10L610 210Z ')\r\n    })\r\n    it('resizes all points in a curved path', function() {\r\n      expect(p2.size(600,200).toString()).toBe('M10 80C45.82089552238806 83.70370370370371 68.2089552238806 83.70370370370371 95.07462686567165 109.62962962962963S229.40298507462686 165.1851851851852 256.2686567164179 139.25925925925927T524.9253731343283 250.37037037037038Q571.4925373134329 254.07407407407408 610 280Z ')\r\n    })\r\n    it('resizes all points in a arc path', function() {\r\n      var expected = [\r\n        ['M', 80, 80],\r\n        ['A', 600, 200, 0, 0, 0, 680, 280],\r\n        ['L', 680, 80],\r\n        ['Z']\r\n      ]\r\n\r\n      var toBeTested = p3.size(600,200).value\r\n      for(var i in toBeTested) {\r\n        expect(toBeTested[i].shift().toUpperCase()).toBe(expected[i].shift().toUpperCase())\r\n        for(var j in toBeTested[i]) {\r\n          expect(toBeTested[i][j]).toBeCloseTo(expected[i][j])\r\n        }\r\n      }\r\n    })\r\n  })\r\n\r\n  describe('equalCommands()', function() {\r\n    it('return true if the passed path array use the same commands', function() {\r\n      var pathArray1 = new SVG.PathArray('m -1500,-478 a 292,195 0 0 1 262,205 l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n        , pathArray2 = new SVG.PathArray('m  -680, 527 a 292,195 0 0 1 262,205 l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n\r\n      expect(pathArray1.equalCommands(pathArray2)).toBe(true)\r\n    })\r\n    it('return false if the passed path array does not use the same commands', function() {\r\n      var pathArray1 = new SVG.PathArray('m -1500,-478 a 292,195 0 0 1 262,205   l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n        , pathArray2 = new SVG.PathArray('m - 663, 521 c 147,178 118,-25 245,210 l -565,319 c 0,0 -134,-374 51,-251 185,122 268,-278 268,-278 z')\r\n\r\n      expect(pathArray1.equalCommands(pathArray2)).toBe(false)\r\n    })\r\n  })\r\n\r\n  describe('morph()', function() {\r\n    it('should set the attribute destination to the passed path array when it have the same comands as this path array', function() {\r\n      var pathArray1 = new SVG.PathArray('m -1500,-478 a 292,195 0 0 1 262,205 l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n        , pathArray2 = new SVG.PathArray('m  -680, 527 a 292,195 0 0 1 262,205 l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n\r\n      pathArray1.morph(pathArray2)\r\n      expect(pathArray1.destination).toEqual(pathArray2)\r\n    })\r\n    it('should set the attribute destination to null when the passed path array does not have the same comands as this path array', function() {\r\n      var pathArray1 = new SVG.PathArray('m -1500,-478 a 292,195 0 0 1 262,205   l -565,319 c 0,0 -134,-374 51,-251 185,122 251,-273 251,-273 z')\r\n        , pathArray2 = new SVG.PathArray('m - 663, 521 c 147,178 118,-25 245,210 l -565,319 c 0,0 -134,-374 51,-251 185,122 268,-278 268,-278 z')\r\n\r\n      pathArray1.morph(pathArray2)\r\n      expect(pathArray1.destination).toBeNull()\r\n    })\r\n  })\r\n\r\n  describe('at()', function() {\r\n    it('returns a morphed path array at a given position', function() {\r\n      var pathArray1 = new SVG.PathArray(\"M  63 25 A 15 15 0 0 1  73 40 A 15 15 0 0 1  61 53 C  49 36  50 59  50 59 L  33 55 Z\")\r\n        , pathArray2 = new SVG.PathArray(\"M 132 40 A 15 15 0 0 1 141 54 A 15 15 0 0 1 130 67 C 118 51 119 73 119 73 L 103 69 Z\")\r\n        , morphedPathArray = pathArray1.morph(pathArray2).at(0.5)\r\n        , sourceArray = pathArray1.value, destinationArray = pathArray1.destination.value\r\n        , morphedArray = morphedPathArray.value\r\n        , i, il, j, jl\r\n\r\n      expect(morphedArray.length).toBe(sourceArray.length)\r\n\r\n      // For all the commands\r\n      for(i = 0, il = sourceArray.length; i < il; i++) {\r\n        // Expect the current command to be the same\r\n        expect(morphedArray[i][0]).toBe(sourceArray[i][0])\r\n        expect(morphedArray[i].length).toBe(sourceArray[i].length)\r\n\r\n        // For all the parameters of the current command\r\n        for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n          expect(morphedArray[i][j]).toBe((sourceArray[i][j] + destinationArray[i][j]) / 2)\r\n        }\r\n      }\r\n    })\r\n    it('should interpolate flags and booleans as fractions between zero and one, with any non-zero value considered to be a value of one/true', function() {\r\n      // Only the Elliptical arc command use flags, it has the following form:\r\n      // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      var pathArray1 = new SVG.PathArray('M  13 13 A 25 37 0 0 1  43 25')\r\n        , pathArray2 = new SVG.PathArray('M 101 55 A 25 37 0 1 0 130 67')\r\n        , morphedPathArray\r\n\r\n      pathArray1.morph(pathArray2)\r\n\r\n      // The morphedPathArray.value contain 2 commands: [['M', ...], ['A', ...]]\r\n      // Elliptical arc command in a path array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      morphedPathArray = pathArray1.at(0)\r\n      expect(morphedPathArray.value[1][4]).toBe(0)\r\n      expect(morphedPathArray.value[1][5]).toBe(1)\r\n\r\n      morphedPathArray = pathArray1.at(0.5)\r\n      expect(morphedPathArray.value[1][4]).toBe(1)\r\n      expect(morphedPathArray.value[1][5]).toBe(1)\r\n\r\n      morphedPathArray = pathArray1.at(1)\r\n      expect(morphedPathArray.value[1][4]).toBe(1)\r\n      expect(morphedPathArray.value[1][5]).toBe(0)\r\n    })\r\n    it('return itself if the destination attribute is null', function(){\r\n      var pathArray = new SVG.PathArray('M  13 13 A 25 37 0 0 1  43 25')\r\n      pathArray.destination = null\r\n      expect(pathArray.at(0.45)).toBe(pathArray)\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/bare.js":"describe('Bare', function() {\r\n\r\n  describe('element()', function() {\r\n    var element\r\n\r\n    beforeEach(function() {\r\n      element = draw.element('rect')\r\n    })\r\n\r\n    it('creates an instance of SVG.Bare', function() {\r\n      expect(element instanceof SVG.Bare).toBeTruthy()\r\n    })\r\n    it('creates element in called parent', function() {\r\n      expect(element.parent()).toBe(draw)\r\n    })\r\n    it('inherits from given parent', function() {\r\n      expect(draw.element('g', SVG.Container).rect).toBeTruthy()\r\n      expect(draw.element('g', SVG.Container).group).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('words()', function() {\r\n    it('inserts plain text in a node', function() {\r\n      var element = draw.element('title').words('These are some words.').id(null)\r\n      var result = element.svg()\r\n      expect(\r\n           result == '<title>These are some words.</title>'\r\n        || result == '<title xmlns=\"http://www.w3.org/2000/svg\">These are some words.</title>'\r\n      ).toBe(true)\r\n    })\r\n    it('removes all nodes before adding words', function() {\r\n      var element = draw.element('title').words('These are some words.').id(null)\r\n      element.words('These are some words.')\r\n      var result = element.svg()\r\n      expect(\r\n           result == '<title>These are some words.</title>'\r\n        || result == '<title xmlns=\"http://www.w3.org/2000/svg\">These are some words.</title>'\r\n      ).toBe(true)\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/boxes.js":"describe('Box', function() {\r\n  it('creates a new instance without passing anything', function() {\r\n    var box = new SVG.Box\r\n\r\n    expect(box instanceof SVG.Box).toBe(true)\r\n    expect(box).toEqual(jasmine.objectContaining({\r\n      x:0, y:0, cx:0, cy:0, width:0, height:0\r\n    }))\r\n  })\r\n\r\n  it('creates a new instance with 4 arguments given', function() {\r\n    var box = new SVG.Box(10, 20, 100, 50)\r\n\r\n    expect(box instanceof SVG.Box).toBe(true)\r\n    expect(box).toEqual(jasmine.objectContaining({\r\n      x:10, y:20, cx:60, cy:45, width:100, height:50\r\n    }))\r\n  })\r\n\r\n  it('creates a new instance with object given', function() {\r\n    var box = new SVG.Box({x:10, y:20, width: 100, height:50})\r\n\r\n    expect(box instanceof SVG.Box).toBe(true)\r\n    expect(box).toEqual(jasmine.objectContaining({\r\n      x:10, y:20, cx:60, cy:45, width:100, height:50\r\n    }))\r\n  })\r\n\r\n  describe('merge()', function() {\r\n    it('merges various bounding boxes', function() {\r\n      var box1 = new SVG.Box(50, 50, 100, 100)\r\n      var box2 = new SVG.Box(300, 400, 100, 100)\r\n      var box3 = new SVG.Box(500, 100, 100, 100)\r\n      var merged = box1.merge(box2).merge(box3)\r\n\r\n      expect(merged).toEqual(jasmine.objectContaining({\r\n        x: 50, y: 50, cx: 325, cy: 275, width: 550, height: 450\r\n      }))\r\n    })\r\n    it('returns a new instance', function() {\r\n      var box1 = new SVG.Box(50, 50, 100, 100)\r\n      var box2 = new SVG.Box(300, 400, 100, 100)\r\n      var merged = box1.merge(box2)\r\n      expect(box1).not.toBe(merged)\r\n      expect(box2).not.toBe(merged)\r\n\r\n      expect(merged instanceof SVG.Box).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('transform()', function() {\r\n    it('transforms the box with given matrix', function() {\r\n      var box1 = new SVG.Box(50, 50, 100, 100).transform(new SVG.Matrix(1,0,0,1,20,20))\r\n      var box2 = new SVG.Box(50, 50, 100, 100).transform(new SVG.Matrix(2,0,0,2,0,0))\r\n      var box3 = new SVG.Box(-200, -200, 100, 100).transform(new SVG.Matrix(1,0,0,1,-20,-20))\r\n\r\n      expect(box1).toEqual(jasmine.objectContaining({\r\n        x: 70, y: 70, cx: 120, cy: 120, width: 100, height: 100\r\n      }))\r\n\r\n      expect(box2).toEqual(jasmine.objectContaining({\r\n        x: 100, y: 100, cx: 200, cy: 200, width: 200, height: 200\r\n      }))\r\n\r\n      expect(box3).toEqual(jasmine.objectContaining({\r\n        x: -220, y: -220, cx: -170, cy: -170, width: 100, height: 100\r\n      }))\r\n    })\r\n  })\r\n})\r\n\r\ndescribe('BBox', function() {\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('creates a new instance from an element', function() {\r\n    var rect = draw.rect(100, 100).move(100, 25)\r\n    var box = new SVG.BBox(rect)\r\n\r\n    expect(box).toEqual(jasmine.objectContaining({\r\n      x: 100, y: 25, cx: 150, cy: 75, width: 100, height: 100\r\n    }))\r\n  })\r\n\r\n  describe('merge()', function() {\r\n    it('returns an instance of SVG.BBox', function() {\r\n      var box1 = new SVG.BBox(50, 50, 100, 100)\r\n      var box2 = new SVG.BBox(300, 400, 100, 100)\r\n      var merged = box1.merge(box2)\r\n\r\n      expect(merged instanceof SVG.BBox).toBe(true)\r\n    })\r\n  })\r\n\r\n})\r\n\r\ndescribe('TBox', function() {\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('should map to RBox and be removed in 3.x', function() {\r\n    var rect = draw.rect(100, 100).move(100, 25).stroke({width:0})\r\n    var tbox = rect.tbox()\r\n\r\n    expect(tbox.x).toBe(100)\r\n    expect(tbox.y).toBeCloseTo(25)\r\n\r\n    rect.transform({ scale: 1.5 })\r\n    tbox = rect.tbox()\r\n    expect(tbox.x).toBe(75)\r\n    expect(tbox.y).toBe(0)\r\n\r\n    rect.transform({ skewX: 5 })\r\n    tbox = rect.tbox()\r\n    expect(tbox.x|0).toBe(68)\r\n    expect(tbox.y|0).toBe(0)\r\n  })\r\n\r\n})\r\n\r\ndescribe('RBox', function() {\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('creates a new instance from an element', function() {\r\n    var rect = draw.rect(100, 100).move(100, 25).stroke({width:0})\r\n    var box = new SVG.RBox(rect).transform(rect.doc().screenCTM().inverse()).addOffset()\r\n    expect(window.roundBox(box)).toEqual(jasmine.objectContaining({\r\n      x: 100, y: 25, cx: 150, cy: 75, width: 100, height: 100\r\n    }))\r\n  })\r\n\r\n  describe('merge()', function() {\r\n    it('returns an instance of SVG.RBox', function() {\r\n      var box1 = new SVG.RBox(50, 50, 100, 100)\r\n      var box2 = new SVG.RBox(300, 400, 100, 100)\r\n      var merged = box1.merge(box2)\r\n\r\n      expect(merged instanceof SVG.RBox).toBe(true)\r\n    })\r\n  })\r\n})\r\n\r\ndescribe('Boxes', function() {\r\n  var rect, nested, offset\r\n\r\n  beforeEach(function() {\r\n    offset = draw.screenCTM()\r\n    draw.viewbox(100,100, 200, 200)\r\n    nested = draw.nested().size(200, 200).move(100,100).viewbox(0, 0, 100, 100)\r\n    rect = nested.rect(50, 180).stroke({width:0}).move(25, 90).scale(2, 0, 0).transform({x:10, y:10}, true)\r\n  })\r\n  afterEach(function() {\r\n    draw.clear().attr('viewBox', null)\r\n  })\r\n\r\n  describe('bbox()', function() {\r\n    it('returns an instance of SVG.BBox', function() {\r\n      expect(rect.bbox() instanceof SVG.BBox).toBeTruthy()\r\n    })\r\n    it('matches the size of the target element, ignoring transformations', function() {\r\n      var box = rect.bbox()\r\n\r\n      expect(box).toEqual(jasmine.objectContaining({\r\n        x: 25, y: 90, cx: 50, cy: 180, width: 50, height: 180\r\n      }))\r\n    })\r\n    it('returns a box even if the element is not in the dom', function() {\r\n      var line = new SVG.Line().plot(0, 0, 50, 50)\r\n      var box = line.bbox()\r\n\r\n      expect(box).toEqual(jasmine.objectContaining({\r\n        x: 0, y: 0, width: 50, height: 50\r\n      }))\r\n\r\n      expect('Should not result into infinite loop').toBe('Should not result into infinite loop')\r\n    })\r\n    it('returns a box even if the element is not in the dom and invisible', function() {\r\n      var line = new SVG.Line().plot(0, 0, 50, 50).hide()\r\n      var box = line.bbox()\r\n\r\n      expect(box).toEqual(jasmine.objectContaining({\r\n        x: 0, y: 0, width: 50, height: 50\r\n      }))\r\n\r\n      expect('Should not result into infinite loop').toBe('Should not result into infinite loop')\r\n    })\r\n  })\r\n\r\n  describe('rbox()', function() {\r\n    it('returns an instance of SVG.RBox', function() {\r\n      expect(rect.rbox() instanceof SVG.RBox).toBeTruthy()\r\n    })\r\n\r\n    it('returns the elements box in absolute screen coordinates by default', function() {\r\n      var box = rect.rbox()\r\n\r\n      expect(window.roundBox(box)).toEqual(jasmine.objectContaining(window.roundBox({\r\n        x: 70 + offset.e, y: 200 + offset.f, width: 100, height: 360\r\n      })))\r\n\r\n    })\r\n\r\n    it('returns the elements box in coordinates of given element (doc)', function() {\r\n      var box = rect.rbox(draw)\r\n\r\n      expect(window.roundBox(box)).toEqual(jasmine.objectContaining({\r\n        x: 240, y: 500, width: 200, height: 720\r\n      }))\r\n    })\r\n\r\n    it('returns the elements box in coordinates of given element (nested)', function() {\r\n      var box = rect.rbox(nested)\r\n\r\n      expect(window.roundBox(box)).toEqual(jasmine.objectContaining({\r\n        x: 70, y: 200, width: 100, height: 360\r\n      }))\r\n    })\r\n  })\r\n\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/circle.js":"describe('Circle', function() {\r\n  var circle\r\n  \r\n  beforeEach(function() {\r\n    circle = draw.circle(240)\r\n  })\r\n  \r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n  \r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(circle.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      circle.x(123)\r\n      var box = circle.bbox()\r\n      expect(box.x).toBeCloseTo(123)\r\n    })\r\n  })\r\n  \r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(circle.y()).toBe(0)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      circle.y(345)\r\n      var box = circle.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n  \r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(circle.cx()).toBe(120)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      circle.cx(123)\r\n      var box = circle.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n  \r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(circle.cy()).toBe(120)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      circle.cy(345)\r\n      var box = circle.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('radius()', function() {\r\n    it('sets the r attribute with the first argument', function() {\r\n      circle.radius(10)\r\n      expect(circle.node.getAttribute('r')).toBe('10')\r\n    })\r\n  })\r\n\r\n  describe('rx()', function() {\r\n    it('sets the r attribute with the first argument', function() {\r\n      circle.rx(11)\r\n      expect(circle.node.getAttribute('r')).toBe('11')\r\n    })\r\n    it('gets the r attribute without and argument', function() {\r\n      circle.rx()\r\n      expect(circle.node.getAttribute('r')).toBe('120')\r\n    })\r\n  })\r\n\r\n  describe('ry()', function() {\r\n    it('sets the r attribute with the first argument', function() {\r\n      circle.ry(12)\r\n      expect(circle.node.getAttribute('r')).toBe('12')\r\n    })\r\n    it('gets the r attribute without and argument', function() {\r\n      circle.ry()\r\n      expect(circle.node.getAttribute('r')).toBe('120')\r\n    })\r\n  })\r\n  \r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      circle.move(123, 456)\r\n      var box = circle.bbox()\r\n      expect(box.x).toBeCloseTo(123)\r\n      expect(box.y).toBe(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      circle.move(50, 60)\r\n      circle.dx(100)\r\n      expect(circle.node.getAttribute('cx')).toBe('270')\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      circle.move(50, 60)\r\n      circle.dy(120)\r\n      expect(circle.node.getAttribute('cy')).toBe('300')\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      circle.move(50,60)\r\n      circle.dmove(80, 25)\r\n      expect(circle.node.getAttribute('cx')).toBe('250')\r\n      expect(circle.node.getAttribute('cy')).toBe('205')\r\n    })\r\n  })\r\n  \r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      circle.center(321,567)\r\n      var box = circle.bbox()\r\n      expect(box.cx).toBe(321)\r\n      expect(box.cy).toBe(567)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width and height of the element', function() {\r\n      circle.width(82)\r\n      expect(circle.node.getAttribute('r')).toBe('41')\r\n    })\r\n    it('gets the width and height of the element if the argument is null', function() {\r\n      expect((circle.width() / 2).toString()).toBe(circle.node.getAttribute('r'))\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height and width of the element', function() {\r\n      circle.height(1236)\r\n      expect(circle.node.getAttribute('r')).toBe('618')\r\n    })\r\n    it('gets the height and width of the element if the argument is null', function() {\r\n      expect((circle.height() / 2).toString()).toBe(circle.node.getAttribute('r'))\r\n    })\r\n  })\r\n  \r\n  describe('size()', function() {\r\n    it('defines the r of the element', function() {\r\n      circle.size(987)\r\n      expect(circle.node.getAttribute('r')).toBe((987 / 2).toString())\r\n    })\r\n  })\r\n  \r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box = circle.scale(2).rbox()\r\n      \r\n      expect(box.width).toBe(circle.attr('r') * 2 * 2)\r\n      expect(box.height).toBe(circle.attr('r') * 2 * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box = circle.scale(2, 3.5).rbox()\r\n      \r\n      expect(box.width).toBe(circle.attr('r') * 2 * 2)\r\n      expect(box.height).toBe(circle.attr('r') * 2 * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      circle.transform({ x: 12, y: 12 })\r\n      expect(window.matrixStringToArray(circle.node.getAttribute('transform'))).toEqual([1,0,0,1,12,12])\r\n    })\r\n  })\r\n  \r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/clip.js":"describe('ClipPath', function() {\r\n  var rect, circle\r\n\r\n  beforeEach(function() {\r\n    rect   = draw.rect(100,100)\r\n    circle = draw.circle(100).move(50, 50)\r\n    rect.clipWith(circle)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('moves the clipping element to a new clip node', function() {\r\n    expect(circle.parent() instanceof SVG.ClipPath).toBe(true)\r\n  })\r\n  \r\n  it('creates the clip node in the defs node', function() {\r\n    expect(circle.parent().parent()).toBe(draw.defs())\r\n  })\r\n\r\n  it('sets the \"clip-path\" attribute on the cliped element with the clip id', function() {\r\n    expect(rect.attr('clip-path')).toBe('url(\"#' + circle.parent().attr('id') + '\")')\r\n  })\r\n\r\n  it('references the clip element in the masked element', function() {\r\n    expect(rect.clipper).toBe(circle.parent())\r\n  })\r\n\r\n  it('references the clipped element in the clipPath target list', function() {\r\n    expect(rect.clipper.targets.indexOf(rect) > -1).toBe(true)\r\n  })\r\n  \r\n  it('reuses clip element when clip was given', function() {\r\n    var clip = rect.clipper\r\n    expect(draw.rect(100,100).clipWith(clip).clipper).toBe(clip)\r\n  })\r\n\r\n  it('unclips all clipped elements when being removed', function() {\r\n    rect.clipper.remove()\r\n    expect(rect.attr('clip-path')).toBe(undefined)\r\n  })\r\n\r\n  describe('unclip()', function() {\r\n\r\n    it('clears the \"clip-path\" attribute on the clipped element', function() {\r\n      rect.unclip()\r\n      expect(rect.attr('clip-path')).toBe(undefined)\r\n    })\r\n\r\n    it('removes the reference to the clipping element', function() {\r\n      rect.unclip()\r\n      expect(rect.clipper).toBe(undefined)\r\n    })\r\n\r\n    it('returns the clipPath element', function() {\r\n      expect(rect.unclip()).toBe(rect)\r\n    })\r\n\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/color.js":"describe('Color', function() {\r\n\tvar color\r\n\r\n\tbeforeEach(function() {\r\n\t\tcolor = new SVG.Color({ r: 0, g: 102, b: 255 })\r\n\t})\r\n\r\n\tit('correclty parses a rgb string', function() {\r\n\t\tcolor = new SVG.Color('rgb(255,0,128)')\r\n\t\texpect(color.r).toBe(255)\r\n\t\texpect(color.g).toBe(0)\r\n\t\texpect(color.b).toBe(128)\r\n\t})\r\n\t\r\n\tit('correclty parses a 3 digit hex string', function() {\r\n\t\tcolor = new SVG.Color('#f06')\r\n\t\texpect(color.r).toBe(255)\r\n\t\texpect(color.g).toBe(0)\r\n\t\texpect(color.b).toBe(102)\r\n\t})\r\n\r\n\tit('correclty parses a 6 digit hex string', function() {\r\n\t\tcolor = new SVG.Color('#0066ff')\r\n\t\texpect(color.r).toBe(0)\r\n\t\texpect(color.g).toBe(102)\r\n\t\texpect(color.b).toBe(255)\r\n\t})\r\n\r\n\tdescribe('toHex()', function() {\r\n\t\tit('returns a hex color', function() {\r\n\t\t\texpect(color.toHex()).toBe('#0066ff')\r\n\t\t})\r\n\t})\r\n\r\n\tdescribe('toRgb()', function() {\r\n\t\tit('returns a rgb string color', function() {\r\n\t\t\texpect(color.toRgb()).toBe('rgb(0,102,255)')\r\n\t\t})\r\n\t})\r\n\r\n\tdescribe('brightness()', function() {\r\n\t\tit('returns the percieved brightness value of a color', function() {\r\n\t\t\texpect(color.brightness()).toBe(0.346)\r\n\t\t})\r\n\t})\r\n\r\n\tdescribe('morph()', function() {\r\n\t\tit('prepares the color for morphing', function() {\r\n\t\t\tvar destination = new SVG.Color\r\n\t\t\tcolor.morph(destination)\r\n\t\t\texpect(color.destination).toEqual(destination)\r\n\t\t})\r\n\t})\r\n\r\n\tdescribe('at()', function() {\r\n\t\tit('morphes color to a given position', function() {\r\n\t\t\tvar destination = new SVG.Color\r\n\t\t\tvar morphed = color.morph(destination).at(0.5)\r\n\t\t\texpect(morphed.r).toBe(0)\r\n\t\t\texpect(morphed.g).toBe(51)\r\n\t\t\texpect(morphed.b).toBe(127)\r\n\t\t})\r\n\r\n\t\tit('morphes color to 1 with higher values', function() {\r\n\t\t\tvar destination = new SVG.Color('#fff')\r\n\t\t\tvar morphed = color.morph(destination).at(2)\r\n\t\t\texpect(morphed.r).toBe(255)\r\n\t\t\texpect(morphed.g).toBe(255)\r\n\t\t\texpect(morphed.b).toBe(255)\r\n\t\t})\r\n\r\n\t\tit('morphes color to 0 with lower values', function() {\r\n\t\t\tvar destination = new SVG.Color('#fff')\r\n\t\t\tvar morphed = color.morph(destination).at(-3)\r\n\t\t\texpect(morphed.r).toBe(0)\r\n\t\t\texpect(morphed.g).toBe(102)\r\n\t\t\texpect(morphed.b).toBe(255)\r\n\t\t})\r\n    \r\n    it('returns itself when no destination specified', function() {\r\n      expect(color.at(0.5)).toBe(color)\r\n    })\r\n\t})\r\n\r\n})\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/container.js":"describe('Container', function() {\r\n\r\n  beforeEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('rect()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.rect(100,100)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a rect', function() {\r\n      expect(draw.rect(100,100).type).toBe('rect')\r\n    })\r\n    it('should create an instance of SVG.Rect', function() {\r\n      expect(draw.rect(100,100) instanceof SVG.Rect).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.rect(100,100) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.rect(100,100) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('ellipse()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.ellipse(100,100)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create an ellipse', function() {\r\n      expect(draw.ellipse(100,100).type).toBe('ellipse')\r\n    })\r\n    it('should create an instance of SVG.Ellipse', function() {\r\n      expect(draw.ellipse(100,100) instanceof SVG.Ellipse).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.ellipse(100,100) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.ellipse(100,100) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('circle()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.circle(100)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create an circle', function() {\r\n      expect(draw.circle(100).type).toBe('circle')\r\n    })\r\n    it('should create an instance of SVG.Circle', function() {\r\n      expect(draw.circle(100) instanceof SVG.Circle).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.circle(100) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.circle(100) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('line()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.line(0,100,100,0)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a line', function() {\r\n      expect(draw.line(0,100,100,0).type).toBe('line')\r\n    })\r\n    it('should create an instance of SVG.Line', function() {\r\n      expect(draw.line(0,100,100,0) instanceof SVG.Line).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.line(0,100,100,0) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.line(0,100,100,0) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('polyline()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.polyline('0,0 100,0 100,100 0,100')\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a polyline', function() {\r\n      expect(draw.polyline('0,0 100,0 100,100 0,100').type).toBe('polyline')\r\n    })\r\n    it('should be an instance of SVG.Polyline', function() {\r\n      expect(draw.polyline('0,0 100,0 100,100 0,100') instanceof SVG.Polyline).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.polyline('0,0 100,0 100,100 0,100') instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.polyline('0,0 100,0 100,100 0,100') instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('polygon()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.polygon('0,0 100,0 100,100 0,100')\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a polygon', function() {\r\n      expect(draw.polygon('0,0 100,0 100,100 0,100').type).toBe('polygon')\r\n    })\r\n    it('should be an instance of SVG.Polygon', function() {\r\n      expect(draw.polygon('0,0 100,0 100,100 0,100') instanceof SVG.Polygon).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.polygon('0,0 100,0 100,100 0,100') instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.polygon('0,0 100,0 100,100 0,100') instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('path()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.path(svgPath)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a path', function() {\r\n      expect(draw.path(svgPath).type).toBe('path')\r\n    })\r\n    it('should be an instance of SVG.Path', function() {\r\n      expect(draw.path(svgPath) instanceof SVG.Path).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.path(svgPath) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.path(svgPath) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('image()', function() {\r\n    it('should increase children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.image(imageUrl, 100, 100)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('should create a rect', function() {\r\n      expect(draw.image(imageUrl, 100, 100).type).toBe('image')\r\n    })\r\n    it('should create an instance of SVG.Rect', function() {\r\n      expect(draw.image(imageUrl, 100, 100) instanceof SVG.Image).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Shape', function() {\r\n      expect(draw.image(imageUrl, 100, 100) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('should be an instance of SVG.Element', function() {\r\n      expect(draw.image(imageUrl, 100, 100) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('text()', function() {\r\n    it('increases children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.text(loremIpsum)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('creates a text element', function() {\r\n      expect(draw.text(loremIpsum).type).toBe('text')\r\n    })\r\n    it('creates an instance of SVG.Rect', function() {\r\n      expect(draw.text(loremIpsum) instanceof SVG.Text).toBe(true)\r\n    })\r\n    it('is an instance of SVG.Shape', function() {\r\n      expect(draw.text(loremIpsum) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('is an instance of SVG.Element', function() {\r\n      expect(draw.text(loremIpsum) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('plain()', function() {\r\n    it('increases children by 1', function() {\r\n      var initial = draw.children().length\r\n      draw.plain(loremIpsum)\r\n      expect(draw.children().length).toBe(initial + 1)\r\n    })\r\n    it('creates a plain element', function() {\r\n      expect(draw.plain(loremIpsum).type).toBe('text')\r\n    })\r\n    it('creates an instance of SVG.Rect', function() {\r\n      expect(draw.plain(loremIpsum) instanceof SVG.Text).toBe(true)\r\n    })\r\n    it('is an instance of SVG.Shape', function() {\r\n      expect(draw.plain(loremIpsum) instanceof SVG.Shape).toBe(true)\r\n    })\r\n    it('is an instance of SVG.Element', function() {\r\n      expect(draw.plain(loremIpsum) instanceof SVG.Element).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('removes all children except the parser if present', function() {\r\n      draw.rect(100,100)\r\n      draw.clear()\r\n      expect(draw.children().length).toBe(parserInDoc)\r\n    })\r\n    it('creates a new defs node', function() {\r\n      var oldDefs = draw.defs()\r\n      draw.rect(100,100).maskWith(draw.circle(100, 100))\r\n      draw.clear()\r\n      expect(draw.defs()).not.toBe(oldDefs)\r\n    })\r\n    it('clears all children in the defs node', function() {\r\n      draw.rect(100,100).maskWith(draw.circle(100, 100))\r\n      draw.clear()\r\n      expect(draw.defs().children().length).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('each()', function() {\r\n    it('should iterate over all children', function() {\r\n      var children = []\r\n\r\n      draw.rect(100,100)\r\n      draw.ellipse(100, 100)\r\n      draw.polygon()\r\n\r\n      draw.each(function() {\r\n        children.push(this.type)\r\n      })\r\n      expect(children).toEqual((parserInDoc ? [parser[0].type] : []).concat(['rect', 'ellipse', 'polygon']))\r\n    })\r\n    it('should only include the its own children', function() {\r\n      var children = []\r\n        , group = draw.group()\r\n\r\n      draw.rect(100,200)\r\n      draw.circle(300)\r\n\r\n      group.rect(100,100)\r\n      group.ellipse(100, 100)\r\n      group.polygon()\r\n\r\n      group.each(function() {\r\n        children.push(this)\r\n      })\r\n\r\n      expect(children).toEqual(group.children())\r\n    })\r\n    it('should traverse recursively when set to deep', function() {\r\n      var children = []\r\n        , group = draw.group()\r\n\r\n      draw.rect(100,200)\r\n      draw.circle(300)\r\n\r\n      group.rect(100,100)\r\n      group.ellipse(100, 100)\r\n      group.polygon()\r\n\r\n      draw.each(function() {\r\n        children.push(this)\r\n      }, true)\r\n\r\n      expect(children.length).toEqual(draw.children().length + group.children().length + (parserInDoc ? parser[0].children().length : 0))\r\n    })\r\n  })\r\n\r\n  describe('get()', function() {\r\n    it('gets an element at a given index', function() {\r\n      draw.clear()\r\n      var rect = draw.rect(100,100)\r\n      var circle = draw.circle(100)\r\n      var line = draw.line(0,0,100,100)\r\n      expect(draw.get(0+parserInDoc)).toBe(rect)\r\n      expect(draw.get(1+parserInDoc)).toBe(circle)\r\n      expect(draw.get(2+parserInDoc)).toBe(line)\r\n      expect(draw.get(3+parserInDoc)).toBeNull()\r\n    })\r\n  })\r\n\r\n  describe('first()', function() {\r\n    it('gets the first child', function() {\r\n      draw.clear()\r\n      var rect = draw.rect(100,100)\r\n      var circle = draw.circle(100)\r\n      var line = draw.line(0,0,100,100)\r\n      expect(draw.first()).toBe(parserInDoc ? parser[0] : rect)\r\n    })\r\n  })\r\n\r\n  describe('last()', function() {\r\n    it('gets the last child', function() {\r\n      draw.clear()\r\n      var rect = draw.rect(100,100)\r\n      var circle = draw.circle(100)\r\n      var line = draw.line(0,0,100,100)\r\n      expect(draw.last()).toBe(line)\r\n    })\r\n  })\r\n\r\n  describe('has()', function() {\r\n    it('determines if a given element is a child of the parent', function() {\r\n      var rect = draw.rect(100,100)\r\n      var circle = draw.circle(100)\r\n      var group = draw.group()\r\n      var line = group.line(0,0,100,100)\r\n      expect(draw.has(rect)).toBe(true)\r\n      expect(draw.has(circle)).toBe(true)\r\n      expect(draw.has(group)).toBe(true)\r\n      expect(draw.has(line)).toBe(false)\r\n      expect(group.has(line)).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('index()', function() {\r\n    it('determines the index of given element', function() {\r\n      var rect = draw.rect(100,100)\r\n      var circle = draw.circle(100)\r\n      var group = draw.group()\r\n      var line = group.line(0,0,100,100)\r\n      expect(draw.index(rect)).toBe(0+parserInDoc)\r\n      expect(draw.index(circle)).toBe(1+parserInDoc)\r\n      expect(draw.index(group)).toBe(2+parserInDoc)\r\n      expect(draw.index(line)).toBe(-1)\r\n      expect(group.index(line)).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('parent()', function() {\r\n    it('returns the parent element instance', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.parent()).toBe(rect.node.parentNode.instance)\r\n    })\r\n  })\r\n\r\n  describe('defs()', function() {\r\n    it('returns the defs from the svg', function() {\r\n      var g = draw.group()\r\n      expect(g.defs()).toBe(draw.doc().defs())\r\n      expect(g.defs() instanceof SVG.Defs).toBeTruthy()\r\n    })\r\n  })\r\n\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/defs.js":"describe('Defs', function() {\r\n  var defs\r\n\r\n  beforeEach(function() {\r\n    defs = draw.defs()\r\n  })\r\n\r\n  it('creates an instance of SVG.Defs', function() {\r\n    expect(defs instanceof SVG.Defs).toBeTruthy()\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/easing.js":"describe('SVG.easing', function() {\r\n  var easedValues = {\r\n    '-':0.5,\r\n    '<>':0.5,\r\n    '>':0.7071,\r\n    '<':0.2929,\r\n  }\r\n\r\n  ;['-', '<>', '<', '>'].forEach(function(el) {\r\n    describe(el, function() {\r\n      it('is 0 at 0', function() {\r\n        expect(SVG.easing[el](0)).toBe(0)\r\n      })\r\n      it('is 1 at 1', function() {\r\n        expect(Math.round(SVG.easing[el](1)*1000)/1000).toBe(1) // we need to round cause for some reason at some point 1==0.999999999\r\n      })\r\n      it('is eased at 0.5', function() {\r\n        expect(SVG.easing[el](0.5)).toBeCloseTo(easedValues[el])\r\n      })\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/element.js":"describe('Element', function() {\r\n\r\n  beforeEach(function() {\r\n    draw.clear()\r\n    draw.attr('viewBox', null)\r\n  })\r\n\r\n  it('should create a circular reference on the node', function() {\r\n    var rect = draw.rect(100,100)\r\n    expect(rect.node.instance).toBe(rect)\r\n  })\r\n\r\n  describe('native()', function() {\r\n    it('returns the node reference', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.native()).toBe(rect.node)\r\n    })\r\n  })\r\n\r\n  describe('attr()', function() {\r\n    var rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      draw.defs().select('pattern').each(function() { this.remove() })\r\n    })\r\n\r\n    it('sets one attribute when two arguments are given', function() {\r\n      rect.attr('fill', '#ff0066')\r\n      expect(rect.node.getAttribute('fill')).toBe('#ff0066')\r\n    })\r\n    it('sets various attributes when an object is given', function() {\r\n      rect.attr({ fill: '#00ff66', stroke: '#ff2233', 'stroke-width': 10 })\r\n      expect(rect.node.getAttribute('fill')).toBe('#00ff66')\r\n      expect(rect.node.getAttribute('stroke')).toBe('#ff2233')\r\n      expect(rect.node.getAttribute('stroke-width')).toBe('10')\r\n    })\r\n    it('gets the value of the string value given as first argument', function() {\r\n      rect.attr('fill', '#ff0066')\r\n      expect(rect.attr('fill')).toEqual('#ff0066')\r\n    })\r\n    it('gets an object with all attributes without any arguments', function() {\r\n      rect.attr({ fill: '#00ff66', stroke: '#ff2233' })\r\n      var attr = rect.attr()\r\n      expect(attr.fill).toBe('#00ff66')\r\n      expect(attr.stroke).toBe('#ff2233')\r\n    })\r\n    it('removes an attribute if the second argument is explicitly set to null', function() {\r\n      rect.attr('stroke-width', 10)\r\n      expect(rect.node.getAttribute('stroke-width')).toBe('10')\r\n      rect.attr('stroke-width', null)\r\n      expect(rect.node.getAttribute('stroke-width')).toBe(null)\r\n    })\r\n    it('correctly parses numeric values as a getter', function() {\r\n      rect.attr('stroke-width', 11)\r\n      expect(rect.node.getAttribute('stroke-width')).toBe('11')\r\n      expect(rect.attr('stroke-width')).toBe(11)\r\n    })\r\n    it('correctly parses negative numeric values as a getter', function() {\r\n      rect.attr('x', -120)\r\n      expect(rect.node.getAttribute('x')).toBe('-120')\r\n      expect(rect.attr('x')).toBe(-120)\r\n    })\r\n    it('falls back on default values if attribute is not present', function() {\r\n      expect(rect.attr('stroke-linejoin')).toBe('miter')\r\n    })\r\n    it('gets the \"style\" attribute as a string', function() {\r\n      rect.style('cursor', 'pointer')\r\n      expect(rect.node.style.cursor).toBe('pointer')\r\n    })\r\n    it('sets the style attribute correctly', function() {\r\n      rect.attr('style', 'cursor:move;')\r\n      expect(rect.node.style.cursor).toBe('move')\r\n    })\r\n    it('acts as a global getter when no arguments are given', function() {\r\n      rect.fill('#ff0066')\r\n      expect(rect.attr().fill).toBe('#ff0066')\r\n    })\r\n    it('correctly parses numeric values as a global getter', function() {\r\n      rect.stroke({ width: 20 })\r\n      expect(rect.attr()['stroke-width']).toBe(20)\r\n    })\r\n    it('correctly parses negative numeric values as a global getter', function() {\r\n      rect.x(-30)\r\n      expect(rect.attr().x).toBe(-30)\r\n    })\r\n    it('leaves unit values alone as a global getter', function() {\r\n      rect.attr('x', '69%')\r\n      expect(rect.attr().x).toBe('69%')\r\n    })\r\n    it('creates an image in defs when image path is specified for fill', function() {\r\n      rect.attr('fill', imageUrl)\r\n      expect(draw.defs().select('pattern').length()).toBe(1)\r\n      expect(draw.defs().select('pattern image').length()).toBe(1)\r\n      expect(draw.defs().select('pattern image').first().src).toBe(imageUrl)\r\n    })\r\n    it('creates pattern in defs when image object is specified for fill', function() {\r\n      rect.attr('fill', new SVG.Image().load(imageUrl))\r\n      expect(draw.defs().select('pattern').length()).toBe(1)\r\n      expect(draw.defs().select('pattern image').length()).toBe(1)\r\n      expect(draw.defs().select('pattern image').first().src).toBe(imageUrl)\r\n    })\r\n    it('correctly creates SVG.Array if array given', function() {\r\n      rect.attr('something', [2,3,4])\r\n      expect(rect.attr('something')).toBe('2 3 4')\r\n    })\r\n    it('redirects to the leading() method when setting leading', function() {\r\n      var text = draw.text(loremIpsum)\r\n      spyOn(text, 'leading')\r\n\r\n      text.attr('leading', 2)\r\n      expect(text.leading).toHaveBeenCalled()\r\n      text.remove()\r\n    })\r\n  })\r\n\r\n  describe('id()', function() {\r\n    var rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n    })\r\n\r\n    it('gets the value if the id attribute without an argument', function() {\r\n      expect(rect.id()).toBe(rect.attr('id'))\r\n    })\r\n    it('sets the value of the id', function() {\r\n      rect.id('new_id')\r\n      expect(rect.attr('id')).toBe('new_id')\r\n    })\r\n  })\r\n\r\n  describe('style()', function() {\r\n    it('sets the style with key and value arguments', function() {\r\n      var rect = draw.rect(100,100).style('cursor', 'crosshair')\r\n      expect(window.stripped(rect.node.style.cssText)).toBe('cursor:crosshair')\r\n    })\r\n    it('sets multiple styles with an object as the first argument', function() {\r\n      var rect = draw.rect(100,100).style({ cursor: 'help', display: 'block' })\r\n      expect(window.stripped(rect.node.style.cssText)).toMatch(/cursor:help/)\r\n      expect(window.stripped(rect.node.style.cssText)).toMatch(/display:block/)\r\n      expect(window.stripped(rect.node.style.cssText).length).toBe(('display:block;cursor:help').length)\r\n    })\r\n    it('sets multiple styles with a css string as the first argument', function() {\r\n      var rect = draw.rect(100,100).style('cursor: help; display: block;')\r\n      expect(window.stripped(rect.node.style.cssText)).toMatch(/cursor:help/)\r\n      expect(window.stripped(rect.node.style.cssText)).toMatch(/display:block/)\r\n      expect(window.stripped(rect.node.style.cssText).length).toBe(('display:block;cursor:help').length)\r\n    })\r\n    it('gets a style with a string key as the fists argument', function() {\r\n      var rect = draw.rect(100,100).style({ cursor: 'progress', display: 'block' })\r\n      expect(rect.style('cursor')).toBe('progress')\r\n    })\r\n    it('gets the full css string with no argument', function() {\r\n      var rect = draw.rect(100,100).style({ cursor: 's-resize', display: 'none' })\r\n      expect(window.stripped(rect.style())).toMatch(/display:none/)\r\n      expect(window.stripped(rect.style())).toMatch(/cursor:s-resize/)\r\n      expect(window.stripped(rect.style()).length).toBe(('cursor:s-resize;display:none').length)\r\n    })\r\n    it('removes a style if the value is an empty string', function() {\r\n      var rect = draw.rect(100,100).style({ cursor: 'n-resize', display: '' })\r\n      expect(window.stripped(rect.style())).toBe('cursor:n-resize')\r\n    })\r\n    it('removes a style if the value explicitly set to null', function() {\r\n      var rect = draw.rect(100,100).style('cursor', 'w-resize')\r\n      expect(window.stripped(rect.style())).toBe('cursor:w-resize')\r\n      rect.style('cursor', null)\r\n      expect(rect.style()).toBe('')\r\n    })\r\n  })\r\n\r\n  describe('transform()', function() {\r\n    var rect, ctm\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n    })\r\n\r\n    it('gets the current transformations', function() {\r\n      expect(rect.transform()).toEqual(new SVG.Matrix(rect).extract())\r\n    })\r\n    it('sets the translation of and element', function() {\r\n      rect.transform({ x: 10, y: 11 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,1,10,11])\r\n    })\r\n    it('performs an absolute translation', function() {\r\n      rect.transform({ x: 10, y: 11 }).transform({ x: 20, y: 21 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,1,20,21])\r\n    })\r\n    it('performs a relative translation when relative is set to true', function() {\r\n      rect.transform({ x: 10, y: 11 }).transform({ x: 20, y: 21, relative: true })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,1,30,32])\r\n    })\r\n    it('performs a relative translation with relative flag', function() {\r\n      rect.transform({ x: 10, y: 11 }).transform({ x: 20, y: 21 }, true)\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,1,30,32])\r\n    })\r\n    it('sets the scaleX and scaleY of an element', function() {\r\n      rect.transform({ scaleX: 0.5, scaleY: 2 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([0.5,0,0,2,25,-50])\r\n    })\r\n    it('performs a uniform scale with scale given', function() {\r\n      rect.transform({ scale: 3 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([3,0,0,3,-100,-100])\r\n    })\r\n    it('also works with only skaleX', function() {\r\n      rect.transform({ scaleX: 3 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([3,0,0,1,-100,0])\r\n    })\r\n    it('also works with only skaleY', function() {\r\n      rect.transform({ scaleY: 3 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,3,0,-100])\r\n    })\r\n\r\n    it('performs an absolute scale by default', function() {\r\n      rect.transform({ scale: 3 }).transform({ scale: 0.5 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([0.5,0,0,0.5,25,25])\r\n    })\r\n    it('performs a relative scale with a relative flag', function() {\r\n      rect.transform({ scaleX: 0.5, scaleY: 2 }).transform({ scaleX: 3, scaleY: 4 }, true)\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1.5,0,0,8,-25,-350])\r\n    })\r\n    it('sets the skewX of an element with center on the element', function() {\r\n      ctm = rect.transform({ skewX: 10 }).ctm()\r\n      expect(ctm.a).toBe(1)\r\n      expect(ctm.b).toBe(0)\r\n      expect(ctm.c).toBeCloseTo(0.17632698070846498)\r\n      expect(ctm.d).toBe(1)\r\n      expect(ctm.e).toBeCloseTo(-8.81634903542325)\r\n      expect(ctm.f).toBe(0)\r\n    })\r\n    it('sets the skewX of an element with given center', function() {\r\n      ctm = rect.transform({ skewX: 10, cx: 0, cy: 0 }).ctm()\r\n      expect(ctm.a).toBe(1)\r\n      expect(ctm.b).toBe(0)\r\n      expect(ctm.c).toBeCloseTo(0.17632698070846498)\r\n      expect(ctm.d).toBe(1)\r\n      expect(ctm.e).toBe(0)\r\n      expect(ctm.f).toBe(0)\r\n    })\r\n    it('sets the skewY of an element', function() {\r\n      ctm = rect.transform({ skewY: -10, cx: 0, cy: 0 }).ctm()\r\n      expect(ctm.a).toBe(1)\r\n      expect(ctm.b).toBeCloseTo(-0.17632698070846498)\r\n      expect(ctm.c).toBe(0)\r\n      expect(ctm.d).toBe(1)\r\n      expect(ctm.e).toBe(0)\r\n      expect(ctm.f).toBe(0)\r\n    })\r\n    it('sets the skewX and skewY of an element', function() {\r\n      ctm = rect.transform({ skewX: 10, skewY: -10, cx: 0, cy: 0 }).ctm()\r\n      expect(ctm.a).toBe(1)\r\n      expect(ctm.b).toBeCloseTo(-0.17632698070846498)\r\n      expect(ctm.c).toBeCloseTo(0.17632698070846498)\r\n      expect(ctm.d).toBe(1)\r\n      expect(ctm.e).toBe(0)\r\n      expect(ctm.f).toBe(0)\r\n    })\r\n    it('performs a uniform skew with skew given', function() {\r\n      ctm = rect.transform({ skew: 5, cx: 0, cy: 0 }).ctm()\r\n      expect(ctm.a).toBe(1)\r\n      expect(ctm.b).toBeCloseTo(0.08748866352592401)\r\n      expect(ctm.c).toBeCloseTo(0.08748866352592401)\r\n      expect(ctm.d).toBe(1)\r\n      expect(ctm.e).toBe(0)\r\n      expect(ctm.f).toBe(0)\r\n    })\r\n    it('rotates the element around its centre if no rotation point is given', function() {\r\n      ctm = rect.center(100, 100).transform({ rotation: 45 }).ctm()\r\n      expect(ctm.a).toBeCloseTo(0.7071068286895752)\r\n      expect(ctm.b).toBeCloseTo(0.7071068286895752)\r\n      expect(ctm.c).toBeCloseTo(-0.7071068286895752)\r\n      expect(ctm.d).toBeCloseTo(0.7071068286895752)\r\n      expect(ctm.e).toBeCloseTo(100)\r\n      expect(ctm.f).toBeCloseTo(-41.421356201171875)\r\n      expect(rect.transform('rotation')).toBe(45)\r\n    })\r\n    it('rotates the element around the given rotation point', function() {\r\n      ctm = rect.transform({ rotation: 55, cx: 80, cy:2 }).ctm()\r\n      expect(ctm.a).toBeCloseTo(0.5735765099525452)\r\n      expect(ctm.b).toBeCloseTo(0.8191521167755127)\r\n      expect(ctm.c).toBeCloseTo(-0.8191521167755127)\r\n      expect(ctm.d).toBeCloseTo(0.5735765099525452)\r\n      expect(ctm.e).toBeCloseTo(35.75218963623047)\r\n      expect(ctm.f).toBeCloseTo(-64.67931365966797)\r\n    })\r\n    it('transforms element using a matrix', function() {\r\n      rect.transform({ a: 0.5, c: 0.5 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([0.5,0,0.5,1,0,0])\r\n    })\r\n    it('transforms relative using a matrix', function() {\r\n      rect.transform({ a: 0.5, c: 0.5 }).transform(new SVG.Matrix({ e: 20, f: 20 }), true)\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([0.5,0,0.5,1,20,20])\r\n    })\r\n    it('flips the element on x axis', function() {\r\n      rect.transform({ flip: 'x' })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([-1,0,0,1,100,0])\r\n    })\r\n    it('flips the element on x axis with offset', function() {\r\n      rect.transform({ flip: 'x', offset: 20 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([-1,0,0,1,40,0])\r\n    })\r\n    it('flips the element on y axis with offset', function() {\r\n      rect.transform({ flip: 'y', offset: 20 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([1,0,0,-1,0,40])\r\n    })\r\n    it('flips the element on both axis with offset', function() {\r\n      rect.transform({ flip: 'both', offset: 20 })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([-1,0,0,-1,40,40])\r\n    })\r\n    it('flips the element on both axis', function() {\r\n      rect.transform({ flip: 'both' })\r\n      expect(window.matrixStringToArray(rect.node.getAttribute('transform'))).toEqual([-1,0,0,-1,100,100])\r\n    })\r\n  })\r\n\r\n  describe('untransform()', function() {\r\n    var circle\r\n\r\n    beforeEach(function() {\r\n      circle = draw.circle(100).translate(50, 100)\r\n    })\r\n\r\n    it('removes the transform attribute', function() {\r\n      expect(window.matrixStringToArray(circle.node.getAttribute('transform'))).toEqual([1,0,0,1,50,100])\r\n      circle.untransform()\r\n      expect(circle.node.getAttribute('transform')).toBeNull()\r\n    })\r\n    it('resets the current transform matix', function() {\r\n      expect(circle.ctm()).toEqual(new SVG.Matrix(1,0,0,1,50,100))\r\n      circle.untransform()\r\n      expect(circle.ctm()).toEqual(new SVG.Matrix)\r\n    })\r\n  })\r\n\r\n  describe('matrixify', function() {\r\n    var rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100, 100)\r\n    })\r\n\r\n    it('allow individual transform definitions to be separated by whitespace', function(){\r\n      // One space\r\n      rect.attr('transform', 'translate(20) translate(20)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,40,0)')\r\n\r\n      // More than one space\r\n      rect.attr('transform', 'translate(20)   translate(-60)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,-40,0)')\r\n    })\r\n\r\n    it('allow individual transform definitions to be separated by a comma', function(){\r\n      rect.attr('transform', 'translate(20,16),translate(20)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,40,16)')\r\n    })\r\n\r\n    it('allow individual transform definitions to be separated by whitespace and a comma', function(){\r\n      // Spaces before the comma\r\n      rect.attr('transform', 'translate(20,16)  ,translate(20)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,40,16)')\r\n\r\n      // Spaces after the comma\r\n      rect.attr('transform', 'translate(12),  translate(10,14)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,22,14)')\r\n\r\n      // Spaces before and after the comma\r\n      rect.attr('transform', 'translate(24,14)  , translate(36,6)')\r\n      expect(rect.matrixify().toString()).toBe('matrix(1,0,0,1,60,20)')\r\n    })\r\n  })\r\n\r\n  describe('toParent()', function() {\r\n    var nested, g1, g2, rect1\r\n\r\n    beforeEach(function() {\r\n      nested = draw.nested()\r\n      g1 = nested.group().translate(20, 20)\r\n      g2 = g1.group().translate(100, 100)\r\n      rect1 = g2.rect(100,100).scale(2)\r\n      rect2 = nested.rect(100,100).scale(0.5)\r\n    })\r\n\r\n    afterEach(function() {\r\n      draw.clear()\r\n    })\r\n\r\n    it('returns itself when given parent and it is the same', function() {\r\n      expect(g2.toParent(g2)).toBe(g2)\r\n    })\r\n\r\n    it('moves the element to other parent while maintaining the same visal representation', function() {\r\n      expect(rect1.toParent(nested).transform()).toEqual(jasmine.objectContaining({\r\n        a:2, b:0, c:0, d:2, e:70, f:70\r\n      }))\r\n      expect(rect1.parent()).toEqual(nested)\r\n      expect(rect2.toParent(g2).transform()).toEqual(jasmine.objectContaining({\r\n        a:0.5, b:0, c:0, d:0.5, e:-95, f:-95\r\n      }))\r\n      expect(rect2.parent()).toEqual(g2)\r\n    })\r\n  })\r\n\r\n  describe('toDoc()', function() {\r\n    var nested, g1, g2, rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'toParent')\r\n    })\r\n\r\n    afterEach(function() {\r\n      draw.clear()\r\n    })\r\n\r\n    it('redirects to toParent(doc)', function() {\r\n      rect.toDoc()\r\n      expect(rect.toParent).toHaveBeenCalledWith(rect.doc())\r\n    })\r\n  })\r\n\r\n  describe('ungroup()', function() {\r\n    var nested, g1, g2, rect1\r\n\r\n    beforeEach(function() {\r\n      draw.defs()\r\n      nested = draw.nested()\r\n      g1 = nested.group().translate(20, 20)\r\n      g2 = g1.group().translate(100, 100)\r\n      rect1 = g2.rect(100,100).scale(2)\r\n      rect2 = g1.rect(100,100).scale(0.5)\r\n    })\r\n\r\n    afterEach(function() {\r\n      draw.clear()\r\n    })\r\n\r\n    it('returns itself when depths is 0 or this is SVG.Defs', function() {\r\n      expect(draw.defs().ungroup()).toBe(draw.defs())\r\n      expect(g1.ungroup(null, 0)).toBe(g1)\r\n    })\r\n\r\n    it('breaks up all container and move the elements to the parent', function() {\r\n      g1.ungroup()\r\n      expect(rect1.parent()).toBe(nested)\r\n      expect(rect2.parent()).toBe(nested)\r\n\r\n      expect(g1.node.parentNode).toBeFalsy()\r\n      expect(g2.node.parentNode).toBeFalsy()\r\n\r\n      expect(rect1.transform()).toEqual(jasmine.objectContaining({\r\n        a:2, b:0, c:0, d:2, e:70, f:70\r\n      }))\r\n      expect(rect2.transform()).toEqual(jasmine.objectContaining({\r\n        a:0.5, b:0, c:0, d:0.5, e:45, f:45\r\n      }))\r\n    })\r\n\r\n    it('ungroups everything to the doc root when called on SVG.Doc / does not ungroup defs/parser', function() {\r\n      draw.ungroup()\r\n      expect(rect1.parent()).toBe(draw)\r\n      expect(rect2.parent()).toBe(draw)\r\n\r\n      expect(g1.node.parentNode).toBeFalsy()\r\n      expect(g1.node.parentNode).toBeFalsy()\r\n      expect(nested.node.parentNode).toBeFalsy()\r\n\r\n      expect(rect1.transform()).toEqual(jasmine.objectContaining({\r\n        a:2, b:0, c:0, d:2, e:70, f:70\r\n      }))\r\n      expect(rect2.transform()).toEqual(jasmine.objectContaining({\r\n        a:0.5, b:0, c:0, d:0.5, e:45, f:45\r\n      }))\r\n\r\n      expect(draw.children().length).toBe(3+parserInDoc) // 2 * rect + defs\r\n    })\r\n  })\r\n\r\n  describe('flatten()', function() {\r\n    it('redirects the call to ungroup()', function() {\r\n      spyOn(draw, 'ungroup')\r\n      draw.flatten()\r\n      expect(draw.ungroup).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('ctm()', function() {\r\n    var rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100, 100)\r\n    })\r\n\r\n    it('gets the current transform matrix of the element', function() {\r\n      rect.translate(10, 20)\r\n      expect(rect.ctm().toString()).toBe('matrix(1,0,0,1,10,20)')\r\n    })\r\n    it('returns an instance of SVG.Matrix', function() {\r\n      expect(rect.ctm() instanceof SVG.Matrix).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('data()', function() {\r\n    it('sets a data attribute and convert value to json', function() {\r\n      var rect = draw.rect(100,100).data('test', 'value')\r\n      expect(rect.node.getAttribute('data-test')).toBe('value')\r\n    })\r\n    it('sets a data attribute and not convert value to json if flagged raw', function() {\r\n      var rect = draw.rect(100,100).data('test', 'value', true)\r\n      expect(rect.node.getAttribute('data-test')).toBe('value')\r\n    })\r\n    it('sets multiple data attributes and convert values to json when an object is passed', function() {\r\n      var rect = draw.rect(100,100).data({\r\n        forbidden: 'fruit'\r\n      , multiple: {\r\n          values: 'in'\r\n        , an: 'object'\r\n        }\r\n      })\r\n      expect(rect.node.getAttribute('data-forbidden')).toBe('fruit')\r\n      expect(rect.node.getAttribute('data-multiple')).toEqual('{\"values\":\"in\",\"an\":\"object\"}')\r\n    })\r\n    it('gets data value if only one argument is passed', function() {\r\n      var rect = draw.rect(100,100).data('test', 101)\r\n      expect(rect.data('test')).toBe(101)\r\n    })\r\n    it('gets the raw value when value is no valid json', function() {\r\n      var rect = draw.rect(100,100).data('test', '{[\"sd\":12}]', true)\r\n      expect(rect.data('test')).toBe('{[\"sd\":12}]')\r\n    })\r\n    it('removes data when null given', function() {\r\n      var rect = draw.rect(100,100).data('test', '{\"sd\":12}', true)\r\n      expect(rect.data('test', null).attr('data-test')).toBeFalsy()\r\n    })\r\n    it('maintains data type for a number', function() {\r\n      var rect = draw.rect(100,100).data('test', 101)\r\n      expect(typeof rect.data('test')).toBe('number')\r\n    })\r\n    it('maintains data type for an object', function() {\r\n      var rect = draw.rect(100,100).data('test', { string: 'value', array: [1,2,3] })\r\n      expect(typeof rect.data('test')).toBe('object')\r\n      expect(Array.isArray(rect.data('test').array)).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('remove()', function() {\r\n    it('removes an element and return it', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.remove()).toBe(rect)\r\n    })\r\n    it('removes an element from its parent', function() {\r\n      var rect = draw.rect(100,100)\r\n      rect.remove()\r\n      expect(draw.has(rect)).toBe(false)\r\n    })\r\n  })\r\n\r\n  describe('addTo()', function() {\r\n    it('adds an element to a given parent and returns itself', function() {\r\n      var rect  = draw.rect(100,100)\r\n        , group = draw.group()\r\n\r\n      expect(rect.addTo(group)).toBe(rect)\r\n      expect(rect.parent()).toBe(group)\r\n    })\r\n  })\r\n\r\n  describe('putIn()', function() {\r\n    it('adds an element to a given parent and returns parent', function() {\r\n      var rect  = draw.rect(100,100)\r\n        , group = draw.group()\r\n\r\n      expect(rect.putIn(group)).toBe(group)\r\n      expect(rect.parent()).toBe(group)\r\n    })\r\n  })\r\n\r\n  describe('rbox()', function() {\r\n    it('returns an instance of SVG.RBox', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.rbox() instanceof SVG.RBox).toBe(true)\r\n    })\r\n    it('returns the correct rectangular box', function() {\r\n      // stroke has to be set in order to get the correct result when calling getBoundingClientRect in IE11\r\n      var rect = draw.size(200, 150).viewbox(0, 0, 200, 150).rect(105, 210).move(2, 12).stroke({width:0})\r\n      var box = rect.rbox(draw)\r\n      expect(box.x).toBeCloseTo(2)\r\n      expect(box.y).toBeCloseTo(12)\r\n      expect(box.cx).toBeCloseTo(54.5)\r\n      expect(box.cy).toBeCloseTo(117)\r\n      expect(box.width).toBeCloseTo(105)\r\n      expect(box.height).toBeCloseTo(210)\r\n    })\r\n  })\r\n\r\n  describe('doc()', function() {\r\n    it('returns the parent document', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.doc()).toBe(draw)\r\n    })\r\n  })\r\n\r\n  describe('parent()', function() {\r\n    it('contains the parent svg', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.parent()).toBe(draw)\r\n    })\r\n    it('contains the parent group when in a group', function() {\r\n      var group = draw.group()\r\n        , rect = group.rect(100,100)\r\n      expect(rect.parent()).toBe(group)\r\n    })\r\n    it('contains the parent which matches type', function() {\r\n      var group = draw.group()\r\n        , rect = group.rect(100,100)\r\n      expect(rect.parent(SVG.Doc)).toBe(draw)\r\n    })\r\n    it('contains the parent which matches selector', function() {\r\n      var group1 = draw.group().addClass('test')\r\n        , group2 = group1.group()\r\n        , rect = group2.rect(100,100)\r\n      expect(rect.parent('.test')).toBe(group1)\r\n    })\r\n  })\r\n\r\n  describe('parents()', function() {\r\n    it('returns array of parent up to but not including the dom element filtered by type', function() {\r\n      var group1 = draw.group().addClass('test')\r\n        , group2 = group1.group()\r\n        , rect = group2.rect(100,100)\r\n\r\n      expect(rect.parents('.test')[0]).toBe(group1)\r\n      expect(rect.parents(SVG.G)[0]).toBe(group2)\r\n      expect(rect.parents(SVG.G)[1]).toBe(group1)\r\n      expect(rect.parents().length).toBe(3)\r\n    })\r\n  })\r\n\r\n  describe('clone()', function() {\r\n    var rect, group, circle\r\n\r\n    beforeEach(function() {\r\n      rect   = draw.rect(100,100).center(321,567).fill('#f06')\r\n      group  = draw.group().add(rect)\r\n      circle = group.circle(100)\r\n    })\r\n\r\n    it('makes an exact copy of the element', function() {\r\n      clone = rect.clone()\r\n      expect(clone.attr('id', null).attr()).toEqual(rect.attr('id', null).attr())\r\n    })\r\n    it('assigns a new id to the cloned element', function() {\r\n      clone = rect.clone()\r\n      expect(clone.attr('id')).not.toBe(rect.attr('id'))\r\n    })\r\n    it('copies all child nodes as well', function() {\r\n      clone = group.clone()\r\n      expect(clone.children().length).toBe(group.children().length)\r\n    })\r\n    it('assigns a new id to cloned child elements', function() {\r\n      clone = group.clone()\r\n      expect(clone.attr('id')).not.toEqual(group.attr('id'))\r\n      expect(clone.get(0).attr('id')).not.toBe(group.get(0).attr('id'))\r\n      expect(clone.get(1).attr('id')).not.toBe(group.get(1).attr('id'))\r\n    })\r\n    it('inserts the clone after the cloned element', function() {\r\n      clone = rect.clone()\r\n      expect(rect.next()).toBe(clone)\r\n    })\r\n    it('inserts the clone in the specified parent', function() {\r\n      var g = draw.group()\r\n      clone = rect.clone(g)\r\n      expect(g.get(0)).toBe(clone)\r\n    })\r\n    it('deep copies over dom data', function() {\r\n      group.dom = {'foo':'bar'}\r\n      rect.dom = {'foo':'baz'}\r\n      clone = group.clone()\r\n      expect(clone.dom.foo).toBe('bar')\r\n      expect(clone.get(0).dom.foo).toBe('baz')\r\n    })\r\n  })\r\n\r\n  describe('toString()', function() {\r\n    it('returns the element id', function() {\r\n      var rect = draw.rect(100,100).center(321,567).fill('#f06')\r\n      expect(rect + '').toBe(rect.attr('id'))\r\n    })\r\n  })\r\n\r\n  describe('replace()', function() {\r\n    it('replaces the original element by another given element', function() {\r\n      var rect = draw.rect(100,100).center(321,567).fill('#f06')\r\n      var circle = draw.circle(200)\r\n      var rectIndex = draw.children().indexOf(rect)\r\n\r\n      rect.replace(circle)\r\n\r\n      expect(rectIndex).toBe(draw.children().indexOf(circle))\r\n    })\r\n    it('removes the original element', function() {\r\n      var rect = draw.rect(100,100).center(321,567).fill('#f06')\r\n\r\n      rect.replace(draw.circle(200))\r\n\r\n      expect(draw.has(rect)).toBe(false)\r\n    })\r\n    it('returns the new element', function() {\r\n      var circle  = draw.circle(200)\r\n      var element = draw.rect(100,100).center(321,567).fill('#f06').replace(circle)\r\n\r\n      expect(element).toBe(circle)\r\n    })\r\n  })\r\n\r\n  describe('classes()', function() {\r\n    it('returns an array of classes on the node', function() {\r\n      var element = draw.rect(100,100)\r\n      element.node.setAttribute('class', 'one two')\r\n      expect(element.classes()).toEqual(['one', 'two'])\r\n    })\r\n  })\r\n\r\n  describe('hasClass()', function() {\r\n    it('returns true if the node has the class', function() {\r\n      var element = draw.rect(100,100)\r\n      element.node.setAttribute('class', 'one')\r\n      expect(element.hasClass('one')).toBeTruthy()\r\n    })\r\n\r\n    it('returns false if the node does not have the class', function() {\r\n      var element = draw.rect(100,100)\r\n      element.node.setAttribute('class', 'one')\r\n      expect(element.hasClass('two')).toBeFalsy()\r\n    })\r\n  })\r\n\r\n  describe('addClass()', function() {\r\n    it('adds the class to the node', function() {\r\n      var element = draw.rect(100,100)\r\n      element.addClass('one')\r\n      expect(element.hasClass('one')).toBeTruthy()\r\n    })\r\n\r\n    it('does not add duplicate classes', function() {\r\n      var element = draw.rect(100,100)\r\n      element.addClass('one')\r\n      element.addClass('one')\r\n      expect(element.node.getAttribute('class')).toEqual('one')\r\n    })\r\n\r\n    it('returns the svg instance', function() {\r\n      var element = draw.rect(100,100)\r\n      expect(element.addClass('one')).toEqual(element)\r\n    })\r\n  })\r\n\r\n  describe('removeClass()', function() {\r\n    it('removes the class from the node when the class exists', function() {\r\n      var element = draw.rect(100,100)\r\n      element.addClass('one')\r\n      element.removeClass('one')\r\n      expect(element.hasClass('one')).toBeFalsy()\r\n    })\r\n\r\n    it('does nothing when the class does not exist', function() {\r\n      var element = draw.rect(100,100)\r\n      element.removeClass('one')\r\n      expect(element.hasClass('one')).toBeFalsy()\r\n    })\r\n\r\n    it('returns the element', function() {\r\n      var element = draw.rect(100,100)\r\n      expect(element.removeClass('one')).toEqual(element)\r\n    })\r\n  })\r\n\r\n  describe('toggleClass()', function() {\r\n    it('adds the class when it does not already exist', function(){\r\n      var element = draw.rect(100,100)\r\n      element.toggleClass('one')\r\n      expect(element.hasClass('one')).toBeTruthy()\r\n    })\r\n    it('removes the class when it already exists', function(){\r\n      var element = draw.rect(100,100)\r\n      element.addClass('one')\r\n      element.toggleClass('one')\r\n      expect(element.hasClass('one')).toBeFalsy()\r\n    })\r\n    it('returns the svg instance', function() {\r\n      var element = draw.rect(100,100)\r\n      expect(element.toggleClass('one')).toEqual(element)\r\n    })\r\n  })\r\n\r\n  describe('reference()', function() {\r\n    it('gets a referenced element from a given attribute', function() {\r\n      var rect = draw.defs().rect(100, 100)\r\n        , use  = draw.use(rect)\r\n        , mark = draw.marker(10, 10)\r\n        , path = draw.path(svgPath).marker('end', mark)\r\n\r\n      expect(use.reference('href')).toBe(rect)\r\n      expect(path.reference('marker-end')).toBe(mark)\r\n    })\r\n  })\r\n\r\n  describe('svg()', function() {\r\n    describe('without an argument', function() {\r\n      it('returns full raw svg when called on the main svg doc', function() {\r\n        draw.size(100,100).rect(100,100).id(null)\r\n        draw.circle(100).fill('#f06').id(null)\r\n\r\n        var toBeTested = draw.svg()\r\n\r\n        // Test for different browsers namely Firefox and Chrome\r\n        expect(\r\n            // IE\r\n            toBeTested === '<svg xmlns:svgjs=\"http://svgjs.com/svgjs\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" height=\"100\" width=\"100\" id=\"' + draw.id() + '\"><rect height=\"100\" width=\"100\"></rect><circle fill=\"#ff0066\" cy=\"50\" cx=\"50\" r=\"50\"></circle></svg>'\r\n\r\n            // Firefox\r\n         || toBeTested === '<svg id=\"' + draw.id() + '\" width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\"><rect width=\"100\" height=\"100\"></rect><circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle></svg>'\r\n\r\n            // svgdom\r\n         || toBeTested === '<svg id=\"' + draw.id() + '\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:svgjs=\"http://svgjs.com/svgjs\" width=\"100\" height=\"100\"><svg id=\"SvgjsSvg1002\" width=\"2\" height=\"0\" style=\"overflow: hidden; top: -100%; left: -100%; position: absolute; opacity: 0\"><polyline id=\"SvgjsPolyline1003\" points=\"10,10 20,10 30,10\"></polyline><path id=\"SvgjsPath1004\" d=\"M80 80A45 45 0 0 0 125 125L125 80Z \"></path></svg><rect width=\"100\" height=\"100\"></rect><circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle></svg>'\r\n        ).toBeTruthy()\r\n\r\n      })\r\n      it('returns partial raw svg when called on a sub group', function() {\r\n        var group = draw.group().id(null)\r\n        group.rect(100,100).id(null)\r\n        group.circle(100).fill('#f06').id(null)\r\n\r\n        var toBeTested = group.svg()\r\n\r\n        expect(\r\n            toBeTested === '<g><rect width=\"100\" height=\"100\"></rect><circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle></g>'\r\n         || toBeTested === '<g><rect height=\"100\" width=\"100\"></rect><circle fill=\"#ff0066\" cy=\"50\" cx=\"50\" r=\"50\"></circle></g>'\r\n         || toBeTested === '<g xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\"></rect><circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle></g>'\r\n        ).toBeTruthy()\r\n      })\r\n      it('returns a single element when called on an element', function() {\r\n        var group = draw.group().id(null)\r\n        group.rect(100,100).id(null)\r\n        var circle = group.circle(100).fill('#f06').id(null)\r\n        var toBeTested = circle.svg()\r\n\r\n        expect(\r\n            toBeTested === '<circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle>'\r\n         || toBeTested === '<circle fill=\"#ff0066\" cy=\"50\" cx=\"50\" r=\"50\"></circle>'\r\n         || toBeTested === '<circle xmlns=\"http://www.w3.org/2000/svg\" r=\"50\" cx=\"50\" cy=\"50\" fill=\"#ff0066\"></circle>'\r\n       ).toBeTruthy()\r\n      })\r\n    })\r\n    describe('with raw svg given', function() {\r\n      it('imports a full svg document', function() {\r\n        draw.svg('<svg id=\"SvgjsSvg1000\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100\" height=\"100\" viewBox=\"0 0 50 50\"><rect id=\"SvgjsRect1183\" width=\"100\" height=\"100\"></rect><circle id=\"SvgjsCircle1184\" r=\"50\" cx=\"25\" cy=\"25\" fill=\"#ff0066\"></circle></svg>')\r\n\r\n        expect(draw.get(0+parserInDoc).type).toBe('svg')\r\n        expect(draw.get(0+parserInDoc).children().length).toBe(2)\r\n        expect(draw.get(0+parserInDoc).get(0).type).toBe('rect')\r\n        expect(draw.get(0+parserInDoc).get(1).type).toBe('circle')\r\n        expect(draw.get(0+parserInDoc).get(1).attr('fill')).toBe('#ff0066')\r\n      })\r\n      it('imports partial svg content', function() {\r\n        draw.svg('<g id=\"SvgjsG1185\"><rect id=\"SvgjsRect1186\" width=\"100\" height=\"100\"></rect><circle id=\"SvgjsCircle1187\" r=\"50\" cx=\"25\" cy=\"25\" fill=\"#ff0066\"></circle></g>')\r\n        expect(draw.get(0+parserInDoc).type).toBe('g')\r\n        expect(draw.get(0+parserInDoc).get(0).type).toBe('rect')\r\n        expect(draw.get(0+parserInDoc).get(1).type).toBe('circle')\r\n        expect(draw.get(0+parserInDoc).get(1).attr('fill')).toBe('#ff0066')\r\n      })\r\n      it('does not import on single elements, even with an argument it acts as a getter', function() {\r\n        var rect   = draw.rect(100,100).id(null)\r\n          , result = rect.svg('<circle r=\"300\"></rect>')\r\n\r\n        expect(\r\n            result === '<rect width=\"100\" height=\"100\"></rect>'\r\n         || result === '<rect height=\"100\" width=\"100\"></rect>'\r\n         || result === '<rect xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"></rect>'\r\n        ).toBeTruthy()\r\n      })\r\n    })\r\n  })\r\n\r\n  describe('writeDataToDom()', function() {\r\n    it('set all properties in el.dom to the svgjs:data attribute', function(){\r\n      var rect = draw.rect(100,100)\r\n      rect.dom.foo = 'bar'\r\n      rect.dom.number = new SVG.Number('3px')\r\n\r\n      rect.writeDataToDom()\r\n\r\n      expect(rect.attr('svgjs:data')).toBe('{\"foo\":\"bar\",\"number\":\"3px\"}')\r\n    })\r\n    it('recursively dumps the data', function() {\r\n      var g = draw.group()\r\n      rect = g.rect(100,100)\r\n      g.dom.foo = 'bar'\r\n      rect.dom.number = new SVG.Number('3px')\r\n\r\n      g.writeDataToDom()\r\n\r\n      expect(g.attr('svgjs:data')).toBe('{\"foo\":\"bar\"}')\r\n      expect(rect.attr('svgjs:data')).toBe('{\"number\":\"3px\"}')\r\n    })\r\n    it('uses lines() instead of each() when dealing with text', function() {\r\n      var text = draw.text('Hello\\nWorld')\r\n      text.writeDataToDom()\r\n      expect(text.attr('svgjs:data')).toBe('{\"leading\":\"1.3\"}')\r\n      expect(text.lines().first().attr('svgjs:data')).toBe('{\"newLined\":true}')\r\n    })\r\n  })\r\n\r\n  describe('setData()', function() {\r\n    it('read all data from the svgjs:data attribute and assign it to el.dom', function(){\r\n      var rect = draw.rect(100,100)\r\n\r\n      rect.attr('svgjs:data', '{\"foo\":\"bar\",\"number\":\"3px\"}')\r\n      rect.setData(JSON.parse(rect.attr('svgjs:data')))\r\n\r\n      expect(rect.dom.foo).toBe('bar')\r\n      expect(rect.dom.number).toBe('3px')\r\n    })\r\n  })\r\n\r\n  describe('point()', function() {\r\n    it('creates a point from screen coordinates transformed in the elements space', function(){\r\n      var rect = draw.rect(100,100)\r\n\r\n      var m = draw.node.getScreenCTM()\r\n      // alert([m.a, m.a, m.c, m.d, m.e, m.f].join(', '))\r\n\r\n      var translation = {x: m.e, y: m.f}\r\n      var pos = {x: 2, y:5}\r\n\r\n      expect(rect.point(pos.x, pos.y).x).toBeCloseTo(pos.x - translation.x)\r\n      expect(rect.point(pos.x, pos.y).y).toBeCloseTo(pos.y - translation.y)\r\n    })\r\n  })\r\n\r\n  describe('inside()', function() {\r\n    it('checks whether the given point inside the bounding box of the element', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.inside(50,50)).toBeTruthy()\r\n      expect(rect.inside(150,150)).toBeFalsy()\r\n    })\r\n  })\r\n  describe('show()', function() {\r\n    it('sets display property to \"\"', function() {\r\n      var rect = draw.rect(100,100).show()\r\n      expect(rect.style('display')).toBe('')\r\n    })\r\n  })\r\n  describe('hide()', function() {\r\n    it('sets display property to none', function() {\r\n      var rect = draw.rect(100,100).hide()\r\n      expect(rect.style('display')).toBe('none')\r\n    })\r\n  })\r\n  describe('visible()', function() {\r\n    it('checks if element is hidden or not', function() {\r\n      var rect = draw.rect(100,100).hide()\r\n      expect(rect.visible()).toBeFalsy()\r\n      rect.show()\r\n      expect(rect.visible()).toBeTruthy()\r\n    })\r\n  })\r\n  describe('is()', function() {\r\n    it('checks if element is instance of a certain kind', function() {\r\n      var rect = draw.rect(100,100)\r\n      expect(rect.is(SVG.Rect)).toBeTruthy()\r\n      expect(rect.is(SVG.Element)).toBeTruthy()\r\n      expect(rect.is(SVG.Parent)).toBeFalsy()\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/ellipse.js":"describe('Ellipse', function() {\r\n  var ellipse\r\n  \r\n  beforeEach(function() {\r\n    ellipse = draw.ellipse(240,90)\r\n  })\r\n  \r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n  \r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(ellipse.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      ellipse.x(123)\r\n      var box = ellipse.bbox()\r\n      expect(box.x).toBeCloseTo(123)\r\n    })\r\n  })\r\n  \r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(ellipse.y()).toBe(0)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      ellipse.y(345)\r\n      var box = ellipse.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n  \r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(ellipse.cx()).toBe(120)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      ellipse.cx(123)\r\n      var box = ellipse.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n  \r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(ellipse.cy()).toBe(45)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      ellipse.cy(345)\r\n      var box = ellipse.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('radius()', function() {\r\n    it('sets the rx and ry', function() {\r\n      ellipse.radius(10, 20)\r\n      expect(ellipse.node.getAttribute('rx')).toBe('10')\r\n      expect(ellipse.node.getAttribute('ry')).toBe('20')\r\n    })\r\n    it('sets the rx and ry if only rx given', function() {\r\n      ellipse.radius(30)\r\n      expect(ellipse.node.getAttribute('rx')).toBe('30')\r\n      expect(ellipse.node.getAttribute('ry')).toBe('30')\r\n    })\r\n    it('sets the rx and ry value correctly when given 0', function() {\r\n      ellipse.radius(11, 0)\r\n      expect(ellipse.node.getAttribute('rx')).toBe('11')\r\n      expect(ellipse.node.getAttribute('ry')).toBe('0')\r\n    })\r\n  })\r\n  \r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      ellipse.move(123, 456)\r\n      var box = ellipse.bbox()\r\n      expect(box.x).toBeCloseTo(123)\r\n      expect(box.y).toBeCloseTo(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      ellipse.move(50, 60)\r\n      ellipse.dx(100)\r\n      expect(ellipse.node.getAttribute('cx')).toBe('270')\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      ellipse.move(50, 60)\r\n      ellipse.dy(120)\r\n      expect(ellipse.node.getAttribute('cy')).toBe('225')\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      ellipse.move(50,60)\r\n      ellipse.dmove(80, 25)\r\n      expect(ellipse.node.getAttribute('cx')).toBe('250')\r\n      expect(ellipse.node.getAttribute('cy')).toBe('130')\r\n    })\r\n  })\r\n  \r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      ellipse.center(321,567)\r\n      var box = ellipse.bbox()\r\n      expect(box.cx).toBe(321)\r\n      expect(box.cy).toBe(567)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width of the element', function() {\r\n      ellipse.width(82)\r\n      expect(ellipse.node.getAttribute('rx')).toBe('41')\r\n    })\r\n    it('gets the width of the element if the argument is null', function() {\r\n      expect((ellipse.width() / 2).toString()).toBe(ellipse.node.getAttribute('rx'))\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height of the element', function() {\r\n      ellipse.height(1236)\r\n      expect(ellipse.node.getAttribute('ry')).toBe('618')\r\n    })\r\n    it('gets the height of the element if the argument is null', function() {\r\n      expect((ellipse.height() / 2).toString()).toBe(ellipse.node.getAttribute('ry'))\r\n    })\r\n  })\r\n  \r\n  describe('size()', function() {\r\n    it('defines the rx and ry of the element', function() {\r\n      ellipse.size(987,654)\r\n      expect(ellipse.node.getAttribute('rx')).toBe((987 / 2).toString())\r\n      expect(ellipse.node.getAttribute('ry')).toBe((654 / 2).toString())\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = ellipse.bbox()\r\n      ellipse.size(500)\r\n      expect(ellipse.width()).toBe(500)\r\n      expect(ellipse.width() / ellipse.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = ellipse.bbox()\r\n      ellipse.size(null, 525)\r\n      expect(ellipse.height()).toBe(525)\r\n      expect(ellipse.width() / ellipse.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n  \r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box = ellipse.scale(2).rbox()\r\n      \r\n      expect(box.width).toBe(ellipse.attr('rx') * 2 * 2)\r\n      expect(box.height).toBe(ellipse.attr('ry') * 2 * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box = ellipse.scale(2, 3.5).rbox()\r\n      \r\n      expect(box.width).toBe(ellipse.attr('rx') * 2 * 2)\r\n      expect(box.height).toBe(ellipse.attr('ry') * 2 * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      ellipse.transform({ x: 12, y: 12 })\r\n      expect(ellipse.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n  \r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/event.js":"describe('Event', function() {\r\n  var rect, context\r\n    , toast = null\r\n    , fruitsInDetail = null,\r\n    action = function(e) {\r\n        toast = 'ready'\r\n        context = this\r\n        fruitsInDetail = e.detail || null\r\n      }\r\n\r\n  beforeEach(function() {\r\n    rect = draw.rect(100, 100)\r\n    spyOn(SVG,'on').and.callThrough()\r\n  })\r\n\r\n  afterEach(function() {\r\n    toast = context = null\r\n  })\r\n\r\n  if (!this.isTouchDevice) {\r\n\r\n    describe('click()', function() {\r\n      it('attaches an onclick event to the node of the element', function() {\r\n        rect.click(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'click', action)\r\n      })\r\n      it('fires the event on click', function() {\r\n        rect.click(action).fire('click')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.click(action).fire('click')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.click(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('dblclick()', function() {\r\n      it('attaches an ondblclick event to the node of the element', function() {\r\n        rect.dblclick(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'dblclick', action)\r\n      })\r\n      it('fires the event on dblclick', function() {\r\n        rect.dblclick(action).fire('dblclick')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.dblclick(action).fire('dblclick')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.dblclick(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mousedown()', function() {\r\n      it('attaches an onmousedown event to the node of the element', function() {\r\n        rect.mousedown(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'mousedown', action)\r\n      })\r\n      it('fires the event on mousedown', function() {\r\n        rect.mousedown(action).fire('mousedown')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mousedown(action).fire('mousedown')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mousedown(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mouseup()', function() {\r\n      it('attaches an onmouseup event to the node of the element', function() {\r\n        rect.mouseup(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'mouseup', action)\r\n      })\r\n      it('fires the event on mouseup', function() {\r\n        rect.mouseup(action).fire('mouseup')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mouseup(action).fire('mouseup')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mouseup(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mouseover()', function() {\r\n      it('attaches an onmouseover event to the node of the element', function() {\r\n        rect.mouseover(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'mouseover', action)\r\n      })\r\n      it('fires the event on mouseover', function() {\r\n        rect.mouseover(action).fire('mouseover')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mouseover(action).fire('mouseover')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mouseover(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mouseout()', function() {\r\n      it('attaches an onmouseout event to the node of the element', function() {\r\n        rect.mouseout(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'mouseout', action)\r\n      })\r\n      it('fires the event on mouseout', function() {\r\n        rect.mouseout(action).fire('mouseout')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mouseout(action).fire('mouseout')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mouseout(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mousemove()', function() {\r\n      it('attaches an onmousemove event to the node of the element', function() {\r\n        rect.mousemove(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'mousemove', action)\r\n      })\r\n      it('fires the event on mousemove', function() {\r\n        rect.mousemove(action).fire('mousemove')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mousemove(action).fire('mousemove')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mousemove(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    /*describe('mouseenter()', function() {\r\n      it('attaches an onmouseenter event to the node of the element', function() {\r\n        expect(typeof rect.node.onmouseenter).not.toBe('function')\r\n        rect.mouseenter(action)\r\n        expect(typeof rect.node.onmouseenter).toBe('function')\r\n      })\r\n      it('fires the event on mouseenter', function() {\r\n        rect.mouseenter(action).fire('mouseenter')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mouseenter(action).fire('mouseenter')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mouseenter(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('mouseleave()', function() {\r\n      it('attaches an onmouseleave event to the node of the element', function() {\r\n        expect(typeof rect.node.onmouseleave).not.toBe('function')\r\n        rect.mouseleave(action)\r\n        expect(typeof rect.node.onmouseleave).toBe('function')\r\n      })\r\n      it('fires the event on mouseleave', function() {\r\n        rect.mouseleave(action).fire('mouseleave')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.mouseleave(action).fire('mouseleave')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.mouseleave(action)).toBe(rect)\r\n      })\r\n    })*/\r\n\r\n  } else {\r\n\r\n    describe('touchstart()', function() {\r\n      it('attaches an ontouchstart event to the node of the element', function() {\r\n        rect.touchstart(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'touchstart', action)\r\n      })\r\n      it('fires the event on touchstart', function() {\r\n        rect.touchstart(action).fire('touchstart')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.touchstart(action).fire('touchstart')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.touchstart(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('touchmove()', function() {\r\n      it('attaches an ontouchmove event to the node of the element', function() {\r\n        rect.touchmove(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'touchmove', action)\r\n      })\r\n      it('fires the event on touchmove', function() {\r\n        rect.touchmove(action).fire('touchmove')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.touchmove(action).fire('touchmove')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.touchmove(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('touchleave()', function() {\r\n      it('attaches an ontouchleave event to the node of the element', function() {\r\n        rect.touchleave(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'touchleave', action)\r\n      })\r\n      it('fires the event on touchleave', function() {\r\n        rect.touchleave(action).fire('touchleave')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.touchleave(action).fire('touchleave')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.touchleave(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('touchend()', function() {\r\n      it('attaches an ontouchend event to the node of the element', function() {\r\n        rect.touchend(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'touchend', action)\r\n      })\r\n      it('fires the event on touchend', function() {\r\n        rect.touchend(action).fire('touchend')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.touchend(action).fire('touchend')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.touchend(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n    describe('touchcancel()', function() {\r\n      it('attaches an ontouchcancel event to the node of the element', function() {\r\n        rect.touchcancel(action)\r\n        expect(SVG.on).toHaveBeenCalledWith(rect.node, 'touchcancel', action)\r\n      })\r\n      it('fires the event on touchcancel', function() {\r\n        rect.touchcancel(action).fire('touchcancel')\r\n        expect(toast).toBe('ready')\r\n      })\r\n      it('applies the element as context', function() {\r\n        rect.touchcancel(action).fire('touchcancel')\r\n        expect(context).toBe(rect)\r\n      })\r\n      it('returns the called element', function() {\r\n        expect(rect.touchcancel(action)).toBe(rect)\r\n      })\r\n    })\r\n\r\n  }\r\n\r\n\r\n  describe('on()', function() {\r\n\r\n    it('attaches an event to the element', function() {\r\n      rect.on('event', action).fire('event')\r\n      expect(toast).toBe('ready')\r\n    })\r\n    it('attaches an event to a non svg element', function() {\r\n      var el = document.createElement('div')\r\n      SVG.on(el, 'event', action)\r\n      el.dispatchEvent(new window.CustomEvent('event'))\r\n      expect(toast).toBe('ready')\r\n      SVG.off(el, 'event', action)\r\n    })\r\n    it('attaches multiple handlers on different element', function() {\r\n      var listenerCnt = SVG.listeners.length\r\n\r\n      var rect2 = draw.rect(100,100);\r\n      var rect3 = draw.rect(100,100);\r\n\r\n      rect.on('event', action)\r\n      rect2.on('event', action)\r\n      rect3.on('event', function(){ butter = 'melting' })\r\n      rect3.on('event', action)\r\n\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['*']).length).toBe(1)  // 1 listener on rect\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect2.node)]['event']['*']).length).toBe(1) // 1 listener on rect2\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect3.node)]['event']['*']).length).toBe(2) // 2 listener on rect3\r\n\r\n      expect(SVG.listeners.length).toBe(listenerCnt + 3)                                                  // added listeners on 3 different elements\r\n    })\r\n    if('attaches a handler to a namespaced event', function(){\r\n      var listenerCnt = SVG.listeners.length\r\n\r\n      var rect2 = draw.rect(100,100);\r\n      var rect3 = draw.rect(100,100);\r\n\r\n      rect.on('event.namespace1', action)\r\n      rect2.on('event.namespace2', action)\r\n      rect3.on('event.namespace3', function(){ butter = 'melting' })\r\n      rect3.on('event', action)\r\n\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['*'])).toBeUndefined()          // no global listener on rect\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['namespace1']).length).toBe( 1) // 1 namespaced listener on rect\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect2.node)]['event']['namespace2']).length).toBe(1) // 1 namespaced listener on rect\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect3.node)]['event']['*']).length).toBe(1)          // 1 gobal listener on rect3\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect3.node)]['event']['namespace3']).length).toBe(1) // 1 namespaced listener on rect3\r\n      expect(SVG.listeners.length).toBe(listenerCnt + 3)                                                           // added listeners on 3 different elements\r\n    })\r\n    it('applies the element as context', function() {\r\n      rect.on('event', action).fire('event')\r\n      expect(context).toBe(rect)\r\n    })\r\n    it('applies given object as context', function() {\r\n      rect.on('event', action, this).fire('event')\r\n      expect(context).toBe(this)\r\n    })\r\n    it('stores the listener for future reference', function() {\r\n      rect.on('event', action)\r\n      expect(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['*'][action._svgjsListenerId]).not.toBeUndefined()\r\n    })\r\n    it('returns the called element', function() {\r\n      expect(rect.on('event', action)).toBe(rect)\r\n    })\r\n  })\r\n\r\n  describe('off()', function() {\r\n    var butter = null\r\n\r\n    beforeEach(function() {\r\n      butter = null\r\n    })\r\n\r\n    it('detaches a specific event listener, all other still working', function() {\r\n      rect2 = draw.rect(100,100);\r\n      rect3 = draw.rect(100,100);\r\n\r\n      rect.on('event', action)\r\n      rect2.on('event', action)\r\n      rect3.on('event', function(){ butter = 'melting' })\r\n\r\n      rect.off('event', action)\r\n\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['*']).length).toBe(0)\r\n\r\n      rect.fire('event')\r\n      expect(toast).toBeNull()\r\n\r\n      rect2.fire('event')\r\n      expect(toast).toBe('ready')\r\n\r\n      rect3.fire('event')\r\n      expect(butter).toBe('melting')\r\n\r\n      expect(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['*'][action]).toBeUndefined()\r\n    })\r\n    it('detaches a specific namespaced event listener, all other still working', function() {\r\n      rect2 = draw.rect(100,100);\r\n      rect3 = draw.rect(100,100);\r\n\r\n      rect.on('event.namespace', action)\r\n      rect2.on('event.namespace', action)\r\n      rect3.on('event.namespace', function(){ butter = 'melting' })\r\n\r\n      rect.off('event.namespace', action)\r\n\r\n      expect(Object.keys(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['namespace']).length).toBe(0)\r\n\r\n      rect.fire('event')\r\n      expect(toast).toBeNull()\r\n\r\n      rect2.fire('event')\r\n      expect(toast).toBe('ready')\r\n\r\n      rect3.fire('event')\r\n      expect(butter).toBe('melting')\r\n\r\n      expect(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']['namespace'][action]).toBeUndefined()\r\n    })\r\n    it('detaches all listeners for a specific namespace', function() {\r\n      rect.on('event', action)\r\n      rect.on('event.namespace', function() { butter = 'melting'; })\r\n      rect.off('.namespace')\r\n\r\n      rect.fire('event')\r\n      expect(toast).toBe('ready')\r\n      expect(butter).toBeNull()\r\n    })\r\n    it('detaches all listeners for an event without a listener given', function() {\r\n      rect.on('event', action)\r\n      rect.on('event.namespace', function() { butter = 'melting'; })\r\n      rect.off('event')\r\n\r\n      rect.fire('event')\r\n      expect(toast).toBeNull()\r\n      expect(butter).toBeNull()\r\n      expect(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]['event']).toBeUndefined()\r\n    })\r\n    it('detaches all listeners without an argument', function() {\r\n      rect.on('event', action)\r\n      rect.on('click', function() { butter = 'melting' })\r\n      rect.off()\r\n      rect.fire('event')\r\n      rect.fire('click')\r\n      expect(toast).toBeNull()\r\n      expect(butter).toBeNull()\r\n      expect(SVG.listeners[SVG.handlerMap.indexOf(rect.node)]).toBeUndefined()\r\n    })\r\n    it('returns the called element', function() {\r\n      expect(rect.off('event', action)).toBe(rect)\r\n    })\r\n    it('does not throw when event is removed which was already removed with a global off', function() {\r\n      var undefined\r\n\r\n      rect.on('event', action)\r\n      rect.off()\r\n      try{\r\n        rect.off('event')\r\n      }catch(e){\r\n        expect('Should not error out').toBe(true)\r\n      }\r\n\r\n      expect(SVG.handlerMap[SVG.handlerMap.indexOf(rect.node)]).toBe(undefined)\r\n    })\r\n  })\r\n\r\n  describe('fire()', function() {\r\n\r\n    beforeEach(function() {\r\n      rect.on('event', action)\r\n    })\r\n\r\n    it('fires an event for the element', function() {\r\n      expect(toast).toBeNull()\r\n      rect.fire('event')\r\n      expect(toast).toBe('ready')\r\n      expect(fruitsInDetail).toBe(null)\r\n    })\r\n    it('returns the called element', function() {\r\n      expect(rect.fire('event')).toBe(rect)\r\n    })\r\n    it('fires event with additional data', function() {\r\n      expect(fruitsInDetail).toBeNull()\r\n      rect.fire('event', {apple:1})\r\n      expect(fruitsInDetail).not.toBe(null)\r\n      expect(fruitsInDetail.apple).toBe(1)\r\n    })\r\n    it('fires my own event', function() {\r\n      toast = null\r\n      rect.fire(new window.CustomEvent('event'))\r\n      expect(toast).toBe('ready')\r\n    })\r\n    it('makes the event cancelable', function() {\r\n      rect.on('event', function(e) {\r\n        e.preventDefault()\r\n      })\r\n      rect.fire('event')\r\n      expect(rect._event.defaultPrevented).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('event()', function() {\r\n    it('returns null when no event was fired', function() {\r\n      expect(rect.event()).toBe(null)\r\n    })\r\n    it('returns the last fired event', function() {\r\n      var event = new window.CustomEvent('foo')\r\n      rect.fire(event)\r\n      expect(rect.event()).toBe(event)\r\n\r\n      event = new window.CustomEvent('bar')\r\n      rect.fire(event)\r\n      expect(rect.event()).toBe(event)\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/fx.js":"describe('FX', function() {\r\n  var rect, fx, undefined;\r\n\r\n  beforeEach(function() {\r\n    rect = draw.rect(100,100).move(100,100)\r\n    fx = rect.animate(500)\r\n\r\n    jasmine.clock().install()\r\n    jasmine.clock().mockDate() // This freeze the Date\r\n  })\r\n\r\n  afterEach(function() {\r\n    jasmine.clock().uninstall()\r\n\r\n    fx.stop(false, true)\r\n  })\r\n\r\n\r\n  it('creates an instance of SVG.FX and sets parameter', function() {\r\n    expect(fx instanceof SVG.FX).toBe(true)\r\n    expect(fx._target).toBe(rect)\r\n    expect(fx.absPos).toBe(0)\r\n    expect(fx.pos).toBe(0)\r\n    expect(fx.lastPos).toBe(0)\r\n    expect(fx.paused).toBe(false)\r\n    expect(fx.active).toBe(false)\r\n    expect(fx._speed).toBe(1)\r\n    expect(fx.situations).toEqual([])\r\n    expect(fx.situation.init).toBe(false)\r\n    expect(fx.situation.reversed).toBe(false)\r\n    expect(fx.situation.duration).toBe(500)\r\n    expect(fx.situation.delay).toBe(0)\r\n    expect(fx.situation.loops).toBe(false)\r\n    expect(fx.situation.loop).toBe(0)\r\n    expect(fx.situation.animations).toEqual({})\r\n    expect(fx.situation.attrs).toEqual({})\r\n    expect(fx.situation.styles).toEqual({})\r\n    expect(fx.situation.transforms).toEqual([])\r\n    expect(fx.situation.once).toEqual({})\r\n  })\r\n\r\n  describe('animate()', function () {\r\n    it('set duration, ease and delay of the new situation to their default value when they are not passed', function() {\r\n      var defaultDuration = 1000\r\n        , defaultEase = SVG.easing['-']\r\n        , defaultDelay = 0\r\n        , lastSituation = fx.animate().last()\r\n\r\n      expect(lastSituation.duration).toBe(defaultDuration)\r\n      expect(lastSituation.ease).toBe(defaultEase)\r\n      expect(lastSituation.delay).toBe(defaultDelay)\r\n    })\r\n\r\n    it('use the passed values to set duration, ease and delay of the new situation', function() {\r\n      var duration = 14502\r\n        , ease = '>'\r\n        , delay = 450\r\n        , lastSituation = fx.animate(duration, ease, delay).last()\r\n\r\n      expect(lastSituation.duration).toBe(duration)\r\n      expect(lastSituation.ease).toBe(SVG.easing[ease])\r\n      expect(lastSituation.delay).toBe(delay)\r\n    })\r\n\r\n    it('allow duration, ease and delay to be passed in an object', function() {\r\n      var o = {\r\n                duration: 7892\r\n              , ease: '<'\r\n              , delay: 1145\r\n              }\r\n        , lastSituation = fx.animate(o).last()\r\n\r\n      expect(lastSituation.duration).toBe(o.duration)\r\n      expect(lastSituation.ease).toBe(SVG.easing[o.ease])\r\n      expect(lastSituation.delay).toBe(o.delay)\r\n    })\r\n\r\n    it('allow ease to be a custom function', function () {\r\n      var customEase = function() {}\r\n        , lastSituation = fx.animate({ease: customEase}).last()\r\n\r\n      expect(lastSituation.ease).toBe(customEase)\r\n    })\r\n  })\r\n\r\n  describe('target()', function(){\r\n    it('returns the current fx object with no argument given', function(){\r\n      expect(fx.target()).toBe(rect)\r\n    })\r\n\r\n    it('changes the target of the animation when parameter given', function(){\r\n      var c = draw.circle(5)\r\n      expect(fx.target(c).target()).toBe(c)\r\n    })\r\n  })\r\n\r\n\r\n  describe('timeToAbsPos()', function() {\r\n    it('converts a timestamp to an absolute progress', function() {\r\n      expect(fx.timeToAbsPos( fx.situation.start + fx.situation.duration*0.5 )).toBe(0.5)\r\n    })\r\n\r\n    it('should take speed into consideration', function() {\r\n      var spd\r\n\r\n      spd = 4\r\n      fx.speed(spd)\r\n      expect(fx.timeToAbsPos( fx.situation.start + (fx.situation.duration/spd)*0.5 )).toBe(0.5)\r\n\r\n      spd = 0.5\r\n      fx.speed(spd)\r\n      expect(fx.timeToAbsPos( fx.situation.start + (fx.situation.duration/spd)*0.25 )).toBe(0.25)\r\n    })\r\n  })\r\n\r\n\r\n  describe('absPosToTime()', function() {\r\n    it('converts an absolute progress to a timestamp', function() {\r\n      expect(fx.absPosToTime(0.5)).toBe( fx.situation.start + fx.situation.duration*0.5 )\r\n    })\r\n\r\n    it('should take speed into consideration', function() {\r\n      var spd\r\n\r\n      spd = 4\r\n      fx.speed(spd)\r\n      expect(fx.absPosToTime(0.5)).toBe( fx.situation.start + (fx.situation.duration/spd)*0.5 )\r\n\r\n      spd = 0.5\r\n      fx.speed(spd)\r\n      expect(fx.absPosToTime(0.25)).toBe( fx.situation.start + (fx.situation.duration/spd)*0.25 )\r\n    })\r\n  })\r\n\r\n\r\n  describe('atStart()', function () {\r\n    it('sets the animation at the start', function() {\r\n      // When the animation is running forward, the start position is 0\r\n      fx.pos = 0.5\r\n      expect(fx.atStart().pos).toBe(0)\r\n\r\n      // When the animation is running backward, the start position is 1\r\n      fx.pos = 0.5\r\n      expect(fx.reverse(true).atStart().pos).toBe(1)\r\n    })\r\n\r\n    it('sets the animation at the start, before any loops', function() {\r\n      fx.loop(true)\r\n\r\n      // When the animation is running forward, the start position is 0\r\n      fx.at(3.7, true)\r\n      expect(fx.absPos).toBe(3.7)\r\n      expect(fx.pos).toBeCloseTo(0.7)\r\n      expect(fx.situation.loop).toBe(3)\r\n\r\n      fx.atStart()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.situation.loop).toBe(0)\r\n\r\n      // When the animation is running backward, the start position is 1\r\n      fx.reverse(true).at(2.14, true)\r\n      expect(fx.absPos).toBe(2.14)\r\n      expect(fx.pos).toBeCloseTo(1 - 0.14)\r\n      expect(fx.situation.loop).toBe(2)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      fx.atStart()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.reversed).toBe(true)\r\n    })\r\n\r\n    it('sets the animation at the start, before any loops when reversing is true', function() {\r\n      fx.loop(true, true) // Set reversing to true\r\n\r\n      // When the animation is running forward, the start position is 0\r\n      fx.at(11.21, true)\r\n      expect(fx.absPos).toBe(11.21)\r\n      expect(fx.pos).toBeCloseTo(1 - 0.21)\r\n      expect(fx.situation.loop).toBe(11)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      fx.atStart()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.reversed).toBe(false)\r\n\r\n      // When the animation is running backward, the start position is 1\r\n      fx.reverse(true).at(14.10, true)\r\n      expect(fx.absPos).toBe(14.10)\r\n      expect(fx.pos).toBeCloseTo(1 - 0.10)\r\n      expect(fx.situation.loop).toBe(14)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      fx.atStart()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.reversed).toBe(true)\r\n    })\r\n  })\r\n\r\n\r\n  describe('atEnd()', function () {\r\n    it('sets the animation at the end', function() {\r\n      // When the animation is running forward, the end position is 1\r\n      fx.pos = 0.5\r\n      expect(fx.atEnd().pos).toBe(1)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate()\r\n\r\n      // When the animation is running backward, the end position is 0\r\n      fx.pos = 0.5\r\n      expect(fx.reverse(true).atEnd().pos).toBe(0)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    it('sets the animation at the end, after all loops', function() {\r\n      var loops\r\n\r\n      // When the animation is running forward, the end position is 1\r\n      loops = 12\r\n      fx.loop(loops).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(loops)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(loops)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate()\r\n\r\n\r\n      // When the animation is running backward, the end position is 0\r\n      loops = 21\r\n      fx.reverse(true).loop(loops).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(loops)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(loops)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    it('sets the animation at the end, after all loops when reversing is true', function() {\r\n      var loops\r\n\r\n      // When reversing is true, the end position is 0 when loops is even and\r\n      // 1 when loops is odd\r\n\r\n      // The animation is running forward\r\n      loops = 6\r\n      fx.loop(loops, true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(loops)\r\n      expect(fx.situation.reversed).toBe(false)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(loops)\r\n      expect(fx.pos).toBe(0) // End position is 0 because loops is even\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate()\r\n\r\n      // When reversing is true and the animation is running backward,\r\n      // the end position is 1 when loops is even and 0 when loops is odd\r\n\r\n      // The animation is running backward\r\n      loops = 3\r\n      fx.reverse(true).loop(loops, true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(loops)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(loops)\r\n      expect(fx.pos).toBe(0) // End position is 0 because loops is odd\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    it('sets the animation at the end of the current iteration when in an infinite loop', function () {\r\n      // When the animation is running forward, the end position is 1\r\n      fx.loop(true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      // Should be halfway through iteration 10\r\n      jasmine.clock().tick(500 * 10 + 250)\r\n      fx.step()\r\n      expect(fx.absPos).toBe(10.5)\r\n      expect(fx.pos).toBe(0.5)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(10)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(11)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate(500)\r\n\r\n      // When the animation is running backward, the end position is 0\r\n      fx.reverse(true).loop(true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      // Should be halfway through iteration 21\r\n      jasmine.clock().tick(500 * 21 + 250)\r\n      fx.step()\r\n      expect(fx.absPos).toBe(21.5)\r\n      expect(fx.pos).toBe(0.5)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(21)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(22)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n\r\n    it('sets the animation at the end of the current iteration when in an infinite loop and reversing is true', function () {\r\n      // When reversing is true, the end position is 1 when ending on an even\r\n      // iteration and 0 when ending on an odd iteration as illustrated below:\r\n\r\n      //   0          Iteration          1\r\n      //   |--------------0------------->|\r\n      //   |<-------------1--------------|\r\n      //   |--------------2------------->|\r\n      //   |<-------------3--------------|\r\n      //                 ...\r\n\r\n\r\n      // The animation is running forward\r\n      fx.loop(true, true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      // Should be halfway through iteration 11\r\n      jasmine.clock().tick(500 * 11 + 250)\r\n      fx.step()\r\n      expect(fx.absPos).toBe(11.5)\r\n      expect(fx.pos).toBe(0.5)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(11)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(12)\r\n      expect(fx.pos).toBe(0) // End position is 0 because ended on a odd iteration\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate(500)\r\n\r\n      // When reversing is true and the animation is running backward,\r\n      // the end position is 0 when ending on an even iteration and\r\n      // 1 when ending on an odd iteration as illustrated below:\r\n\r\n      //   0          Iteration          1\r\n      //   |<-------------0--------------|\r\n      //   |--------------1------------->|\r\n      //   |<-------------2--------------|\r\n      //   |--------------3------------->|\r\n      //                 ...\r\n\r\n      // The animation is running backward\r\n      fx.reverse(true).loop(true).start().step()\r\n      expect(fx.absPos).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      // Should be halfway through iteration 42\r\n      jasmine.clock().tick(500 * 42 + 250)\r\n      fx.step()\r\n      expect(fx.absPos).toBe(42.5)\r\n      expect(fx.pos).toBe(0.5)\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(42)\r\n      expect(fx.situation.loops).toBe(true)\r\n\r\n      fx.atEnd()\r\n      expect(fx.absPos).toBe(43)\r\n      expect(fx.pos).toBe(0) // End position is 0 because ended on an even iteration\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n  })\r\n\r\n\r\n  describe('at()', function() {\r\n    it('sets the progress to the specified position', function() {\r\n      var pos\r\n\r\n      // Animation running forward\r\n      pos = 0.5\r\n      expect(fx.at(pos).pos).toBe(pos)\r\n      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * pos)\r\n\r\n      // Animation running backward\r\n      pos = 0.4\r\n      expect(fx.reverse(true).at(pos).pos).toBe(pos)\r\n      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * (1-pos))\r\n    })\r\n\r\n    it('should convert a position to an absolute position', function () {\r\n      var pos, loop, absPos\r\n\r\n      fx.loop(true)\r\n\r\n      // Animation running forward\r\n      pos = 0.7\r\n      loop = 4\r\n      absPos = pos+loop\r\n      fx.situation.loop = loop\r\n      expect(fx.at(pos).absPos).toBe(absPos)\r\n      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * absPos)\r\n\r\n      // Animation running backward\r\n      pos = 0.23\r\n      loop = 9\r\n      absPos = (1-pos)+loop\r\n      fx.situation.loop = loop\r\n      fx.situation.reversed = true\r\n      expect(fx.at(pos).absPos).toBe(absPos)\r\n      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * absPos)\r\n\r\n    })\r\n\r\n    it('should end the animation when the end position is passed', function() {\r\n      var pos\r\n\r\n      fx.start()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation).not.toBeNull()\r\n\r\n      // When running forward, the end position is 1\r\n      pos = 1\r\n      expect(fx.at(pos).pos).toBe(pos)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate().start()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation).not.toBeNull()\r\n\r\n      // When running backward, the end position is 0\r\n      pos = 0\r\n      expect(fx.reverse(true).at(pos).pos).toBe(pos)\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    it('correct the passed position when it is out of [0,1] and the animation is not looping', function () {\r\n      var pos\r\n\r\n      pos = -0.7\r\n      expect(fx.at(pos).pos).toBe(0)\r\n\r\n      pos = 1.3\r\n      expect(fx.at(pos).pos).toBe(1)\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate()\r\n\r\n      // Should work even when animation is running backward\r\n      pos = 1.3\r\n      expect(fx.reverse(true).at(pos).pos).toBe(1)\r\n\r\n      pos = -0.7\r\n      expect(fx.reverse(true).at(pos).pos).toBe(0)\r\n    })\r\n\r\n    it('should, when the animation is looping and the passed position is out of [0,1], use the integer part of postion to update the loop counter and set position to its fractional part', function(){\r\n      var loop, pos, posFrac, posInt\r\n\r\n      // Without the reverse flag\r\n      fx.loop(10)\r\n      expect(fx.situation.loops).toBe(10)\r\n      expect(fx.situation.loop).toBe(loop = 0)\r\n\r\n      pos = 1.3\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(posFrac)\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n\r\n      pos = 7.723\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(posFrac)\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n\r\n      // In this case, pos is above the remaining number of loops, so we expect\r\n      // the position to be set to 1 and the animation to be ended\r\n      pos = 4.3\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBe(1)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      // Recreate an animation since the other one was ended\r\n      fx.animate()\r\n\r\n      // With the reverse flag, the position is reversed each time loop is odd\r\n      fx.loop(10, true)\r\n      expect(fx.situation.loops).toBe(10)\r\n      expect(fx.situation.loop).toBe(loop = 0)\r\n      expect(fx.situation.reversed).toBe(false)\r\n\r\n      pos = 3.3\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(1-posFrac) // Animation is reversed because 0+3 is odd\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      // When the passed position is below 0, the integer part of position is\r\n      // substracted from 1, so, in this case, -0.6 has 1 as is integer part\r\n      // This is necessary so we can add something to the loop counter\r\n      pos = -0.645\r\n      posFrac = (1-pos) % 1\r\n      posInt = (1-pos) - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(posFrac)\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n      expect(fx.situation.reversed).toBe(false)\r\n\r\n      // In this case, pos is above the remaining number of loop, so we expect\r\n      // the position to be set to 0 (since we end reversed) and the animation to\r\n      // be ended\r\n      pos = 7.2\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBe(0)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    it('should, when the animation is in a infinite loop and the passed position is out of [0,1], use the integer part of postion to update the loop counter and set position to its fractional part', function(){\r\n      var loop, pos, posFrac, posInt\r\n\r\n      // Without the reverse flag\r\n      fx.loop(true)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.situation.loop).toBe(loop = 0)\r\n\r\n      pos = 10.34\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(posFrac)\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n\r\n      // With the reverse flag, the position is reversed each time loop is odd\r\n      fx.loop(true, true)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.situation.loop).toBe(loop = 0)\r\n      expect(fx.situation.reversed).toBe(false)\r\n\r\n      pos = 3.3\r\n      posFrac = pos % 1\r\n      posInt = pos - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(1-posFrac) // Animation is reversed because 3+0 is odd\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n      expect(fx.situation.reversed).toBe(true)\r\n\r\n      pos = -8.41\r\n      posFrac = (1-pos) % 1\r\n      posInt = (1-pos) - posFrac\r\n      expect(fx.at(pos).pos).toBeCloseTo(posFrac)\r\n      expect(fx.situation.loop).toBe(loop += posInt)\r\n      expect(fx.situation.reversed).toBe(false)\r\n    })\r\n\r\n    it('should take speed into consideration', function() {\r\n      var dur, spd\r\n\r\n      dur = fx.situation.duration\r\n\r\n      spd = 4\r\n      fx.speed(spd).at(0)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 5\r\n      fx.speed(spd).at(0.15)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 0.25\r\n      fx.speed(spd).at(0.75)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 0.5\r\n      fx.speed(spd).at(0.83)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n    })\r\n\r\n    it('should consider the first parameter as an absolute position when the second parameter is true', function() {\r\n      var absPos\r\n\r\n      fx.loop(true)\r\n\r\n      absPos = 3.2\r\n      expect(fx.at(absPos, true).absPos).toBe(absPos)\r\n\r\n      absPos = -4.27\r\n      expect(fx.at(absPos, true).absPos).toBe(absPos)\r\n\r\n      absPos = 0\r\n      expect(fx.at(absPos, true).absPos).toBe(absPos)\r\n\r\n      absPos = 1\r\n      expect(fx.at(absPos, true).absPos).toBe(absPos)\r\n    })\r\n  })\r\n\r\n\r\n  describe('start()', function(){\r\n    it('starts the animation', function() {\r\n      fx.start()\r\n      expect(fx.active).toBe(true)\r\n\r\n      jasmine.clock().tick(200)\r\n      fx.step() // Call step to update the animation\r\n\r\n      expect(fx.pos).toBeGreaterThan(0)\r\n    })\r\n\r\n    it('should take speed into consideration', function() {\r\n      var dur = 500\r\n        , delay = 300\r\n        , spd = 4\r\n\r\n\r\n      fx.stop().animate(dur, '-', delay).speed(spd).start()\r\n      expect(fx.situation.finish - new Date).toBe(delay/spd + dur/spd)\r\n    })\r\n\r\n    it('should do the delay', function() {\r\n      fx.situation.delay = 1000\r\n      expect(fx.start().active).toBe(true)\r\n\r\n      jasmine.clock().tick(501)\r\n      fx.step() // Call step to update the animation\r\n      expect(fx.active).toBe(true)\r\n\r\n      jasmine.clock().tick(501)\r\n      fx.step() // Call step to update the animation\r\n      expect(fx.active).toBe(true)\r\n\r\n      jasmine.clock().tick(501)\r\n      fx.step() // Call step to update the animation\r\n      expect(fx.active).toBe(false)\r\n    })\r\n  })\r\n\r\n  describe('delay()', function() {\r\n    it('should push an empty situation with its duration attribute set to the duration of the delay', function() {\r\n      var delay = 8300\r\n      fx.delay(delay)\r\n      expect(fx.situations[0].duration).toBe(delay)\r\n    })\r\n  })\r\n\r\n\r\n  describe('pause()', function() {\r\n    it('pause the animation', function() {\r\n      expect(fx.pause().paused).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('play()', function() {\r\n    it('returns itself when animation not paused', function() {\r\n      expect(fx.paused).toBe(false)\r\n      expect(fx.play()).toBe(fx)\r\n    })\r\n\r\n    it('unpause the animation', function() {\r\n      var start = fx.start().pause().situation.start\r\n\r\n      jasmine.clock().tick(200)\r\n\r\n      expect(fx.situation.start).toBe(start)\r\n      expect(fx.play().paused).toBe(false)\r\n      expect(fx.situation.start).not.toBe(start)\r\n    })\r\n\r\n    it('should not change the position when the animation is unpaused while it is set to run backward', function(){\r\n      var pos = 0.4\r\n\r\n      expect(fx.reverse(true).at(pos).pause().play().pos).toBe(pos)\r\n    })\r\n\r\n    it('should be able to unpause the delay', function () {\r\n      fx.stop().animate(500, '-', 300).start().step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBeCloseTo(-0.6)\r\n\r\n      // At this point, we should have an animation of 500 ms with a delay of\r\n      // 300 ms that should be running.\r\n\r\n      jasmine.clock().tick(150)\r\n\r\n      // Should be halfway through the delay\r\n      fx.step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(-0.3)\r\n\r\n      expect(fx.pause().paused).toBe(true) // Pause the delay\r\n\r\n      jasmine.clock().tick(150)\r\n\r\n      // Unpause, should still be halfway through the delay\r\n      expect(fx.play().paused).toBe(false)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(-0.3)\r\n\r\n      jasmine.clock().tick(150)\r\n\r\n      // Delay should be done\r\n      fx.step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      jasmine.clock().tick(500)\r\n\r\n      // Animation and delay should be done\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.absPos).toBe(1)\r\n    })\r\n  })\r\n\r\n\r\n  describe('speed()', function() {\r\n    it('set the speed of the animation', function(){\r\n      var dur, spd\r\n\r\n      dur = fx.situation.duration\r\n\r\n      spd = 2\r\n      fx.speed(spd)\r\n      expect(fx._speed).toBe(spd)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 0.5\r\n      fx.speed(spd)\r\n      expect(fx._speed).toBe(spd)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 2\r\n      fx.at(0.2).speed(spd)\r\n      expect(fx._speed).toBe(spd)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)\r\n\r\n      spd = 1\r\n      fx.speed(spd)\r\n      expect(fx._speed).toBe(spd)\r\n      expect(fx.situation.finish-fx.situation.start).toBe(dur)\r\n    })\r\n\r\n    it('should not change the position when the animation is run backward', function(){\r\n      var pos = 0.4\r\n\r\n      expect(fx.reverse(true).at(pos).speed(2).pos).toBe(pos)\r\n    })\r\n\r\n    it('return the current speed with no argument given', function(){\r\n      var spd\r\n\r\n      spd = 2\r\n      fx._speed = spd\r\n      expect(fx.speed()).toBe(spd)\r\n\r\n      spd = 0.5\r\n      fx._speed = spd\r\n      expect(fx.speed()).toBe(spd)\r\n\r\n      spd = 1\r\n      fx._speed = spd\r\n      expect(fx.speed()).toBe(spd)\r\n    })\r\n\r\n    it('pause the animation when a speed of 0 is passed', function(){\r\n      var spd = fx._speed\r\n\r\n      expect(fx.speed(0)).toBe(fx)\r\n      expect(fx._speed).toBe(spd)\r\n      expect(fx.paused).toBe(true)\r\n    })\r\n\r\n    it('should affect all animations in the queue', function(){\r\n      fx.speed(2).animate(300)\r\n      expect(fx.situations.length).not.toBe(0)\r\n      expect(fx.pos).not.toBe(1)\r\n\r\n      // At this point, there should be 2 animations in the queue to be played:\r\n      // the one of 500ms that is added before every test and the one of 300ms\r\n      // we just added. Normally, it would take 800ms before both of these\r\n      // animations are done, but because we set the speed to 2, it should\r\n      // only take 400ms to do both animations.\r\n      fx.start().step()\r\n\r\n      jasmine.clock().tick(250)\r\n\r\n      // Should be playing the second animation\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situations.length).toBe(0)\r\n      expect(fx.pos).not.toBe(1)\r\n\r\n      jasmine.clock().tick(150) // 400ms have passed\r\n\r\n      // All animations should be done\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situations.length).toBe(0)\r\n      expect(fx.pos).toBe(1)\r\n    })\r\n\r\n    it('should affect the delay', function() {\r\n      fx.stop().animate(500, '-', 300).start().step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBeCloseTo(-0.6)\r\n\r\n      fx.speed(2)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBeCloseTo(-0.6)\r\n\r\n      // At this point, we should have an animation of 500 ms with a delay of\r\n      // 300 ms that should be running. Normally, it would take 800 ms for the\r\n      // animation and its delay to complete, but because the speed is set to 2\r\n      // , it should only take 400ms\r\n\r\n      jasmine.clock().tick(75)\r\n\r\n      // Should be halfway through the delay\r\n      fx.step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(-0.3)\r\n\r\n      jasmine.clock().tick(75)\r\n\r\n      // Delay should be done\r\n      fx.step()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      jasmine.clock().tick(250)\r\n\r\n      // Animation and delay should be done\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.absPos).toBe(1)\r\n    })\r\n  })\r\n\r\n\r\n  describe('reverse()', function() {\r\n    it('toggles the direction of the animation without a parameter', function() {\r\n      expect(fx.reverse().situation.reversed).toBe(true)\r\n    })\r\n    it('sets the direction to backwards with true given', function() {\r\n      expect(fx.reverse(true).situation.reversed).toBe(true)\r\n    })\r\n    it('sets the direction to forwards with false given', function() {\r\n      expect(fx.reverse(false).situation.reversed).toBe(false)\r\n    })\r\n  })\r\n\r\n\r\n  describe('queue()', function() {\r\n    it('can add a situation to the queue', function() {\r\n      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})\r\n\r\n      fx.queue(situation)\r\n      expect(fx.situations[0]).toBe(situation)\r\n    })\r\n\r\n    it('can add a function to the queue', function() {\r\n      var f = function(){}\r\n\r\n      fx.queue(f)\r\n      expect(fx.situations[0]).toBe(f)\r\n    })\r\n\r\n    it('should set the situation attribute before pushing something in the situations queue', function(){\r\n      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})\r\n\r\n      // Clear the animation that is created before each test\r\n      fx.stop()\r\n\r\n      expect(fx.situation).toBeNull()\r\n      expect(fx.situations.length).toBe(0)\r\n      fx.queue(situation)\r\n      expect(fx.situation).toBe(situation)\r\n      expect(fx.situations.length).toBe(0)\r\n    })\r\n  })\r\n\r\n\r\n  describe('dequeue()', function() {\r\n    it('should pull the next situtation from the queue', function() {\r\n      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})\r\n\r\n      fx.queue(situation)\r\n      expect(fx.situtation).not.toBe(situation)\r\n      expect(fx.situations[0]).toBe(situation)\r\n\r\n      fx.dequeue()\r\n      expect(fx.situation).toBe(situation)\r\n      expect(fx.situations.length).toBe(0)\r\n    })\r\n\r\n    it('initialize the animation pulled from the queue to its start position', function() {\r\n      // When the animation is forward, the start position is 0\r\n      fx.animate()\r\n      fx.pos = 0.5\r\n      expect(fx.dequeue().pos).toBe(0)\r\n\r\n      // When the animation backward, the start position is 1\r\n      fx.animate().reverse(true)\r\n      fx.pos = 0.5\r\n      expect(fx.dequeue().pos).toBe(1)\r\n    })\r\n\r\n    it('when the first element of the queue is a function, it should execute it', function() {\r\n      var called = false\r\n\r\n      fx.queue(function(){\r\n        called = true\r\n        expect(this).toBe(fx)\r\n        this.dequeue()\r\n      }).dequeue()\r\n\r\n      expect(called).toBe(true)\r\n    })\r\n\r\n    it('should stop the currently running animation when there is one', function() {\r\n      fx.start()\r\n      expect(fx.active).toBe(true)\r\n      fx.queue(function() {\r\n        expect(this.active).toBe(false)\r\n        this.dequeue()\r\n      })\r\n      fx.dequeue()\r\n    })\r\n  })\r\n\r\n\r\n  describe('stop()', function() {\r\n    it('stops the animation immediately without a parameter', function() {\r\n      fx.animate(500).start()\r\n      expect(fx.stop().situation).toBeNull()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situations.length).toBe(1)\r\n    })\r\n    it('stops the animation immediately and fullfill it if first parameter true', function() {\r\n      fx.animate(500).start()\r\n      expect(fx.stop(true).situation).toBeNull()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.situations.length).toBe(1)\r\n    })\r\n    it('stops the animation immediately and remove all items from queue when second parameter true', function() {\r\n      fx.animate(500).start()\r\n      expect(fx.stop(false, true).situation).toBeNull()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situations.length).toBe(0)\r\n    })\r\n  })\r\n\r\n\r\n  describe('reset()', function() {\r\n    it('resets the element to the state it was when the current animation was started', function() {\r\n      var loops = 4\r\n        , situation = fx.situation\r\n\r\n      // These settings make the animations run backward\r\n      fx.situation.loop = 2\r\n      fx.situation.loops = loops\r\n      fx.situation.reversed = true\r\n      fx.pos = 0.5\r\n      fx.absPos = 2.5\r\n\r\n      fx.reset()\r\n\r\n      expect(fx.situation).toBe(situation)\r\n      expect(fx.situation.loops).toBe(loops)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.reversed).toBe(true) // True because the animation is backward\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.absPos).toBe(0)\r\n    })\r\n  })\r\n\r\n\r\n  describe('finish()', function() {\r\n    it('finish the whole animation by fullfilling every single one', function() {\r\n      fx.animate(500)\r\n      expect(fx.finish().pos).toBe(1)\r\n      expect(fx.situations.length).toBe(0)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n  })\r\n\r\n\r\n  describe('progress()', function() {\r\n    it('returns the current position', function() {\r\n      expect(fx.progress()).toBe(0)\r\n      expect(fx.progress()).toBe(fx.pos)\r\n    })\r\n    it('returns the current position as eased value if fist argument is true', function() {\r\n      var anim = draw.rect(100,100).animate(500,'>').start()\r\n      expect(anim.progress(true)).toBe(0)\r\n\r\n      anim.at(0.25)\r\n      expect(anim.progress(true)).toBeCloseTo(anim.situation.ease(0.25))\r\n    })\r\n  })\r\n\r\n\r\n  describe('after()', function() {\r\n    it('adds a callback which is called when the current animation is finished', function() {\r\n      var called = false\r\n\r\n      fx.start().after(function(situation){\r\n        expect(fx.situation).toBe(situation)\r\n        expect(fx.pos).toBe(1)\r\n        called = true\r\n      })\r\n\r\n      jasmine.clock().tick(500)\r\n      fx.step()\r\n      expect(called).toBe(true)\r\n    })\r\n  })\r\n\r\n\r\n  describe('afterAll()', function() {\r\n    it('adds a callback which is called when all animations are finished', function() {\r\n      var called = false\r\n\r\n      fx.animate(150).animate(125).start().afterAll(function(){\r\n        expect(fx.pos).toBe(1)\r\n        expect(fx.situations.length).toBe(0)\r\n        called = true\r\n      })\r\n\r\n      expect(fx.situations.length).toBe(2)\r\n\r\n      // End of the first animation\r\n      jasmine.clock().tick(500)\r\n      fx.step()\r\n      expect(fx.situations.length).toBe(1)\r\n      expect(called).toBe(false)\r\n\r\n      // End of the second animation\r\n      jasmine.clock().tick(150)\r\n      fx.step()\r\n      expect(fx.situations.length).toBe(0)\r\n      expect(called).toBe(false)\r\n\r\n      // End of the third and last animation\r\n      jasmine.clock().tick(125)\r\n      fx.step()\r\n      expect(fx.situation).toBeNull()\r\n      expect(called).toBe(true)\r\n    })\r\n  })\r\n\r\n\r\n  describe('during()', function() {\r\n    it('adds a callback which is called on every animation step', function() {\r\n      var called = 0\r\n\r\n      fx.start().during(function(pos, morph, eased, situation){\r\n\r\n        expect(fx.situation).toBe(situation)\r\n\r\n        switch(++called) {\r\n          case 1:\r\n            expect(pos).toBeCloseTo(0.25)\r\n            break\r\n\r\n          case 2:\r\n            expect(pos).toBeCloseTo(0.5)\r\n            break\r\n\r\n          case 3:\r\n            expect(pos).toBeCloseTo(0.65)\r\n            break\r\n\r\n          case 4:\r\n            expect(pos).toBe(1)\r\n            break\r\n        }\r\n\r\n        expect(morph(0, 100)).toBeCloseTo(pos*100)\r\n\r\n      })\r\n\r\n      jasmine.clock().tick(125)\r\n      fx.step()\r\n      expect(called).toBe(1)\r\n\r\n      jasmine.clock().tick(125) // 250 ms have passed\r\n      fx.step()\r\n      expect(called).toBe(2)\r\n\r\n      jasmine.clock().tick(75) // 325 ms have passed\r\n      fx.step()\r\n      expect(called).toBe(3)\r\n\r\n      jasmine.clock().tick(175) // 500 ms have passed\r\n      fx.step()\r\n      expect(called).toBe(4)\r\n    })\r\n  })\r\n\r\n\r\n  describe('duringAll()', function() {\r\n    it('adds a callback which is called on every animation step for the whole chain', function() {\r\n\r\n      fx.finish()\r\n      rect.off('.fx')\r\n\r\n      fx.animate(500).start().animate(500)\r\n\r\n      var sit = null\r\n\r\n      var pos1 = false\r\n      var pos2 = false\r\n\r\n      fx.duringAll(function(pos, morph, eased, situation){\r\n\r\n        if(pos1){\r\n          pos1 = false\r\n          sit = situation\r\n          expect(this.fx.pos).toBeCloseTo(0.6)\r\n        }\r\n\r\n        if(pos2){\r\n          pos2 = null\r\n          expect(situation).not.toBe(sit)\r\n          expect(this.fx.pos).toBeCloseTo(0.75)\r\n        }\r\n      })\r\n\r\n      pos1 = true\r\n      jasmine.clock().tick(300)\r\n      fx.step()\r\n\r\n      jasmine.clock().tick(200) // End of the first animation\r\n      fx.step()\r\n\r\n      pos2 = true\r\n      jasmine.clock().tick(375)\r\n      fx.step()\r\n\r\n      if(pos1 || pos2) {\r\n        fail('Not enough situations called')\r\n      }\r\n    })\r\n  })\r\n\r\n\r\n  describe('once()', function() {\r\n    it('adds a callback which is called once at the specified position', function() {\r\n      var called = false\r\n\r\n      fx.start().once(0.5, function(pos, eased){\r\n        called = true\r\n        expect(pos).toBeCloseTo(0.5)\r\n      })\r\n\r\n      jasmine.clock().tick(125)\r\n      fx.step()\r\n      expect(called).toBe(false)\r\n\r\n      jasmine.clock().tick(125) // 250 ms have passed\r\n      fx.step()\r\n      expect(called).toBe(true)\r\n    })\r\n  })\r\n\r\n\r\n  describe('loop()', function() {\r\n    it('should create an eternal loop when no arguments are given', function() {\r\n      var time = 10523, dur = fx.situation.duration\r\n\r\n      fx.loop()\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      fx.start().step()\r\n      jasmine.clock().tick(time)\r\n      fx.step()\r\n\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe( Math.floor(time/dur) )\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n    })\r\n\r\n    it('should create an eternal loop when the first argument is true', function() {\r\n      var time = 850452, dur = fx.situation.duration\r\n\r\n      fx.loop(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      fx.start().step()\r\n      jasmine.clock().tick(time)\r\n      fx.step()\r\n\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe( Math.floor(time/dur) )\r\n      expect(fx.situation.loops).toBe(true)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n    })\r\n\r\n    it('should loop for the specified number of times', function() {\r\n      var time = 0, dur = fx.situation.duration\r\n\r\n      fx.loop(3)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(3)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      fx.start().step()\r\n      jasmine.clock().tick(200)\r\n      time = 200\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(3)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(550)\r\n      time += 550 // time at 750\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(1)\r\n      expect(fx.situation.loops).toBe(3)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(570)\r\n      time += 570 // time at 1320\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(2)\r\n      expect(fx.situation.loops).toBe(3)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(180)\r\n      time += 180 // time at 1500\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.absPos).toBe(3)\r\n    })\r\n\r\n    it('should go from beginning to end and start over again (0->1.0->1.0->1.) by default', function() {\r\n      var time = 0, dur = fx.situation.duration\r\n\r\n      fx.loop(2)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(false)\r\n      expect(fx.situation.reversed).toBe(false)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      fx.start().step()\r\n      jasmine.clock().tick(325)\r\n      time = 325\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(false)\r\n      expect(fx.situation.reversed).toBe(false)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(575)\r\n      time += 575 // time at 900\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(1)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(false)\r\n      expect(fx.situation.reversed).toBe(false)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(200)\r\n      time += 200 // time at 1100\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n      expect(fx.pos).toBe(1)\r\n      expect(fx.absPos).toBe(2)\r\n    })\r\n\r\n    it('should be completely reversed before starting over (0->1->0->1->0->1.) when the reverse flag is passed', function() {\r\n      var time = 0, dur = fx.situation.duration\r\n\r\n      fx.loop(2, true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(true)\r\n      expect(fx.situation.reversed).toBe(false)\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(0)\r\n\r\n      fx.start().step()\r\n      jasmine.clock().tick(325)\r\n      time = 325\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(true)\r\n      expect(fx.situation.reversed).toBe(false)\r\n      expect(fx.pos).toBeCloseTo((time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(575)\r\n      time += 575 // time at 900\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(true)\r\n      expect(fx.situation.loop).toBe(1)\r\n      expect(fx.situation.loops).toBe(2)\r\n      expect(fx.situation.reversing).toBe(true)\r\n      expect(fx.situation.reversed).toBe(true)\r\n      expect(fx.pos).toBeCloseTo(1 - (time/dur) % 1)\r\n      expect(fx.absPos).toBeCloseTo(time/dur)\r\n\r\n      jasmine.clock().tick(200)\r\n      time += 200 // time at 1100\r\n\r\n      fx.step()\r\n      expect(fx.active).toBe(false)\r\n      expect(fx.situation).toBeNull()\r\n      expect(fx.pos).toBe(0)\r\n      expect(fx.absPos).toBe(2)\r\n    })\r\n\r\n    it('should be applied on the last situation', function() {\r\n      fx.loop(5)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(5)\r\n      expect(fx.situation.reversing).toBe(false)\r\n\r\n      fx.animate().loop(3, true)\r\n      expect(fx.situation.loop).toBe(0)\r\n      expect(fx.situation.loops).toBe(5)\r\n      expect(fx.situation.reversing).toBe(false)\r\n\r\n      var c = fx.last()\r\n      expect(c.loop).toBe(0)\r\n      expect(c.loops).toBe(3)\r\n      expect(c.reversing).toBe(true)\r\n    })\r\n\r\n    it('should be possible to call it with false as the first argument', function() {\r\n      fx.situation.loops = true\r\n      fx.loop(false)\r\n      expect(fx.situation.loops).toBe(false)\r\n    })\r\n  })\r\n\r\n\r\n  describe('step()', function() {\r\n    it('should not recalculate the absolute position if the first parameter is true', function() {\r\n      var absPos\r\n\r\n      // We shift start to help us see if the absolute position get recalculated\r\n      // If it get recalculated, the result would be 0.5\r\n      fx.situation.start -= 250\r\n\r\n      absPos = 0.4\r\n      fx.absPos = absPos\r\n      expect(fx.step(true).absPos).toBe(absPos)\r\n\r\n      absPos = 0\r\n      fx.absPos = absPos\r\n      expect(fx.step(true).absPos).toBe(absPos)\r\n\r\n      absPos = -3.7\r\n      fx.absPos = absPos\r\n      expect(fx.step(true).absPos).toBe(absPos)\r\n\r\n      absPos = 1\r\n      fx.absPos = absPos\r\n      expect(fx.step(true).absPos).toBe(absPos)\r\n    })\r\n\r\n    it('should not allow an absolute position to be above the end', function() {\r\n      var absPos, loops\r\n\r\n      // With no loops, absolute position should not go above 1\r\n      absPos = 4.26\r\n      fx.absPos = absPos\r\n      expect(fx.step(true).absPos).toBe(1)\r\n      expect(fx.situation).toBeNull()\r\n\r\n      fx.animate() // Recreate an animation since the other one was ended\r\n\r\n      // With loops, absolute position should not go above loops\r\n      loops = 4\r\n      absPos = 7.42\r\n      fx.absPos = absPos\r\n      expect(fx.loop(loops).step(true).absPos).toBe(loops)\r\n      expect(fx.situation).toBeNull()\r\n    })\r\n\r\n    describe('when converting an absolute position to a position', function() {\r\n      it('should, when the absolute position is below the maximum number of loops, use the integer part of the absolute position to set the loop counter and use its fractional part to set the position', function(){\r\n        var absPos, absPosFrac, absPosInt, loops\r\n\r\n        // Without the reverse flag\r\n        loops = 12\r\n        absPos = 4.52\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.loop(loops).step(true)\r\n        expect(fx.pos).toBe(absPosFrac)\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n\r\n        fx.stop().animate()\r\n\r\n        loops = true\r\n        absPos = 2.57\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.loop(loops).step(true)\r\n        expect(fx.pos).toBe(absPosFrac)\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n\r\n        fx.stop().animate()\r\n\r\n        // With the reverse flag, the position is reversed at each odd loop\r\n        loops = 412\r\n        absPos = 6.14\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(absPosFrac)\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n        expect(fx.situation.reversed).toBe(false)\r\n\r\n        fx.stop().animate()\r\n\r\n        loops = true\r\n        absPos = 5.12\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(1-absPosFrac) // Odd loop, so it is reversed\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n        expect(fx.situation.reversed).toBe(true)\r\n\r\n        fx.stop().animate()\r\n\r\n        // When the animation is set to run backward, it is the opposite, the position is reversed at each even loop\r\n        loops = 14\r\n        absPos = 8.46\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.reverse(true).loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(1-absPosFrac) // Even loop, so it is reversed\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n        expect(fx.situation.reversed).toBe(true)\r\n\r\n        fx.stop().animate()\r\n\r\n        loops = true\r\n        absPos = 3.12\r\n        absPosInt = Math.floor(absPos)\r\n        absPosFrac = absPos - absPosInt\r\n        fx.absPos = absPos\r\n        fx.reverse(true).loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(absPosFrac)\r\n        expect(fx.situation.loop).toBe(absPosInt)\r\n        expect(fx.situation.reversed).toBe(false)\r\n      })\r\n\r\n      it('should, when the absolute position is above or equal to the the maximum number of loops, set the position to its end value and end the animation', function() {\r\n        var absPos, loops\r\n\r\n        // Without the reverse flag, the end value of position is 1\r\n        loops = 6\r\n        absPos = 13.52\r\n        fx.absPos = absPos\r\n        fx.loop(loops).step(true)\r\n        expect(fx.pos).toBe(1)\r\n        expect(fx.situation).toBeNull()\r\n\r\n        fx.animate() // Recreate an animation since the other one was ended\r\n\r\n        loops = false\r\n        absPos = 146.22\r\n        fx.absPos = absPos\r\n        fx.loop(loops).step(true)\r\n        expect(fx.pos).toBe(1)\r\n        expect(fx.situation).toBeNull()\r\n\r\n        fx.animate() // Recreate an animation since the other one was ended\r\n\r\n        // With the reverse flag, the end value of position is 0 when loops is even and 1 when loops is an odd number or false\r\n        loops = 6\r\n        absPos = 6\r\n        fx.absPos = absPos\r\n        fx.loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(0) // Even loops\r\n        expect(fx.situation).toBeNull()\r\n\r\n        fx.animate() // Recreate an animation since the other one was ended\r\n\r\n        loops = false\r\n        absPos = 4.47\r\n        fx.absPos = absPos\r\n        fx.loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(1) // 1 since loops is false\r\n        expect(fx.situation).toBeNull()\r\n\r\n        fx.animate() // Recreate an animation since the other one was ended\r\n\r\n        // When the animation is set to run backward, it is the opposite, the end value of position is 1 when loops is even and 0 when loops is an odd number or false\r\n        loops = 8\r\n        absPos = 12.65\r\n        fx.absPos = absPos\r\n        fx.reverse(true).loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(1) // Even loops\r\n        expect(fx.situation).toBeNull()\r\n\r\n        fx.animate() // Recreate an animation since the other one was ended\r\n\r\n        loops = 11\r\n        absPos = 12.41\r\n        fx.absPos = absPos\r\n        fx.reverse(true).loop(loops, true).step(true)\r\n        expect(fx.pos).toBe(0) // Odd loops\r\n        expect(fx.situation).toBeNull()\r\n      })\r\n\r\n      it('should set the position to its start value when the absolute position is below 0', function() {\r\n        var absPos\r\n\r\n        // When the animation is not set to run backward the start value is 0\r\n        absPos = -2.27\r\n        fx.loop(7)\r\n        fx.situation.loop = 3\r\n        fx.absPos = absPos\r\n        fx.step(true)\r\n        expect(fx.pos).toBe(0)\r\n        expect(fx.absPos).toBe(absPos)\r\n        expect(fx.situation.loop).toBe(0)\r\n\r\n        fx.stop().animate()\r\n\r\n        // When the animation is set to run backward the start value is 1\r\n        absPos = -4.12\r\n        fx.absPos = absPos\r\n        fx.reverse(true).step(true)\r\n        expect(fx.pos).toBe(1)\r\n        expect(fx.absPos).toBe(absPos)\r\n      })\r\n\r\n      it('should, when looping with the reverse flag, toggle reversed only when the difference between the new value of loop counter and its old value is odd', function() {\r\n        // The new value of the loop counter is the integer part of absPos\r\n\r\n        fx.loop(9, true)\r\n        expect(fx.situation.loop).toBe(0)\r\n        expect(fx.pos).toBe(0)\r\n        expect(fx.situation.reversed).toBe(false)\r\n\r\n        fx.absPos = 3\r\n        fx.step(true)\r\n        expect(fx.situation.reversed).toBe(true) // (3-0) is odd\r\n\r\n        fx.absPos = 1\r\n        fx.step(true)\r\n        expect(fx.situation.reversed).toBe(true) // (1-3) is even\r\n\r\n        fx.absPos = 6\r\n        fx.step(true)\r\n        expect(fx.situation.reversed).toBe(false) // (6-1) is odd\r\n\r\n        fx.absPos = 9\r\n        fx.step(true)\r\n        expect(fx.situation).toBeNull()\r\n        expect(fx.pos).toBe(1) // It should end not reversed, which mean the position is expected to be 1\r\n                               // ((9-1)-6) is even, the -1 is because we do not want reversed to be toggled after the last loop\r\n      })\r\n\r\n      it('should not throw an error when stop is called in a during callback', function () {\r\n        fx.move(100,100).start()\r\n        fx.during(function () {this.stop()})\r\n        expect(fx.step.bind(fx)).not.toThrow()\r\n      })\r\n\r\n      it('should not throw an error when finish is called in a during callback', function () {\r\n        fx.move(100,100).start()\r\n        fx.during(function () {this.finish()})\r\n        expect(fx.step.bind(fx)).not.toThrow()\r\n      })\r\n    })\r\n  })\r\n\r\n\r\n  it('animates the x/y-attr', function() {\r\n    var called = false\r\n\r\n    fx.move(200,200).after(function(){\r\n\r\n      expect(rect.x()).toBe(200)\r\n      expect(rect.y()).toBe(200)\r\n      called = true\r\n\r\n    })\r\n\r\n    jasmine.clock().tick(250)\r\n    fx.step()\r\n    expect(rect.x()).toBeGreaterThan(100)\r\n    expect(rect.y()).toBeGreaterThan(100)\r\n\r\n    jasmine.clock().tick(250)\r\n    fx.step()\r\n    expect(called).toBe(true)\r\n  })\r\n\r\n  it('animates matrix', function() {\r\n    var ctm, called = false\r\n\r\n    fx.transform({a:0.8, b:0.4, c:-0.15, d:0.7, e: 90.3, f: 27.07}).after(function(){\r\n\r\n      var ctm = rect.ctm()\r\n      expect(ctm.a).toBeCloseTo(0.8)\r\n      expect(ctm.b).toBeCloseTo(0.4)\r\n      expect(ctm.c).toBeCloseTo(-0.15)\r\n      expect(ctm.d).toBeCloseTo(0.7)\r\n      expect(ctm.e).toBeCloseTo(90.3)\r\n      expect(ctm.f).toBeCloseTo(27.07)\r\n      called = true\r\n\r\n    })\r\n\r\n    jasmine.clock().tick(250)\r\n    fx.step()\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBeLessThan(1)\r\n    expect(ctm.b).toBeGreaterThan(0)\r\n    expect(ctm.c).toBeLessThan(0)\r\n    expect(ctm.d).toBeGreaterThan(0)\r\n    expect(ctm.e).toBeGreaterThan(0)\r\n    expect(ctm.f).toBeGreaterThan(0)\r\n\r\n    jasmine.clock().tick(250)\r\n    fx.step()\r\n    expect(called).toBe(true)\r\n  })\r\n\r\n  it('animate a scale transform using the passed center point when there is already a transform in place', function(){\r\n    var ctm\r\n\r\n    // When no ceter point is passed to the method scale, it use the center of the element as the center point\r\n\r\n    rect.scale(2) // The transform in place\r\n\r\n    fx.scale(0.5)\r\n    jasmine.clock().tick(500) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(0.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(0.5)\r\n    expect(ctm.e).toBe(75)\r\n    expect(ctm.f).toBe(75)\r\n  })\r\n\r\n  it('animate a flip(x) transform', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'x'}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(0.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(1)\r\n    expect(ctm.e).toBe(75)\r\n    expect(ctm.f).toBe(0)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(-1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(1)\r\n    expect(ctm.e).toBe(300)\r\n    expect(ctm.f).toBe(0)\r\n  })\r\n\r\n  it('animate a flip(x) transform with an offset', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'x', offset: 20}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(0.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(1)\r\n    expect(ctm.e).toBe(10)\r\n    expect(ctm.f).toBe(0)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(-1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(1)\r\n    expect(ctm.e).toBe(40)\r\n    expect(ctm.f).toBe(0)\r\n  })\r\n\r\n  it('animate a flip(y) transform', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'y'}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(0.5)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(75)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(-1)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(300)\r\n  })\r\n\r\n  it('animate a flip(y) transform with an offset', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'y', offset: 20}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(0.5)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(10)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(-1)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(40)\r\n  })\r\n\r\n  it('animate a flip() transform', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'both'}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(0.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(0.5)\r\n    expect(ctm.e).toBe(75)\r\n    expect(ctm.f).toBe(75)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(-1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(-1)\r\n    expect(ctm.e).toBe(300)\r\n    expect(ctm.f).toBe(300)\r\n  })\r\n\r\n  it('animate a flip() transform with an offset', function() {\r\n    var ctm\r\n\r\n    fx.transform({flip: 'both', offset: 20}).start()\r\n\r\n    jasmine.clock().tick(125) // Have the animation be 1/4 of the way (not halfway as usual because of a bug in the node method getCTM on Firefox)\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(0.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(0.5)\r\n    expect(ctm.e).toBe(10)\r\n    expect(ctm.f).toBe(10)\r\n\r\n    jasmine.clock().tick(475) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(-1)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(-1)\r\n    expect(ctm.e).toBe(40)\r\n    expect(ctm.f).toBe(40)\r\n  })\r\n\r\n  it('animate relative matrix transform', function(){\r\n    var ctm\r\n\r\n    fx.transform(new SVG.Matrix().scale(2,0,0), true)\r\n\r\n    jasmine.clock().tick(250) // Have the animation be half way\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(1.5)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(1.5)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(0)\r\n\r\n    jasmine.clock().tick(250) // Have the animation reach its end\r\n    fx.step()\r\n\r\n    ctm = rect.ctm()\r\n    expect(ctm.a).toBe(2)\r\n    expect(ctm.b).toBe(0)\r\n    expect(ctm.c).toBe(0)\r\n    expect(ctm.d).toBe(2)\r\n    expect(ctm.e).toBe(0)\r\n    expect(ctm.f).toBe(0)\r\n  })\r\n\r\n  describe('when animating plots', function() {\r\n    it('should allow plot animations to be chained', function() {\r\n      var pathString1 = 'M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80'\r\n        , pathString2 = 'M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80'\r\n        , path = draw.path(pathString1)\r\n        , morph\r\n\r\n      fx = path.animate(1000).plot(pathString2).animate(1000).plot(pathString1)\r\n      morph = new SVG.PathArray(pathString1).morph(pathString2)\r\n\r\n      fx.start()\r\n      expect(path.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(500) // Have the first animation be half way\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(500) // Have the first animation reach its end\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(1))\r\n      morph = new SVG.PathArray(pathString2).morph(pathString1)\r\n      expect(path.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(500) // Have the second animation be half way\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(500) // Have the second animation reach its end\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called on a polyline', function() {\r\n      var startValue = [[0,0], [100,50], [50,100], [150,50], [200,50]]\r\n        , endValue = [[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]]\r\n        , morph = new SVG.PointArray(startValue).morph(endValue)\r\n        , polyline = draw.polyline(startValue)\r\n\r\n      fx = polyline.animate(3000).plot(endValue)\r\n\r\n      fx.start()\r\n      expect(polyline.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(polyline.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(polyline.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called on a polygon', function() {\r\n      var startValue = [[0,0], [100,50], [50,100], [150,50], [200,50]]\r\n        , endValue = [[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]]\r\n        , morph = new SVG.PointArray(startValue).morph(endValue)\r\n        , polygon = draw.polygon(startValue)\r\n\r\n      fx = polygon.animate(3000).plot(endValue)\r\n\r\n      fx.start()\r\n      expect(polygon.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(polygon.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(polygon.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called on a path', function() {\r\n      var startValue = new SVG.PathArray('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')\r\n        , endValue = new SVG.PathArray('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80')\r\n        , morph = new SVG.PathArray(startValue).morph(endValue)\r\n        , path = draw.path(startValue)\r\n\r\n      fx = path.animate(2000).plot(endValue)\r\n\r\n      fx.start()\r\n      expect(path.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(1000) // Have the animation be half way\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(1000) // Have the animation reach its end\r\n      fx.step()\r\n      expect(path.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called on a textpath', function() {\r\n      var startValue = new SVG.PathArray('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')\r\n        , endValue = new SVG.PathArray('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80')\r\n        , morph = new SVG.PathArray(startValue).morph(endValue)\r\n\r\n      var text = draw.text(function(add) {\r\n        add.tspan(\"We go up and down, then we go down, then up again\")\r\n      })\r\n\r\n      fx = text.path(startValue).animate(500).plot(endValue)\r\n\r\n      fx.start()\r\n      expect(text.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      fx.step()\r\n      expect(text.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      fx.step()\r\n      expect(text.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called on a line', function() {\r\n      var startValue = '0,0 100,150'\r\n        , endValue = [[50,30], [120,250]]\r\n        , morph = new SVG.PointArray(startValue).morph(endValue)\r\n        , line = draw.line(startValue)\r\n\r\n      fx = line.animate(3000).plot(endValue)\r\n\r\n      fx.start()\r\n      expect(line.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(line.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(line.array()).toEqual(morph.at(1))\r\n    })\r\n\r\n    it('should allow plot to be called with 4 parameters on a line', function () {\r\n      var startPointArray = new SVG.PointArray('0,0 100,150')\r\n        , endPointArray = new SVG.PointArray([[50,30], [120,250]])\r\n        , morph = new SVG.PointArray(startPointArray).morph(endPointArray)\r\n        , a\r\n\r\n      a = startPointArray.value\r\n      var line = draw.line(a[0][0], a[0][1], a[1][0], a[1][1])\r\n\r\n      a = endPointArray.value\r\n      fx = line.animate(3000).plot(a[0][0], a[0][1], a[1][0], a[1][1])\r\n\r\n      fx.start()\r\n      expect(line.array()).toEqual(morph.at(0))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(line.array()).toEqual(morph.at(0.5))\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(line.array()).toEqual(morph.at(1))\r\n    })\r\n  })\r\n\r\n\r\n  describe('when animating attributes', function() {\r\n    it('should be possible to animate numeric attributes', function () {\r\n      var startValue = 0\r\n        , endValue = 150\r\n        , morph = new SVG.Number(startValue).morph(endValue)\r\n\r\n      var text = draw.text(function(add) {\r\n        add.tspan('We go ')\r\n        add.tspan('up').fill('#f09').dy(-40)\r\n        add.tspan(', then we go down, then up again').dy(40)\r\n      })\r\n\r\n      var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'\r\n\r\n      text.path(path).font({ size: 42.5, family: 'Verdana' })\r\n\r\n      text.textPath().attr('startOffset', startValue)\r\n      fx = text.textPath().animate(1000).attr('startOffset', endValue)\r\n\r\n      fx.start()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(0).value)\r\n\r\n      jasmine.clock().tick(500) // Have the animation be half way\r\n      fx.step()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(0.5).value)\r\n\r\n      jasmine.clock().tick(500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(1).value)\r\n    })\r\n\r\n    it('should be possible to animate non-numeric attributes', function () {\r\n      var startValue = 'butt'\r\n        , endValue = 'round'\r\n        , line = draw.line('0,0 100,150').attr('stroke-linecap', startValue)\r\n\r\n      fx = line.animate(3000).attr('stroke-linecap', endValue)\r\n\r\n      fx.start()\r\n      expect(line.attr('stroke-linecap')).toBe(startValue)\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(line.attr('stroke-linecap')).toBe(startValue)\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(line.attr('stroke-linecap')).toBe(endValue)\r\n    })\r\n\r\n    it('should be possible to animate color attributes by using SVG.Color', function() {\r\n      var startValue = 'rgb(42,251,100)'\r\n        , endValue = 'rgb(10,80,175)'\r\n        , morph = new SVG.Color(startValue).morph(endValue)\r\n\r\n      rect.attr('fill', startValue)\r\n      fx.attr('fill', endValue)\r\n\r\n      fx.start()\r\n      expect(rect.attr('fill')).toBe(morph.at(0).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      fx.step()\r\n      expect(rect.attr('fill')).toBe(morph.at(0.5).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      fx.step()\r\n      expect(rect.attr('fill')).toBe(morph.at(1).toString())\r\n    })\r\n\r\n    it('should be possible to pass percentage strings to numeric attributes', function () {\r\n      var startValue = '0%'\r\n        , endValue = '80%'\r\n        , morph = new SVG.Number(startValue).morph(endValue)\r\n\r\n      var text = draw.text(function(add) {\r\n        add.tspan('We go ')\r\n        add.tspan('up').fill('#f09').dy(-40)\r\n        add.tspan(', then we go down, then up again').dy(40)\r\n      })\r\n\r\n      var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'\r\n\r\n      text.path(path).font({ size: 42.5, family: 'Verdana' })\r\n\r\n      text.textPath().attr('startOffset', startValue)\r\n      fx = text.textPath().animate(1000).attr('startOffset', endValue)\r\n\r\n      fx.start()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(0).toString())\r\n\r\n      jasmine.clock().tick(500) // Have the animation be half way\r\n      fx.step()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(0.5).toString())\r\n\r\n      jasmine.clock().tick(500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(text.textPath().attr('startOffset')).toBe(morph.at(1).toString())\r\n    })\r\n\r\n    it('should allow 0 to be specified without unit', function () {\r\n      // This code snippet come from issue #552\r\n\r\n      var gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at(0, '#33235b')\r\n        s2 = stop.at(0.5, '#E97639')\r\n        s3 = stop.at(1, '#33235b')\r\n      })\r\n\r\n      var r1, r2;\r\n      var fill = draw.pattern('300%', '100%', function(add) {\r\n        r1 = add.rect('150%', '100%').fill(gradient)\r\n        r2 = add.rect('150%', '100%').fill(gradient)\r\n      });\r\n      fill.attr({patternUnits: 'userSpaceOnUse'})\r\n\r\n      r1.attr('x', 0).animate('0.5s').attr('x', '150%')\r\n      r2.attr('x', '-150%').animate('0.5s').attr('x', 0)\r\n\r\n      var text = draw.text('Manifesto').move('50%', '50%').fill(fill)\r\n      text.font({\r\n        size: 70\r\n        , anchor: 'middle'\r\n        , leading: 1\r\n      })\r\n\r\n      r1.fx.start()\r\n      r2.fx.start()\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      r1.fx.step()\r\n      r2.fx.step()\r\n      expect(r1.attr('x')).toBe('75%')\r\n      expect(r2.attr('x')).toBe('-75%')\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      r1.fx.step()\r\n      r2.fx.step()\r\n      expect(r1.attr('x')).toBe('150%')\r\n      expect(r2.attr('x')).toBe('0%')\r\n    })\r\n  })\r\n\r\n\r\n  describe('when animating styles', function() {\r\n    it('should be possible to animate numeric styles', function () {\r\n      var startValue = 0\r\n        , endValue = 5\r\n        , morph = new SVG.Number(startValue).morph(endValue)\r\n\r\n      rect.style('stroke-width', startValue)\r\n      fx.style('stroke-width', endValue)\r\n\r\n      fx.start()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(0).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      fx.step()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(0.5).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      fx.step()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(1).toString())\r\n    })\r\n\r\n    it('should be possible to animate non-numeric styles', function () {\r\n      var startValue = 'butt'\r\n        , endValue = 'round'\r\n        , line = draw.line('0,0 100,150').style('stroke-linecap', startValue)\r\n\r\n      fx = line.animate(3000).style('stroke-linecap', endValue)\r\n\r\n      fx.start()\r\n      expect(line.style('stroke-linecap')).toBe(startValue)\r\n\r\n      jasmine.clock().tick(1500) // Have the animation be half way\r\n      fx.step()\r\n      expect(line.style('stroke-linecap')).toBe(startValue)\r\n\r\n      jasmine.clock().tick(1500) // Have the animation reach its end\r\n      fx.step()\r\n      expect(line.style('stroke-linecap')).toBe(endValue)\r\n    })\r\n\r\n    it('should be possible to animate color styles by using SVG.Color', function() {\r\n      var startValue = '#81DE01'\r\n        , endValue = '#B1835D'\r\n        , morph = new SVG.Color(startValue).morph(endValue)\r\n\r\n      rect.style('fill', startValue)\r\n      fx.style('fill', endValue)\r\n\r\n\r\n      fx.start()\r\n      // When setting a style color, it get saved as  a rgb() string even if it was passed as an hex code\r\n      // The style rgb string has spaces while the one returned by SVG.Color do not as show bellow\r\n      // CSS: rgb(255, 255, 255)                    SVG.Color: rgb(255,255,255)\r\n      // The space in the style rbg string are removed so they can be equal\r\n      expect(rect.style('fill').replace(/\\s+/g, '')).toBe(morph.at(0).toRgb())\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      fx.step()\r\n      expect(rect.style('fill').replace(/ /g, '')).toBe(morph.at(0.5).toRgb())\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      fx.step()\r\n      expect(rect.style('fill').replace(/ /g, '')).toBe(morph.at(1).toRgb())\r\n    })\r\n\r\n    it('should be possible to pass percentage strings to numeric styles', function () {\r\n      var startValue = '0%'\r\n        , endValue = '5%'\r\n        , morph = new SVG.Number(startValue).morph(endValue)\r\n\r\n      rect.style('stroke-width', startValue)\r\n      fx.style('stroke-width', endValue)\r\n\r\n      fx.start()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(0).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      fx.step()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(0.5).toString())\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      fx.step()\r\n      expect(rect.style('stroke-width')).toBe(morph.at(1).toString())\r\n    })\r\n\r\n    it('should allow 0 to be specified without a unit', function () {\r\n      var r1 = draw.rect(100,100).move(200,200)\r\n        , r2 = draw.rect(100,100).move(400,400)\r\n\r\n      r1.style('stroke-width', '100%').animate(500).style('stroke-width', 0)\r\n      r2.style('stroke-width', 0).animate(500).style('stroke-width', '100%')\r\n\r\n      r1.fx.start()\r\n      r2.fx.start()\r\n      expect(r1.style('stroke-width')).toBe('100%')\r\n      expect(r2.style('stroke-width')).toBe('0%')\r\n\r\n      jasmine.clock().tick(250) // Have the animation be half way\r\n      r1.fx.step()\r\n      r2.fx.step()\r\n      expect(r1.style('stroke-width')).toBe('50%')\r\n      expect(r2.style('stroke-width')).toBe('50%')\r\n\r\n      jasmine.clock().tick(250) // Have the animation reach its end\r\n      r1.fx.step()\r\n      r2.fx.step()\r\n      expect(r1.style('stroke-width')).toBe('0%')\r\n      expect(r2.style('stroke-width')).toBe('100%')\r\n    })\r\n  })\r\n\r\n\r\n  describe('add()', function() {\r\n    it('adds to animations obj by default', function() {\r\n      fx.add('x', new SVG.Number(20))\r\n      expect(fx.situation.animations.x.value).toBe(20)\r\n    })\r\n\r\n    it('adds to specified obj', function() {\r\n      fx.add('x', new SVG.Number(20), 'animations')\r\n      fx.add('x', new SVG.Number(20), 'attrs')\r\n      fx.add('x', new SVG.Number(20), 'styles')\r\n      expect(fx.situation.animations.x.value).toBe(20)\r\n      expect(fx.situation.attrs.x.value).toBe(20)\r\n      expect(fx.situation.styles.x.value).toBe(20)\r\n    })\r\n  })\r\n\r\n  describe('attr()', function() {\r\n    it('should allow an object to be passed', function() {\r\n      spyOn(fx, 'attr').and.callThrough()\r\n      fx.attr({\r\n        x: 20,\r\n        y: 20\r\n      })\r\n\r\n      expect(fx.attr).toHaveBeenCalledWith('x', 20)\r\n      expect(fx.attr).toHaveBeenCalledWith('y', 20)\r\n    })\r\n\r\n    it('should call add() with attrs as method', function() {\r\n      spyOn(fx, 'add')\r\n      fx.attr('x', 20)\r\n      expect(fx.add).toHaveBeenCalledWith('x', 20, 'attrs')\r\n    })\r\n  })\r\n\r\n  describe('style()', function() {\r\n    it('should allow an object to be passed', function() {\r\n      spyOn(fx, 'style').and.callThrough()\r\n      fx.style({\r\n        x: 20,\r\n        y: 20\r\n      })\r\n\r\n      expect(fx.style).toHaveBeenCalledWith('x', 20)\r\n      expect(fx.style).toHaveBeenCalledWith('y', 20)\r\n    })\r\n\r\n    it('should call add() with styles as method', function() {\r\n      spyOn(fx, 'add')\r\n      fx.style('x', 20)\r\n      expect(fx.add).toHaveBeenCalledWith('x', 20, 'styles')\r\n    })\r\n  })\r\n\r\n  describe('x() / y()', function() {\r\n    it('should add an entry to the animations obj', function() {\r\n      spyOn(fx, 'add')\r\n      fx.x(20)\r\n      fx.y(20)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('x', jasmine.objectContaining({value:20}))\r\n      expect(fx.add).toHaveBeenCalledWith('y', jasmine.objectContaining({value:20}))\r\n    })\r\n\r\n    it('allows relative move with relative flag set', function() {\r\n      spyOn(fx, 'add')\r\n      fx.x(20, true)\r\n      fx.y(20, true)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('x', jasmine.objectContaining({value:20, relative:true }))\r\n      expect(fx.add).toHaveBeenCalledWith('y', jasmine.objectContaining({value:20, relative:true }))\r\n    })\r\n\r\n    it('redirects to transform when target is a group', function() {\r\n      var group = draw.group()\r\n        , fx = group.animate(500)\r\n\r\n      spyOn(fx, 'transform')\r\n\r\n      fx.x(20)\r\n      fx.y(20)\r\n\r\n      expect(fx.transform).toHaveBeenCalledWith({x: 20}, undefined)\r\n      expect(fx.transform).toHaveBeenCalledWith({y: 20}, undefined)\r\n    })\r\n\r\n    it('redirects to transform when target is a group with relative flag set', function() {\r\n      var group = draw.group()\r\n        , fx = group.animate(500)\r\n\r\n      spyOn(fx, 'transform')\r\n\r\n      fx.x(20, true)\r\n      fx.y(20, true)\r\n\r\n      expect(fx.transform).toHaveBeenCalledWith({x: 20}, true)\r\n      expect(fx.transform).toHaveBeenCalledWith({y: 20}, true)\r\n    })\r\n  })\r\n\r\n  describe('cx() / cy()', function() {\r\n    it('should call add with method and argument', function() {\r\n      spyOn(fx, 'add')\r\n      fx.cx(20)\r\n      fx.cy(20)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('cx', jasmine.objectContaining({value:20}))\r\n      expect(fx.add).toHaveBeenCalledWith('cy', jasmine.objectContaining({value:20}))\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('should redirect call to x() and y()', function() {\r\n      spyOn(fx, 'x').and.callThrough()\r\n      spyOn(fx, 'y').and.callThrough()\r\n      fx.move(20, 20)\r\n\r\n      expect(fx.x).toHaveBeenCalledWith(20)\r\n      expect(fx.y).toHaveBeenCalledWith(20)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('should redirect call to cx() and cy()', function() {\r\n      spyOn(fx, 'cx').and.callThrough()\r\n      spyOn(fx, 'cy').and.callThrough()\r\n      fx.center(20, 20)\r\n\r\n      expect(fx.cx).toHaveBeenCalledWith(20)\r\n      expect(fx.cy).toHaveBeenCalledWith(20)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should set font-size with attr() when called on a text', function() {\r\n      var text = draw.text('Hello World')\r\n        , fx = text.animate(500)\r\n\r\n      spyOn(fx, 'attr')\r\n      fx.size(20)\r\n      expect(fx.attr).toHaveBeenCalledWith('font-size', 20)\r\n    })\r\n\r\n    it('should set width and height with add()', function() {\r\n      spyOn(fx, 'add').and.callThrough()\r\n      fx.size(20, 20)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('width', jasmine.objectContaining({value:20}))\r\n      expect(fx.add).toHaveBeenCalledWith('height', jasmine.objectContaining({value:20}))\r\n    })\r\n\r\n    it('should calculate proportional size when only height or width is given', function() {\r\n      spyOn(fx, 'add').and.callThrough()\r\n      fx.size(40, null)\r\n      fx.size(null, 60)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('width', jasmine.objectContaining({value:40}))\r\n      expect(fx.add).toHaveBeenCalledWith('height', jasmine.objectContaining({value:40}))\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('width', jasmine.objectContaining({value:60}))\r\n      expect(fx.add).toHaveBeenCalledWith('height', jasmine.objectContaining({value:60}))\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('should call add with plot as method', function() {\r\n      var polyline = draw.polyline('10 10 20 20 30 10 50 20')\r\n        , fx = polyline.animate(500)\r\n\r\n      spyOn(fx, 'add')\r\n      fx.plot('5 5 30 29 40 19 12 30')\r\n      expect(fx.add).toHaveBeenCalledWith('plot', '5 5 30 29 40 19 12 30')\r\n    })\r\n\r\n    it('also accept parameter list', function() {\r\n      var line = draw.line('10 10 20 20')\r\n        , fx = line.animate(500)\r\n\r\n      spyOn(fx, 'add')\r\n      fx.plot(5, 5, 10, 10)\r\n      expect(fx.add).toHaveBeenCalledWith('plot', [5, 5, 10, 10])\r\n    })\r\n  })\r\n\r\n  describe('leading()', function() {\r\n    it('should call add with method and argument', function() {\r\n      var text = draw.text('Hello World')\r\n        , fx = text.animate(500)\r\n      spyOn(fx, 'add')\r\n      fx.leading(3)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('leading', jasmine.objectContaining({value:3}))\r\n    })\r\n\r\n    it('does nothiing when not called on text', function() {\r\n      spyOn(fx, 'add')\r\n      fx.leading(3)\r\n      expect(fx.add).not.toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('viewbox()', function() {\r\n    it('should call add with method and argument', function() {\r\n      var nested = draw.nested()\r\n        , fx = nested.animate(500)\r\n      spyOn(fx, 'add')\r\n      fx.viewbox(1,2,3,4)\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('viewbox', jasmine.objectContaining({x:1, y:2, width:3, height:4}))\r\n    })\r\n\r\n    it('does nothing when not called on SVG.Container', function() {\r\n      spyOn(fx, 'add')\r\n      fx.viewbox(1,2,3,4)\r\n      expect(fx.add).not.toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('update()', function() {\r\n    it('should convert call with 3 arguments to call with obj', function() {\r\n      var stop = new SVG.Stop()\r\n        , fx = stop.animate()\r\n      spyOn(fx, 'update').and.callThrough()\r\n      fx.update(1,'#ccc',0.5)\r\n\r\n      expect(fx.update).toHaveBeenCalledWith({offset: 1, color: '#ccc', opacity: 0.5})\r\n    })\r\n\r\n    it('calls add with method argument and attrs as type', function() {\r\n      var stop = new SVG.Stop()\r\n        , fx = stop.animate()\r\n      spyOn(fx, 'add')\r\n      fx.update({offset: 1, color: '#ccc', opacity: 0.5})\r\n\r\n      expect(fx.add).toHaveBeenCalledWith('stop-opacity', 0.5, 'attrs')\r\n      expect(fx.add).toHaveBeenCalledWith('stop-color', '#ccc', 'attrs')\r\n      expect(fx.add).toHaveBeenCalledWith('offset', 1, 'attrs')\r\n    })\r\n\r\n    it('does nothing when not called on SVG.Stop', function() {\r\n      spyOn(fx, 'add')\r\n      fx.update({offset: 1, color: '#ccc', opacity: 0.5})\r\n      expect(fx.add).not.toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('transform()', function() {\r\n    it('returns itself when no valid transformation was found', function() {\r\n      expect(fx.transform({})).toBe(fx)\r\n    })\r\n    it('gets the current transforms', function() {\r\n      expect(fx.transform()).toEqual(new SVG.Matrix(rect).extract())\r\n    })\r\n    it('gets a certain transformation if used with an argument', function() {\r\n      expect(fx.transform('x')).toEqual(0)\r\n    })\r\n    it('adds an entry to transforms when matrix given', function() {\r\n      var matrix = new SVG.Matrix(1,2,3,4,5,6)\r\n      fx.transform(matrix)\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(matrix))\r\n    })\r\n    it('sets relative flag when given', function() {\r\n      var matrix = new SVG.Matrix(1,2,3,4,5,6)\r\n      fx.transform(matrix, true)\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(matrix))\r\n      expect(fx.situation.transforms[0].relative).toBe(true)\r\n    })\r\n    it('adds an entry to transforms when rotation given', function() {\r\n      fx.transform({rotation: 30, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Rotate(30, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when scale given', function() {\r\n      fx.transform({scale: 2, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Scale(2, 2, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when scaleX given', function() {\r\n      fx.transform({scaleX: 2, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Scale(2, 1, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when scaleY given', function() {\r\n      fx.transform({scaleY: 2, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Scale(1, 2, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when skewX given', function() {\r\n      fx.transform({skewX: 2, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Skew(2, 0, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when skewY given', function() {\r\n      fx.transform({skewY: 2, cx:0, cy:0})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Skew(0, 2, 0, 0)))\r\n    })\r\n    it('adds an entry to transforms when flip x given', function() {\r\n      fx.transform({flip: 'x'})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining((new SVG.Matrix()).flip('x', 150)))\r\n    })\r\n    it('adds an entry to transforms when flip x with offset given', function() {\r\n      fx.transform({flip: 'x', offset: 100})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining((new SVG.Matrix()).flip('x', 100)))\r\n    })\r\n    it('adds an entry to transforms when flip y given', function() {\r\n      fx.transform({flip: 'y'})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining((new SVG.Matrix()).flip('y', 150)))\r\n    })\r\n    it('adds an entry to transforms when x given', function() {\r\n      fx.transform({x:20})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Translate(20, undefined)))\r\n    })\r\n    it('adds an entry to transforms when y given', function() {\r\n      fx.transform({y:20})\r\n      expect(fx.situation.transforms[0]).toEqual(jasmine.objectContaining(new SVG.Translate(undefined, 20)))\r\n    })\r\n  })\r\n\r\n  /* shortcuts for animation */\r\n  describe('animate()', function() {\r\n    it('creates a new fx instance on the element', function() {\r\n      var rect = draw.rect(100,100)\r\n      rect.animate(100)\r\n      expect(rect.fx instanceof SVG.FX).toBeTruthy()\r\n    })\r\n\r\n    it('redirects the call to fx.animate()', function() {\r\n      spyOn(fx, 'animate')\r\n      rect.animate()\r\n      expect(fx.animate).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('delay()', function() {\r\n    it('creates a new fx instance on the element', function() {\r\n      var rect = draw.rect(100,100)\r\n      rect.delay(100)\r\n      expect(rect.fx instanceof SVG.FX).toBeTruthy()\r\n    })\r\n\r\n    it('redirects the call to fx.delay()', function() {\r\n      spyOn(fx, 'delay')\r\n      rect.delay(5)\r\n      expect(fx.delay).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('stop()', function() {\r\n    it('redirects the call to fx.stop()', function() {\r\n      spyOn(fx, 'stop')\r\n      rect.stop()\r\n      expect(fx.stop).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('finish()', function() {\r\n    it('redirects the call to fx.finish()', function() {\r\n      spyOn(fx, 'finish')\r\n      rect.finish()\r\n      expect(fx.finish).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('pause()', function() {\r\n    it('redirects the call to fx.pause()', function() {\r\n      spyOn(fx, 'pause')\r\n      rect.pause()\r\n      expect(fx.pause).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('play()', function() {\r\n    it('redirects the call to fx.play()', function() {\r\n      spyOn(fx, 'play')\r\n      rect.play()\r\n      expect(fx.play).toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('speed()', function() {\r\n    it('redirects the call to fx.speed() as getter', function() {\r\n      spyOn(fx, 'speed')\r\n      rect.speed()\r\n      expect(fx.speed).toHaveBeenCalled()\r\n    })\r\n\r\n    it('redirects the call to fx.speed() as setter', function() {\r\n      spyOn(fx, 'speed').and.callThrough()\r\n      expect(rect.speed(5)).toBe(rect)\r\n      expect(fx.speed).toHaveBeenCalled()\r\n    })\r\n  })\r\n})\r\n\r\ndescribe('SVG.MorphObj', function() {\r\n  it('accepts color strings and converts them to SVG.Color', function() {\r\n    var obj = new SVG.MorphObj('#000', '#fff')\r\n    expect(obj instanceof SVG.Color).toBeTruthy()\r\n\r\n    obj = new SVG.MorphObj('rgb(0,0,0)', 'rgb(255,255,255)')\r\n    expect(obj instanceof SVG.Color).toBeTruthy()\r\n  })\r\n\r\n  it('accepts numbers and converts them to SVG.Number', function() {\r\n    var obj = new SVG.MorphObj('0', '10')\r\n    expect(obj instanceof SVG.Number).toBeTruthy()\r\n\r\n    var obj = new SVG.MorphObj(0, 10)\r\n    expect(obj instanceof SVG.Number).toBeTruthy()\r\n  })\r\n\r\n  it('accepts any other values', function() {\r\n    var obj = new SVG.MorphObj('Hello', 'World')\r\n\r\n    expect(obj.value).toBe('Hello')\r\n    expect(obj.destination).toBe('World')\r\n  })\r\n\r\n  it('morphes unmorphable objects with plain morphing', function() {\r\n    var obj = new SVG.MorphObj('Hello', 'World')\r\n\r\n    expect(obj.at(0,0)).toBe('Hello')\r\n    expect(obj.at(0.5,0.5)).toBe('Hello')\r\n    expect(obj.at(1,1)).toBe('World')\r\n  })\r\n\r\n  it('converts to its value when casted', function() {\r\n    var obj = new SVG.MorphObj('Hello', 'World')\r\n    expect(obj.valueOf()).toBe('Hello')\r\n    expect(obj + 'World').toBe('HelloWorld')\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/gradient.js":"describe('Gradient', function() {\r\n  var rect, gradient\r\n\r\n  beforeEach(function() {\r\n    rect = draw.rect(100,100)\r\n    gradient = draw.gradient('linear', function(stop) {\r\n      stop.at({ offset: 0, color: '#333', opacity: 1 })\r\n      stop.at({ offset: 1, color: '#fff', opacity: 1 })\r\n    })\r\n    radial = draw.gradient('radial', function(stop) {\r\n      stop.at({ offset: 0, color: '#333', opacity: 1 })\r\n      stop.at({ offset: 1, color: '#fff', opacity: 1 })\r\n    })\r\n  })\r\n\r\n  afterEach(function() {\r\n    rect.remove()\r\n    gradient.remove()\r\n  })\r\n\r\n  it('is an instance of SVG.Gradient', function() {\r\n    expect(gradient instanceof SVG.Gradient).toBe(true)\r\n  })\r\n\r\n  it('allows creation of a new gradient without block', function() {\r\n    gradient = draw.gradient('linear')\r\n    expect(gradient.children().length).toBe(0)\r\n  })\r\n\r\n  describe('fill()', function() {\r\n    it('returns the id of the gradient wrapped in url()', function() {\r\n      expect(gradient.fill()).toBe('url(#' + gradient.attr('id') + ')')\r\n    })\r\n  })\r\n  \r\n  describe('from()', function() {\r\n    it('sets fx and fy attribute for radial gradients', function() {\r\n      radial.from(7, 10)\r\n      expect(radial.attr('fx')).toBe(7)\r\n      expect(radial.attr('fy')).toBe(10)\r\n    })\r\n    it('sets x1 and y1 attribute for linear gradients', function() {\r\n      gradient.from(7, 10)\r\n      expect(gradient.attr('x1')).toBe(7)\r\n      expect(gradient.attr('y1')).toBe(10)\r\n    })\r\n  })\r\n  \r\n  describe('to()', function() {\r\n    it('sets cx and cy attribute for radial gradients', function() {\r\n      radial.to(75, 105)\r\n      expect(radial.attr('cx')).toBe(75)\r\n      expect(radial.attr('cy')).toBe(105)\r\n    })\r\n    it('sets x2 and y2 attribute for linear gradients', function() {\r\n      gradient.to(75, 105)\r\n      expect(gradient.attr('x2')).toBe(75)\r\n      expect(gradient.attr('y2')).toBe(105)\r\n    })\r\n  })\r\n\r\n  describe('attr()', function() {\r\n    it('will catch transform attribues and convert them to gradientTransform', function() {\r\n      expect(gradient.translate(100,100).attr('gradientTransform')).toBe('matrix(1,0,0,1,100,100)')\r\n    })\r\n  })\r\n\r\n  describe('toString()', function() {\r\n    it('returns the id of the gradient wrapped in url()', function() {\r\n      expect(gradient + '').toBe('url(#' + gradient.attr('id') + ')')\r\n    })\r\n    it('is called when instance is passed as an attribute value', function() {\r\n      rect.attr('fill', gradient)\r\n      expect(rect.attr('fill')).toBe('url(#' + gradient.attr('id') + ')')\r\n    })\r\n  })\r\n\r\n  describe('input values', function() {\r\n    var s1, s2\r\n\r\n    it('accepts floats', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at({ offset: 0.12, color: '#333', opacity: 1 })\r\n        s2 = stop.at({ offset: 0.93, color: '#fff', opacity: 1 })\r\n      })\r\n      expect(s1.attr('offset')).toBe(0.12)\r\n      expect(s2.attr('offset')).toBe(0.93)\r\n    })\r\n    it('accepts string floats', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at({ offset: '0.13', color: '#333', opacity: 1 })\r\n        s2 = stop.at({ offset: '0.92', color: '#fff', opacity: 1 })\r\n      })\r\n      expect(s1.attr('offset')).toBe(0.13)\r\n      expect(s2.attr('offset')).toBe(0.92)\r\n    })\r\n    it('accept percentages', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at({ offset: '14%', color: '#333', opacity: 1 })\r\n        s2 = stop.at({ offset: '91%', color: '#fff', opacity: 1 })\r\n      })\r\n      expect(s1.attr('offset')).toBe('14%')\r\n      expect(s2.attr('offset')).toBe('91%')\r\n    })\r\n  })\r\n\r\n  describe('update()', function() {\r\n\r\n    it('removes all existing children first', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at({ offset: 0.12, color: '#333', opacity: 1 })\r\n        s2 = stop.at({ offset: 0.93, color: '#fff', opacity: 1 })\r\n      })\r\n      expect(gradient.children().length).toBe(2)\r\n      gradient.update(function(stop) {\r\n        s1 = stop.at({ offset: 0.33, color: '#666', opacity: 1 })\r\n        s2 = stop.at({ offset: 1, color: '#000', opacity: 1 })\r\n      })\r\n      expect(gradient.children().length).toBe(2)\r\n    })\r\n\r\n    it('accepts multiple aruments on fixed positions', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at(0.11, '#333')\r\n        s2 = stop.at(0.94, '#fff', 0.5)\r\n      })\r\n      expect(gradient.children().length).toBe(2)\r\n      expect(s1.attr('offset')).toBe(0.11)\r\n      expect(s1.attr('stop-color')).toBe('#333333')\r\n      expect(s2.attr('offset')).toBe(0.94)\r\n      expect(s2.attr('stop-color')).toBe('#ffffff')\r\n      expect(s2.attr('stop-opacity')).toBe(0.5)\r\n    })\r\n\r\n  })\r\n\r\n  describe('get()', function() {\r\n\r\n    it('returns the stop at a given index', function() {\r\n      gradient = draw.gradient('linear', function(stop) {\r\n        s1 = stop.at({ offset: 0.12, color: '#333', opacity: 1 })\r\n        s2 = stop.at({ offset: 0.93, color: '#fff', opacity: 1 })\r\n      })\r\n      expect(gradient.get(0)).toBe(s1)\r\n      expect(gradient.get(1)).toBe(s2)\r\n      expect(gradient.get(2)).toBeNull()\r\n    })\r\n\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/group.js":"describe('Group', function() {\r\n  var group\r\n\r\n  beforeEach(function() {\r\n    group = draw.group().move(50, 50)\r\n    group.rect(100,100)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(group.x()).toBe(50)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      group.x(123)\r\n      var box = group.gbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n    it('sets the value of x correctly when called multiple times', function() {\r\n      group.x(10).x(100).x(13)\r\n      var box = group.gbox()\r\n      expect(box.x).toBe(13)\r\n    })\r\n    it('sets the value of x correctly when the first argument is a string number', function(){\r\n      group.x('123')\r\n      var box = group.gbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(group.y()).toBe(50)\r\n    })\r\n    it('sets the value of y with the first argument', function() {\r\n      group.y(345)\r\n      var box = group.gbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n    it('sets the value of y correctly when called multiple times', function() {\r\n      group.y(1).y(10).y(15)\r\n      var box = group.gbox()\r\n      expect(box.y).toBe(15)\r\n    })\r\n    it('sets the value of y correctly when the first argument is a string number', function(){\r\n      group.y('124')\r\n      var box = group.gbox()\r\n      expect(box.y).toBe(124)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(group.cx()).toBe(100)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      group.cx(123)\r\n      var box = group.gbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(group.cy()).toBe(100)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      group.cy(345)\r\n      var box = group.gbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      group.move(123,456)\r\n      expect(group.node.getAttribute('transform')).toBe('matrix(1,0,0,1,123,456)')\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      group.center(321,567)\r\n      var box = group.gbox()\r\n      expect(box.cx).toBe(321)\r\n      expect(box.cy).toBe(567)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      group.move(50,60)\r\n      group.dx(100)\r\n      expect(group.node.getAttribute('transform')).toBe('matrix(1,0,0,1,150,60)')\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      group.move(50,60)\r\n      group.dy(120)\r\n      expect(group.node.getAttribute('transform')).toBe('matrix(1,0,0,1,50,180)')\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      group.move(50, 60)\r\n      group.dmove(80, 25)\r\n      expect(group.node.getAttribute('transform')).toBe('matrix(1,0,0,1,130,85)')\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/helper.js":"// create canavs\r\n//var drawing, window = window, document = document, SVG = SVG\r\n\r\nparserInDoc = false\r\n\r\nif(typeof exports === 'object'){\r\n  window = require('svgdom')\r\n  SVG = require('../../dist/svg.js')\r\n  document = window.document\r\n  drawing = document.documentElement\r\n  imageUrl = 'spec/fixtures/pixel.png'\r\n  parserInDoc = true\r\n  \r\n  function tag(name, attrs, children) {\r\n    var el = document.createElement(name)\r\n    for(var i in attrs){\r\n      el.setAttribute(i, attrs[i])\r\n    }\r\n    \r\n    for(var i in children){\r\n      if(typeof children[i] == 'string')\r\n        children[i] = document.createTextNode(children[i])\r\n        \r\n      el.appendChild(children[i])\r\n    }\r\n    \r\n    return el\r\n  }\r\n  \r\n  // create fixtures in svgdom\r\n  var el = tag('svg', {\r\n    height:0,\r\n    width:0,\r\n    id:'inlineSVG'\r\n  },[\r\n    tag('defs', {}, [\r\n      tag('linearGradient', {}, [\r\n        tag('stop', {offset: '5%',  'stop-color': 'green'}),\r\n        tag('stop', {offset: '95%', 'stop-color': 'gold'}),\r\n      ]),\r\n      tag('radialGradient', {}, [\r\n        tag('stop', {offset: '5%',  'stop-color': 'green'}),\r\n        tag('stop', {offset: '95%', 'stop-color': 'gold'}),\r\n      ])\r\n    ]),\r\n    tag('desc', {}, ['Some description']),\r\n    tag('path', {\r\n      id: 'lineAB',\r\n      d: 'M 100 350 l 150 -300',\r\n      stroke: 'red',\r\n      'stroke-width': '3',\r\n      fill: 'none'\r\n    }),\r\n    tag('path', {\r\n      id: 'lineBC',\r\n      d: 'M 250 50 l 150 300',\r\n      stroke: 'red',\r\n      'stroke-width': '3',\r\n      fill: 'none'\r\n    }),\r\n    tag('path', {\r\n      d: 'M 175 200 l 150 0',\r\n      stroke: 'green',\r\n      'stroke-width': '3',\r\n      fill: 'none'\r\n    }),\r\n    tag('path', {\r\n      d: 'M 100 350 q 150 -300 300 0',\r\n      stroke: 'blue',\r\n      'stroke-width': '5',\r\n      fill: 'none'\r\n    }),\r\n    tag('g', {\r\n      stroke: 'black',\r\n      'stroke-width': '2',\r\n      fill: 'black',\r\n      id: 'pointGroup'\r\n    },[\r\n      tag('circle', {\r\n        id: 'pointA',\r\n        cx: '100',\r\n        cy: '350',\r\n        r: '3',\r\n      }),\r\n      tag('circle', {\r\n        id: 'pointB',\r\n        cx: '250',\r\n        cy: '50',\r\n        r: '50',\r\n      }),\r\n      tag('circle', {\r\n        id: 'pointC',\r\n        cx: '400',\r\n        cy: '350',\r\n        r: '50',\r\n      })\r\n    ]),\r\n    tag('g', {\r\n      'font-size': '30',\r\n      font: 'sans-serif',\r\n      fill: 'black',\r\n      stroke: 'none',\r\n      'text-anchor': 'middle',\r\n      id: 'labelGroup'\r\n    },[\r\n      tag('text', {\r\n        x: '100',\r\n        y: '350',\r\n        dy: '-30',\r\n      }, ['A']),\r\n      tag('text', {\r\n        x: '250',\r\n        y: '50',\r\n        dy: '-10',\r\n      }, ['B']),\r\n      tag('text', {\r\n        x: '400',\r\n        y: '350',\r\n        dx: '30',\r\n      }, ['C'])\r\n    ]),\r\n    tag('polygon', {points: '200,10 250,190 160,210'}),\r\n    tag('polyline', {points: '20,20 40,25 60,40 80,120 120,140 200,180'})\r\n  ])\r\n  \r\n  document.appendChild(el)\r\n  \r\n}else{\r\n  drawing = document.createElement('div')\r\n  document.getElementsByTagName('body')[0].appendChild(drawing)\r\n  imageUrl = 'fixtures/pixel.png'\r\n}\r\n\r\nparserInDoc |= 0\r\ndrawing.id = 'drawing'\r\ndraw = SVG(drawing).size(100,100)\r\n\r\nparser = parserInDoc ? [SVG.parser.draw.instance] : []\r\n\r\n// raw path data\r\nsvgPath = 'M88.006,61.994c3.203,0,6.216-1.248,8.481-3.514C98.752,56.215,100,53.203,100,50c0-3.204-1.248-6.216-3.513-8.481 c-2.266-2.265-5.278-3.513-8.481-3.513c-2.687,0-5.237,0.877-7.327,2.496h-7.746l5.479-5.479 c5.891-0.757,10.457-5.803,10.457-11.896c0-6.614-5.381-11.995-11.994-11.995c-6.093,0-11.14,4.567-11.896,10.457l-5.479,5.479 v-7.747c1.618-2.089,2.495-4.641,2.495-7.327c0-3.204-1.247-6.216-3.513-8.481C56.216,1.248,53.204,0,50,0 c-3.204,0-6.216,1.248-8.481,3.513c-2.265,2.265-3.513,5.277-3.513,8.481c0,2.686,0.877,5.237,2.495,7.327v7.747l-5.479-5.479 c-0.757-5.89-5.803-10.457-11.896-10.457c-6.614,0-11.995,5.381-11.995,11.995c0,6.093,4.567,11.139,10.458,11.896l5.479,5.479 h-7.747c-2.089-1.619-4.641-2.496-7.327-2.496c-3.204,0-6.216,1.248-8.481,3.513C1.248,43.784,0,46.796,0,50 c0,3.203,1.248,6.216,3.513,8.48c2.265,2.266,5.277,3.514,8.481,3.514c2.686,0,5.237-0.877,7.327-2.496h7.747l-5.479,5.479 c-5.891,0.757-10.458,5.804-10.458,11.896c0,6.614,5.381,11.994,11.995,11.994c6.093,0,11.139-4.566,11.896-10.457l5.479-5.479 v7.749c-3.63,4.7-3.291,11.497,1.018,15.806C43.784,98.752,46.796,100,50,100c3.204,0,6.216-1.248,8.481-3.514 c4.309-4.309,4.647-11.105,1.018-15.806v-7.749l5.479,5.479c0.757,5.891,5.804,10.457,11.896,10.457 c6.613,0,11.994-5.38,11.994-11.994c0-6.093-4.566-11.14-10.457-11.896l-5.479-5.479h7.746 C82.769,61.117,85.319,61.994,88.006,61.994z M76.874,68.354c4.705,0,8.52,3.814,8.52,8.521c0,4.705-3.814,8.52-8.52,8.52 s-8.52-3.814-8.52-8.52l-12.33-12.33V81.98c3.327,3.328,3.327,8.723,0,12.049c-3.327,3.328-8.722,3.328-12.049,0 c-3.327-3.326-3.327-8.721,0-12.049V64.544l-12.33,12.33c0,4.705-3.814,8.52-8.52,8.52s-8.52-3.814-8.52-8.52 c0-4.706,3.814-8.521,8.52-8.521l12.33-12.33H18.019c-3.327,3.328-8.722,3.328-12.049,0c-3.327-3.326-3.327-8.721,0-12.048 s8.722-3.327,12.049,0h17.438l-12.33-12.33c-4.706,0-8.52-3.814-8.52-8.52c0-4.706,3.814-8.52,8.52-8.52s8.52,3.814,8.52,8.52 l12.33,12.33V18.019c-3.327-3.327-3.327-8.722,0-12.049s8.722-3.327,12.049,0s3.327,8.722,0,12.049v17.438l12.33-12.33 c0-4.706,3.814-8.52,8.52-8.52s8.52,3.814,8.52,8.52c0,4.705-3.814,8.52-8.52,8.52l-12.33,12.33h17.438 c3.327-3.327,8.722-3.327,12.049,0s3.327,8.722,0,12.048c-3.327,3.328-8.722,3.328-12.049,0H64.544L76.874,68.354z'\r\n\r\n// image url\r\n\r\n\r\n// lorem ipsum text\r\nloremIpsum = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras sodales\\n imperdiet auctor. Nunc ultrices lectus at erat dictum pharetra\\n elementum ante posuere. Duis turpis risus, blandit nec elementum et,\\n posuere eget lacus. Aliquam et risus magna, eu aliquet nibh. Fusce\\n consequat mi quis purus varius sagittis euismod urna interdum.\\n Curabitur aliquet orci quis felis semper vulputate. Vestibulum ac nisi\\n magna, id dictum diam. Proin sed metus vel magna blandit\\n sodales. Pellentesque at neque ultricies nunc euismod rutrum ut in\\n lorem. Mauris euismod tellus in tellus tempus interdum. Phasellus\\n mattis sapien et leo feugiat dictum. Vestibulum at volutpat velit.'\r\n\r\nbeforeEach(function(){\r\n  // test for touch device\r\n  this.isTouchDevice = 'ontouchstart' in document.documentElement\r\n})\r\n\r\n// strip spaces from result\r\nwindow.stripped = function(string) {\r\n  string = string.replace(/\\s+/g, '')\r\n  if(string.slice(-1) == ';') string = string.slice(0, -1)\r\n  return string\r\n}\r\n\r\n// This is needed because of IE11 which uses space as a delimiter in matrix\r\nwindow.matrixStringToArray = function(source){\r\n  return source\r\n    .replace(/matrix\\(|\\)/, '')\r\n    .split(SVG.regex.delimiter)\r\n    .map(parseFloat)\r\n}\r\n\r\n// This is needed because of IE11 creating values like 2.99999 when calculating a transformed box\r\nwindow.roundBox = function(box) {\r\n  return new SVG.Box(\r\n    Math.round(box.x),\r\n    Math.round(box.y),\r\n    Math.round(box.width),\r\n    Math.round(box.height)\r\n  )\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/hyperlink.js":"describe('Hyperlink', function() {\r\n  var link\r\n    , url = 'http://svgjs.com'\r\n\r\n  beforeEach(function() {\r\n    link = draw.link(url)\r\n    link.rect(100,100)\r\n  })\r\n  \r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('creates a link', function() {\r\n    expect(link.attr('href')).toBe(url)\r\n  })\r\n\r\n  describe('to()', function() {\r\n    it('creates xlink:href attribute', function() {\r\n      link.to('http://apple.com')\r\n      expect(link.attr('href')).toBe('http://apple.com')\r\n    })\r\n  })\r\n\r\n  describe('show()', function() {\r\n    it('creates xlink:show attribute', function() {\r\n      link.show('replace')\r\n      expect(link.attr('show')).toBe('replace')\r\n    })\r\n  })\r\n\r\n  describe('target()', function() {\r\n    it('creates target attribute', function() {\r\n      link.target('_blank')\r\n      expect(link.attr('target')).toBe('_blank')\r\n    })\r\n  })\r\n\r\n  describe('SVG.Element', function() {\r\n    var element\r\n\r\n    beforeEach(function() {\r\n      element = draw.rect(100,100)\r\n    })\r\n\r\n    describe('linkTo()', function() {\r\n      it('wraps the called element in a link with given url', function() {\r\n        element.linkTo(url)\r\n        expect(element.parent().attr('href')).toBe(url)\r\n      })\r\n      it('wraps the called element in a link with given block', function() {\r\n        element.linkTo(function(link) {\r\n          link.to(url).target('_blank')\r\n        })\r\n        expect(element.parent().attr('href')).toBe(url)\r\n        expect(element.parent().attr('target')).toBe('_blank')\r\n      })\r\n    })\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/image.js":"describe('Image', function() {\r\n  var image\r\n\r\n  beforeEach(function() {\r\n    image = draw.image(imageUrl, 100, 100)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n\r\n  describe('()', function() {\r\n    it('should set width and height automatically if no size is given', function(done) {\r\n      image = draw.image(imageUrl).loaded(function() {\r\n        expect(image.node.getAttribute('height')).toBe('1')\r\n        expect(image.node.getAttribute('width')).toBe('1')\r\n        done()\r\n      })\r\n    })\r\n    it('should set width and height if size is given', function(done) {\r\n      image = draw.image(imageUrl, 100, 100).loaded(function() {\r\n        expect(image.node.getAttribute('height')).toBe('100')\r\n        expect(image.node.getAttribute('width')).toBe('100')\r\n        done()\r\n      })\r\n    })\r\n    it('returns itself when no url given', function() {\r\n      var img = new SVG.Image()\r\n      expect(img.load()).toBe(img)\r\n    })\r\n  })\r\n\r\n  describe('loaded()', function() {\r\n    beforeEach(function(done) {\r\n      loadCb = {cb: function(){ done() }}\r\n      errorCb = jasmine.createSpy('errorCb')\r\n      spyOn(loadCb, 'cb').and.callThrough()\r\n      image = draw.image(imageUrl, 100, 100).loaded(loadCb.cb).error(errorCb)\r\n    })\r\n\r\n    it('should set the load callback', function() {\r\n      expect(image._loaded).toBe(loadCb.cb)\r\n    })\r\n    it('executes the load callback', function() {\r\n      expect(loadCb.cb).toHaveBeenCalledWith({\r\n        width: 1,\r\n        height: 1,\r\n        ratio: 1,\r\n        url: jasmine.any(String)\r\n      })\r\n    })\r\n    it('does not execute the error callback', function() {\r\n      expect(errorCb).not.toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n  describe('error()', function() {\r\n    beforeEach(function(done) {\r\n      loadCb = jasmine.createSpy('loadCb')\r\n      errorCb = {cb: function(){ done() }}\r\n      spyOn(errorCb, 'cb').and.callThrough()\r\n      image = draw.image('not_existant.jpg', 100, 100).loaded(loadCb).error(errorCb.cb)\r\n    })\r\n\r\n    it('should set the error callback', function() {\r\n      expect(image._error).toBe(errorCb.cb)\r\n    })\r\n    it('executes the error callback', function() {\r\n      expect(errorCb.cb).toHaveBeenCalledWith(jasmine.any(window.Event))\r\n    })\r\n    it('does not execute the load callback', function() {\r\n      expect(loadCb).not.toHaveBeenCalled()\r\n    })\r\n  })\r\n\r\n\r\n  describe('x()', function() {\r\n    it('should return the value of x without an argument', function() {\r\n      expect(image.x()).toBe(0)\r\n    })\r\n    it('should set the value of x with the first argument', function() {\r\n      image.x(123)\r\n      var box = image.bbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('should return the value of y without an argument', function() {\r\n      expect(image.y()).toBe(0)\r\n    })\r\n    it('should set the value of y with the first argument', function() {\r\n      image.y(345)\r\n      var box = image.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('should return the value of cx without an argument', function() {\r\n      expect(image.cx()).toBe(50)\r\n    })\r\n    it('should set the value of cx with the first argument', function() {\r\n      image.cx(123)\r\n      var box = image.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('should return the value of cy without an argument', function() {\r\n      expect(image.cy()).toBe(50)\r\n    })\r\n    it('should set the value of cy with the first argument', function() {\r\n      image.cy(345)\r\n      var box = image.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('should set the x and y position', function() {\r\n      image.move(123,456)\r\n      expect(image.node.getAttribute('x')).toBe('123')\r\n      expect(image.node.getAttribute('y')).toBe('456')\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      image.move(50,60)\r\n      image.dx(100)\r\n      expect(image.node.getAttribute('x')).toBe('150')\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      image.move(50,60)\r\n      image.dy(120)\r\n      expect(image.node.getAttribute('y')).toBe('180')\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      image.move(50,60)\r\n      image.dmove(80, 25)\r\n      expect(image.node.getAttribute('x')).toBe('130')\r\n      expect(image.node.getAttribute('y')).toBe('85')\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('should set the cx and cy position', function() {\r\n      image.center(321,567)\r\n      var box = image.bbox()\r\n      expect(box.cx).toBe(321)\r\n      expect(box.cy).toBe(567)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width of the element', function() {\r\n      image.width(789)\r\n      expect(image.node.getAttribute('width')).toBe('789')\r\n    })\r\n    it('gets the width of the element if the argument is null', function() {\r\n      expect(image.width().toString()).toBe(image.node.getAttribute('width'))\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height of the element', function() {\r\n      image.height(1236)\r\n      expect(image.node.getAttribute('height')).toBe('1236')\r\n    })\r\n    it('gets the height of the element if the argument is null', function() {\r\n      expect(image.height().toString()).toBe(image.node.getAttribute('height'))\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      image.size(987,654)\r\n      expect(image.node.getAttribute('width')).toBe('987')\r\n      expect(image.node.getAttribute('height')).toBe('654')\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = image.bbox()\r\n      image.size(500)\r\n      expect(image.width()).toBe(500)\r\n      expect(image.width() / image.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = image.bbox()\r\n      image.size(null, 525)\r\n      expect(image.height()).toBe(525)\r\n      expect(image.width() / image.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box = image.scale(2).rbox()\r\n\r\n      expect(box.width).toBe(image.attr('width') * 2)\r\n      expect(box.height).toBe(image.attr('height') * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box = image.scale(2, 3.5).rbox()\r\n\r\n      expect(box.width).toBe(image.attr('width') * 2)\r\n      expect(box.height).toBe(image.attr('height') * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('should set the translation of an element', function() {\r\n      image.transform({ x: 12, y: 12 })\r\n      expect(image.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/line.js":"describe('Line', function() {\r\n  var line\r\n\r\n  beforeEach(function() {\r\n    line = draw.line(0,100,100,0)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  // #487\r\n  describe('()', function(){\r\n    it('will take an array as input', function(){\r\n      line = draw.line([[0,100],[100,0]])\r\n      var attrs = line.attr()\r\n      expect(attrs.x1).toBe(0)\r\n      expect(attrs.y1).toBe(100)\r\n      expect(attrs.x2).toBe(100)\r\n      expect(attrs.y2).toBe(0)\r\n    })\r\n\r\n    it('falls back to a line with its two points at [0,0] without an argument', function() {\r\n      line = draw.line()\r\n      var attrs = line.attr()\r\n      expect(attrs.x1).toBe(0)\r\n      expect(attrs.y1).toBe(0)\r\n      expect(attrs.x2).toBe(0)\r\n      expect(attrs.y2).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('should return the value of x without an argument', function() {\r\n      expect(line.x()).toBe(0)\r\n    })\r\n    it('should set the value of x with the first argument', function() {\r\n      line.x(123)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('should return the value of y without an argument', function() {\r\n      expect(line.y()).toBe(0)\r\n    })\r\n    it('should set the value of y with the first argument', function() {\r\n      line.y(345)\r\n      var box = line.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('should return the value of cx without an argument', function() {\r\n      expect(line.cx()).toBe(50)\r\n    })\r\n    it('should set the value of cx with the first argument', function() {\r\n      line.cx(123)\r\n      var box = line.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('should return the value of cy without an argument', function() {\r\n      expect(line.cy()).toBe(50)\r\n    })\r\n    it('should set the value of cy with the first argument', function() {\r\n      line.cy(345)\r\n      var box = line.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('should set the x and y position', function() {\r\n      line.move(123,456)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(123)\r\n      expect(box.y + box.height).toBe(556)\r\n      expect(box.x + box.width).toBe(223)\r\n      expect(box.y).toBe(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      line.move(50,60)\r\n      line.dx(100)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(150)\r\n      expect(box.y + box.height).toBe(160)\r\n      expect(box.x + box.width).toBe(250)\r\n      expect(box.y).toBe(60)\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      line.move(50, 60)\r\n      line.dy(120)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(50)\r\n      expect(box.y + box.height).toBe(280)\r\n      expect(box.x + box.width).toBe(150)\r\n      expect(box.y).toBe(180)\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      line.move(50,60)\r\n      line.dmove(80, 25)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(130)\r\n      expect(box.y + box.height).toBe(185)\r\n      expect(box.x + box.width).toBe(230)\r\n      expect(box.y).toBe(85)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('should set the cx and cy position', function() {\r\n      line.center(321,567)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(271)\r\n      expect(box.y + box.height).toBe(617)\r\n      expect(box.x + box.width).toBe(371)\r\n      expect(box.y).toBe(517)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width of the element', function() {\r\n      line.width(400)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(0)\r\n      expect(box.x + box.width).toBe(400)\r\n    })\r\n    it('get the width of the element without argument', function() {\r\n      line.width(123)\r\n      var box = line.bbox()\r\n      expect(line.width()).toBe(box.width)\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height of the element', function() {\r\n      line.height(300)\r\n      var box = line.bbox()\r\n      expect(box.y).toBe(0)\r\n      expect(box.y + box.height).toBe(300)\r\n    })\r\n    it('gets the height of the element without argument', function() {\r\n      line.height(456)\r\n      var box = line.bbox()\r\n      expect(line.height()).toBe(box.height)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      line.size(987,654)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(0)\r\n      expect(box.y + box.height).toBe(654)\r\n      expect(box.x + box.width).toBe(987)\r\n      expect(box.y).toBe(0)\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = line.bbox()\r\n      line.size(500)\r\n      expect(line.width()).toBe(500)\r\n      expect(line.width() / line.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = line.bbox()\r\n      line.size(null, 525)\r\n      expect(line.height()).toBe(525)\r\n      expect(line.width() / line.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box1 = line.rbox()\r\n        , box2 = line.scale(2).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box1 = line.rbox()\r\n        , box2 = line.scale(2,3.5).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('should set the translation of an element', function() {\r\n      line.transform({ x: 12, y: 12 })\r\n      expect(line.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('should update the start and end points', function() {\r\n      line.plot(100,200,300,400)\r\n      var box = line.bbox()\r\n      expect(box.x).toBe(100)\r\n      expect(box.y).toBe(200)\r\n      expect(box.x + box.width).toBe(300)\r\n      expect(box.y + box.height).toBe(400)\r\n    })\r\n    it('change the x1,y1,x2,y2 attributes of the underlying line node when a string is passed', function() {\r\n      expect(line.plot('100,50 200,10')).toBe(line)\r\n\r\n      var attrs  = line.attr()\r\n      expect(attrs.x1).toBe(100)\r\n      expect(attrs.y1).toBe(50)\r\n      expect(attrs.x2).toBe(200)\r\n      expect(attrs.y2).toBe(10)\r\n    })\r\n    it('change the x1,y1,x2,y2 attributes of the underlying line node when 4 numbers are passed', function() {\r\n      expect(line.plot(45, 24, 220, 300)).toBe(line)\r\n\r\n      var attrs  = line.attr()\r\n      expect(attrs.x1).toBe(45)\r\n      expect(attrs.y1).toBe(24)\r\n      expect(attrs.x2).toBe(220)\r\n      expect(attrs.y2).toBe(300)\r\n    })\r\n    it('return the coordinates in a point array when no arguments are passed', function () {\r\n      var attrs = line.attr()\r\n        , pointArray = new SVG.PointArray([[attrs.x1, attrs.y1], [attrs.x2, attrs.y2]])\r\n\r\n      expect(line.plot()).toEqual(pointArray)\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/marker.js":"describe('Marker', function() {\r\n  \r\n  describe('on a container element', function() {\r\n    var marker\r\n\r\n    beforeEach(function() {\r\n      marker = draw.marker(10, 12, function(add) {\r\n        add.rect(10, 12)\r\n\r\n        this.ref(5, 6)\r\n      })\r\n    })\r\n\r\n    it('creates an instance of SVG.Marker', function() {\r\n      expect(marker instanceof SVG.Marker).toBeTruthy()\r\n    })\r\n\r\n    it('creates marker in defs', function() {\r\n      expect(marker.parent() instanceof SVG.Defs).toBeTruthy()\r\n    })\r\n\r\n    describe('marker()', function() {\r\n      it('returns the marker element', function() {\r\n        expect(marker = draw.marker(10, 12)).toBe(marker)\r\n      })\r\n      it('sets the refX to half of the given width', function() {\r\n        marker = draw.marker(10, 12)\r\n        expect(marker.node.getAttribute('refX')).toBe('5')\r\n      })\r\n      it('sets the refY to half of the given height', function() {\r\n        marker = draw.marker(13, 15)\r\n        expect(marker.node.getAttribute('refY')).toBe('7.5')\r\n      })\r\n    })\r\n\r\n  })\r\n  \r\n  describe('on a target path', function() {\r\n    var path, marker\r\n\r\n    beforeEach(function() {\r\n      path = draw.path('M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')\r\n\r\n      path.marker('mid', 10, 12, function(add) {\r\n        add.rect(10, 12)\r\n\r\n        this.ref(5, 6)\r\n      })\r\n\r\n      marker = path.marker('mid', 10, 10)\r\n    })\r\n\r\n    it('creates an instance of SVG.Marker', function() {\r\n      expect(path.reference('marker-mid') instanceof SVG.Marker).toBeTruthy()\r\n    })\r\n\r\n    describe('marker()', function() {\r\n      it('returns the target element', function() {\r\n        expect(path.marker('start', 10, 12)).toBe(path)\r\n      })\r\n      it('creates a marker and applies it to the marker-start attribute', function() {\r\n        path.marker('start', 10, 12)\r\n        marker = path.reference('marker-start')\r\n\r\n        expect(path.node.getAttribute('marker-start')).toBe(marker.toString())\r\n      })\r\n      it('creates a marker and applies it to the marker-mid attribute', function() {\r\n        path.marker('mid', 10, 12)\r\n        marker = path.reference('marker-mid')\r\n\r\n        expect(path.node.getAttribute('marker-mid')).toBe(marker.toString())\r\n      })\r\n      it('creates a marker and applies it to the marker-end attribute', function() {\r\n        path.marker('end', 10, 12)\r\n        marker = path.reference('marker-end')\r\n\r\n        expect(path.node.getAttribute('marker-end')).toBe(marker.toString())\r\n      })\r\n      it('accepts an instance of an existing marker element as the second argument', function() {\r\n        marker = draw.marker(11, 11)\r\n        path.marker('mid', marker)\r\n\r\n        expect(path.node.getAttribute('marker-mid')).toBe(marker.toString())\r\n      })\r\n    })\r\n  })\r\n\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/mask.js":"describe('Mask', function() {\r\n  var rect, circle\r\n\r\n  beforeEach(function() {\r\n    rect   = draw.rect(100,100)\r\n    circle = draw.circle(100).move(50, 50).fill('#fff')\r\n    rect.maskWith(circle)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('moves the masking element to a new mask node', function() {\r\n    expect(circle.parent() instanceof SVG.Mask).toBe(true)\r\n  })\r\n  \r\n  it('creates the mask node in the defs node', function() {\r\n    expect(circle.parent().parent()).toBe(draw.defs())\r\n  })\r\n\r\n  it('sets the \"mask\" attribute on the masked element with the mask id', function() {\r\n    expect(rect.attr('mask')).toBe('url(\"#' + circle.parent().attr('id') + '\")')\r\n  })\r\n\r\n  it('references the mask element in the masked element', function() {\r\n    expect(rect.masker).toBe(circle.parent())\r\n  })\r\n\r\n  it('references the masked element in the mask target list', function() {\r\n    expect(rect.masker.targets.indexOf(rect) > -1).toBe(true)\r\n  })\r\n\r\n  it('reuses mask element when mask was given', function() {\r\n    var mask = rect.masker\r\n    expect(draw.rect(100,100).maskWith(mask).masker).toBe(mask)\r\n  })\r\n  \r\n  it('unmasks all masked elements when being removed', function() {\r\n    rect.masker.remove()\r\n    expect(rect.attr('mask')).toBe(undefined)\r\n  })\r\n\r\n  describe('unmask()', function() {\r\n\r\n    it('clears the \"mask\" attribute on the masked element', function() {\r\n      rect.unmask()\r\n      expect(rect.attr('mask')).toBe(undefined)\r\n    })\r\n\r\n    it('removes the reference to the masking element', function() {\r\n      rect.unmask()\r\n      expect(rect.masker).toBe(undefined)\r\n    })\r\n\r\n    it('returns the element itslef', function() {\r\n      expect(rect.unmask()).toBe(rect)\r\n    })\r\n\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/matrix.js":"describe('Matrix', function() {\r\n  var matrix\r\n\r\n  describe('initialization', function() {\r\n\r\n    describe('without a source', function() {\r\n\r\n      beforeEach(function() {\r\n        matrix = new SVG.Matrix\r\n      })\r\n\r\n      it('creates a new matrix with default values', function() {\r\n        expect(matrix.a).toBe(1)\r\n        expect(matrix.b).toBe(0)\r\n        expect(matrix.c).toBe(0)\r\n        expect(matrix.d).toBe(1)\r\n        expect(matrix.e).toBe(0)\r\n        expect(matrix.f).toBe(0)\r\n      })\r\n\r\n      describe('extract()', function() {\r\n        var extract\r\n\r\n        beforeEach(function() {\r\n          extract = matrix.extract()\r\n        })\r\n\r\n        it('parses translation values', function() {\r\n          expect(extract.x).toBe(0)\r\n          expect(extract.y).toBe(0)\r\n        })\r\n        it('parses skew values', function() {\r\n          expect(extract.skewX).toBe(0)\r\n          expect(extract.skewY).toBe(0)\r\n        })\r\n        it('parses scale values', function() {\r\n          expect(extract.scaleX).toBe(1)\r\n          expect(extract.scaleY).toBe(1)\r\n        })\r\n        it('parses rotatoin value', function() {\r\n          expect(extract.rotation).toBe(0)\r\n        })\r\n      })\r\n\r\n      describe('toString()' , function() {\r\n        it('exports correctly to a string', function() {\r\n          expect(matrix.toString()).toBe('matrix(1,0,0,1,0,0)')\r\n        })\r\n      })\r\n    })\r\n\r\n    describe('with an element given', function() {\r\n      var rect\r\n\r\n      beforeEach(function() {\r\n        rect = draw.rect(100, 100)\r\n          .transform({ rotation: -10 }, true)\r\n          .transform({ x: 40, y: 50 }, true)\r\n          .transform({ scale: 2 }, true)\r\n\r\n        matrix = new SVG.Matrix(rect)\r\n      })\r\n\r\n      it('parses the current transform matrix from an element', function() {\r\n        expect(matrix.a).toBeCloseTo(1.9696155786514282)\r\n        expect(matrix.b).toBeCloseTo(-0.3472963869571686)\r\n        expect(matrix.c).toBeCloseTo(0.3472963869571686)\r\n        expect(matrix.d).toBeCloseTo(1.9696155786514282)\r\n        expect(matrix.e).toBeCloseTo(-17.770875930786133)\r\n        expect(matrix.f).toBeCloseTo(11.178505897521973)\r\n      })\r\n\r\n      describe('extract()', function() {\r\n\r\n        it('parses translation values', function() {\r\n          var extract = new SVG.Matrix(draw.rect(100, 100).translate(40, 50)).extract()\r\n          expect(extract.x).toBeCloseTo(40)\r\n          expect(extract.y).toBeCloseTo(50)\r\n        })\r\n        it('parses skewX value', function() {\r\n          var extract = new SVG.Matrix(draw.rect(100, 100).skew(25, 0)).extract()\r\n          expect(extract.skewX).toBeCloseTo(25)\r\n        })\r\n        it('parses skewY value', function() {\r\n          var extract = new SVG.Matrix(draw.rect(100, 100).skew(0, 20)).extract()\r\n          expect(extract.skewY).toBeCloseTo(20)\r\n        })\r\n        it('parses scale values', function() {\r\n          var extract = new SVG.Matrix(draw.rect(100, 100).scale(2, 3)).extract()\r\n          expect(extract.scaleX).toBeCloseTo(2)\r\n          expect(extract.scaleY).toBeCloseTo(3)\r\n        })\r\n        it('parses rotatoin value', function() {\r\n          var extract = new SVG.Matrix(draw.rect(100, 100).rotate(-100)).extract()\r\n          expect(extract.rotation).toBeCloseTo(-100)\r\n        })\r\n\r\n      })\r\n\r\n    })\r\n\r\n    describe('with a string given', function() {\r\n      it('parses the string value correctly', function() {\r\n        var matrix = new SVG.Matrix('2, 0, 0, 2, 100, 50')\r\n\r\n        expect(matrix.a).toBe(2)\r\n        expect(matrix.b).toBe(0)\r\n        expect(matrix.c).toBe(0)\r\n        expect(matrix.d).toBe(2)\r\n        expect(matrix.e).toBe(100)\r\n        expect(matrix.f).toBe(50)\r\n      })\r\n    })\r\n\r\n    describe('with an array given', function() {\r\n      it('parses the array correctly', function() {\r\n        var matrix = new SVG.Matrix([2, 0, 0, 2, 100, 50])\r\n\r\n        expect(matrix.a).toBe(2)\r\n        expect(matrix.b).toBe(0)\r\n        expect(matrix.c).toBe(0)\r\n        expect(matrix.d).toBe(2)\r\n        expect(matrix.e).toBe(100)\r\n        expect(matrix.f).toBe(50)\r\n      })\r\n    })\r\n\r\n    describe('with an object given', function() {\r\n      it('parses the object correctly', function() {\r\n        var matrix = new SVG.Matrix({a:2, b:0, c:0, d:2, e:100, f:50})\r\n\r\n        expect(matrix.a).toBe(2)\r\n        expect(matrix.b).toBe(0)\r\n        expect(matrix.c).toBe(0)\r\n        expect(matrix.d).toBe(2)\r\n        expect(matrix.e).toBe(100)\r\n        expect(matrix.f).toBe(50)\r\n      })\r\n    })\r\n\r\n    describe('with 6 arguments given', function() {\r\n      it('parses the arguments correctly', function() {\r\n        var matrix = new SVG.Matrix(2, 0, 0, 2, 100, 50)\r\n\r\n        expect(matrix.a).toBe(2)\r\n        expect(matrix.b).toBe(0)\r\n        expect(matrix.c).toBe(0)\r\n        expect(matrix.d).toBe(2)\r\n        expect(matrix.e).toBe(100)\r\n        expect(matrix.f).toBe(50)\r\n      })\r\n    })\r\n\r\n  })\r\n\r\n  describe('clone()', function() {\r\n    it('returns a clone of the matrix', function() {\r\n      var matrix = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , clone = matrix.clone()\r\n      expect(matrix).not.toBe(clone)\r\n      for(var i in 'abcdef') {\r\n        expect(matrix[i]).toEqual(clone[i])\r\n      }\r\n    })\r\n  })\r\n\r\n  describe('morph()', function() {\r\n    it('stores a given matrix for morphing', function() {\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , matrix2 = new SVG.Matrix(1, 0, 0, 1, 4, 3)\r\n\r\n      matrix1.morph(matrix2)\r\n\r\n      expect(matrix1.destination).toEqual(matrix2)\r\n    })\r\n    it('stores a clone, not the given matrix itself', function() {\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , matrix2 = new SVG.Matrix(1, 0, 0, 1, 4, 3)\r\n\r\n      matrix1.morph(matrix2)\r\n\r\n      expect(matrix1.destination).not.toBe(matrix2)\r\n    })\r\n  })\r\n\r\n  describe('at()', function() {\r\n    it('returns a morphed array at a given position', function() {\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , matrix2 = new SVG.Matrix(1, 0, 0, 1, 4, 3)\r\n        , matrix3 = matrix1.morph(matrix2).at(0.5)\r\n\r\n      expect(matrix1.toString()).toBe('matrix(2,0,0,5,0,0)')\r\n      expect(matrix2.toString()).toBe('matrix(1,0,0,1,4,3)')\r\n      expect(matrix3.toString()).toBe('matrix(1.5,0,0,3,2,1.5)')\r\n    })\r\n    it('returns itself when no destination specified', function() {\r\n      var matrix = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n      expect(matrix.at(0.5)).toBe(matrix)\r\n    })\r\n  })\r\n\r\n  describe('multiply()', function() {\r\n    it('multiplies two matices', function() {\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , matrix2 = new SVG.Matrix(1, 0, 0, 1, 4, 3)\r\n        , matrix3 = matrix1.multiply(matrix2)\r\n\r\n      expect(matrix1.toString()).toBe('matrix(2,0,0,5,0,0)')\r\n      expect(matrix2.toString()).toBe('matrix(1,0,0,1,4,3)')\r\n      expect(matrix3.toString()).toBe('matrix(2,0,0,5,8,15)')\r\n    })\r\n    it('accepts matrices in any form', function() {\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 0, 0)\r\n        , matrix2 = matrix1.multiply('1,0,0,1,4,3')\r\n\r\n      expect(matrix1.toString()).toBe('matrix(2,0,0,5,0,0)')\r\n      expect(matrix2.toString()).toBe('matrix(2,0,0,5,8,15)')\r\n    })\r\n  })\r\n\r\n  describe('inverse()', function() {\r\n    it('inverses matrix', function() {\r\n\r\n      var matrix1 = new SVG.Matrix(2, 0, 0, 5, 4, 3)\r\n        , matrix2 = matrix1.inverse()\r\n        , abcdef = [0.5,0,0,0.2,-2,-0.6]\r\n\r\n      expect(matrix1.toString()).toBe('matrix(2,0,0,5,4,3)')\r\n\r\n      for(var i in 'abcdef') {\r\n        expect(matrix2['abcdef'[i]]).toBeCloseTo(abcdef[i])\r\n      }\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('translates matrix by given x and y values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).translate(10, 12.5)\r\n\r\n      expect(matrix.e).toBe(14)\r\n      expect(matrix.f).toBe(15.5)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('performs a uniformal scale with one value', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).scale(3)\r\n\r\n      expect(matrix.a).toBe(3)\r\n      expect(matrix.d).toBe(3)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n    it('performs a non-uniformal scale with two values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).scale(2.5, 3.5)\r\n\r\n      expect(matrix.a).toBe(2.5)\r\n      expect(matrix.d).toBe(3.5)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n    it('performs a uniformal scale at a given center point with three values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).scale(3, 150, 100)\r\n\r\n      expect(matrix.a).toBe(3)\r\n      expect(matrix.d).toBe(3)\r\n      expect(matrix.e).toBe(-296)\r\n      expect(matrix.f).toBe(-197)\r\n    })\r\n    it('performs a non-uniformal scale at a given center point with four values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).scale(3, 2, 150, 100)\r\n\r\n      expect(matrix.a).toBe(3)\r\n      expect(matrix.d).toBe(2)\r\n      expect(matrix.e).toBe(-296)\r\n      expect(matrix.f).toBe(-97)\r\n    })\r\n  })\r\n\r\n  describe('rotate()', function() {\r\n    it('performs a rotation with one argument', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).rotate(30)\r\n\r\n      expect(matrix.a).toBeCloseTo(0.8660254037844387)\r\n      expect(matrix.d).toBeCloseTo(0.8660254037844387)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n    it('performs a rotation on a given point with three arguments', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).rotate(30, 150, 100)\r\n\r\n      expect(matrix.a).toBeCloseTo(0.8660254037844387)\r\n      expect(matrix.d).toBeCloseTo(0.8660254037844387)\r\n      expect(matrix.e).toBeCloseTo(74.0961894323342)\r\n      expect(matrix.f).toBeCloseTo(-58.60254037844388)\r\n    })\r\n  })\r\n\r\n  describe('flip()', function() {\r\n    describe('with x given', function() {\r\n      it('performs a flip over the horizontal axis with one argument', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip('x')\r\n\r\n        expect(matrix.a).toBe(-1)\r\n        expect(matrix.d).toBe(1)\r\n        expect(matrix.e).toBe(4)\r\n        expect(matrix.f).toBe(3)\r\n      })\r\n      it('performs a flip over the horizontal axis over a given point with two arguments', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip('x', 150)\r\n\r\n        expect(matrix.a).toBe(-1)\r\n        expect(matrix.d).toBe(1)\r\n        expect(matrix.e).toBe(304)\r\n        expect(matrix.f).toBe(3)\r\n      })\r\n    })\r\n    describe('with y given', function() {\r\n      it('performs a flip over the vertical axis with one argument', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip('y')\r\n\r\n        expect(matrix.a).toBe(1)\r\n        expect(matrix.d).toBe(-1)\r\n        expect(matrix.e).toBe(4)\r\n        expect(matrix.f).toBe(3)\r\n      })\r\n      it('performs a flip over the vertical axis over a given point with two arguments', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip('y', 100)\r\n\r\n        expect(matrix.a).toBe(1)\r\n        expect(matrix.d).toBe(-1)\r\n        expect(matrix.e).toBe(4)\r\n        expect(matrix.f).toBe(203)\r\n      })\r\n    })\r\n    describe('with no axis given', function() {\r\n      it('performs a flip over the horizontal and vertical axis with no argument', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip()\r\n\r\n        expect(matrix.a).toBe(-1)\r\n        expect(matrix.d).toBe(-1)\r\n        expect(matrix.e).toBe(4)\r\n        expect(matrix.f).toBe(3)\r\n      })\r\n      it('performs a flip over the horizontal and vertical axis over a given point with one argument that represent both coordinates', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip(100)\r\n\r\n        expect(matrix.a).toBe(-1)\r\n        expect(matrix.d).toBe(-1)\r\n        expect(matrix.e).toBe(204)\r\n        expect(matrix.f).toBe(203)\r\n      })\r\n      it('performs a flip over the horizontal and vertical axis over a given point with two arguments', function() {\r\n        var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).flip(50, 100)\r\n\r\n        expect(matrix.a).toBe(-1)\r\n        expect(matrix.d).toBe(-1)\r\n        expect(matrix.e).toBe(104)\r\n        expect(matrix.f).toBe(203)\r\n      })\r\n    })\r\n  })\r\n\r\n  describe('skew()', function() {\r\n    it('performs a uniformal skew with one value', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skew(14)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.24932800284318)\r\n      expect(matrix.c).toBeCloseTo(0.24932800284318)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n    it('performs a non-uniformal skew with two values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skew(8, 5)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.087488663525924)\r\n      expect(matrix.c).toBeCloseTo(0.14054083470239)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n    it('performs a uniformal skew at a given center point with three values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skew(3, 150, 100)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.052407779283041)\r\n      expect(matrix.c).toBeCloseTo(0.052407779283041)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBeCloseTo(-1.2407779283)\r\n      expect(matrix.f).toBeCloseTo(-4.8611668924562)\r\n    })\r\n    it('performs a non-uniformal skew at a given center point with four values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skew(9, 7, 150, 100)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.1227845609029)\r\n      expect(matrix.c).toBeCloseTo(0.15838444032454)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBeCloseTo(-11.83844403245)\r\n      expect(matrix.f).toBeCloseTo(-15.417684135435)\r\n    })\r\n    it('can be chained', function(){\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skew(9, 7).skew(20, 40)\r\n\r\n      expect(matrix.a).toBeCloseTo(1.1329003254605)\r\n      expect(matrix.b).toBeCloseTo(0.96188419208018)\r\n      expect(matrix.c).toBeCloseTo(0.52235467459074)\r\n      expect(matrix.d).toBeCloseTo(1.0446899253961)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n  })\r\n\r\n  describe('skewX', function(){\r\n    it('performs a skew along the x axis with one value', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skewX(12)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBe(0)\r\n      expect(matrix.c).toBeCloseTo(0.21255656167002)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n\r\n    it('performs a skew along the x axis at a given center point with three values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skewX(5, 150, 100)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBe(0)\r\n      expect(matrix.c).toBeCloseTo(0.087488663525924)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBeCloseTo(-4.74886635259)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n  })\r\n\r\n  describe('skewY', function(){\r\n    it('performs a skew along the y axis with one value', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skewY(12)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.21255656167002)\r\n      expect(matrix.c).toBe(0)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBe(3)\r\n    })\r\n\r\n    it('performs a skew along the y axis at a given center point with three values', function() {\r\n      var matrix = new SVG.Matrix(1, 0, 0, 1, 4, 3).skewY(5, 150, 100)\r\n\r\n      expect(matrix.a).toBe(1)\r\n      expect(matrix.b).toBeCloseTo(0.087488663525924)\r\n      expect(matrix.c).toBe(0)\r\n      expect(matrix.d).toBe(1)\r\n      expect(matrix.e).toBe(4)\r\n      expect(matrix.f).toBeCloseTo(-10.123299528889)\r\n    })\r\n  })\r\n\r\n  describe('native()', function() {\r\n    it('returns the node reference', function() {\r\n      expect(new SVG.Matrix().native() instanceof window.SVGMatrix).toBeTruthy()\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/memory.js":"describe('Memory', function () {\r\n  var rect, circle\r\n\r\n  beforeEach(function() {\r\n    rect = draw.rect(100,120)\r\n    circle = draw.circle(100)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('remember()', function() {\r\n    it('accepts an object with values', function() {\r\n      rect.remember({ some: {cool:'and',nested:'stuff',foo:5} })\r\n      expect(rect.remember('some').foo).toBe(5)\r\n    })\r\n    it('accepts key / value arguments', function() {\r\n      rect.remember('fill', rect.attr('fill'))\r\n      rect.fill('#f09')\r\n      expect(rect.remember('fill')).toBe('#000000')\r\n    })\r\n    it('acts as a getter with one string argument', function() {\r\n      rect.remember('opacity', 0.85)\r\n      expect(rect.remember('opacity')).toBe(0.85)\r\n    })\r\n    it('saves values to individual objects', function() {\r\n      rect.remember('opacity', 0.85)\r\n      circle.remember('opacity', 0.5)\r\n      expect(rect.remember('opacity')).toBe(0.85)\r\n      expect(circle.remember('opacity')).toBe(0.5)\r\n    })\r\n  })\r\n\r\n  describe('forget()', function() {\r\n    it('deletes a given memory', function() {\r\n      rect.remember({ grass: 'is green', one: 1 })\r\n      rect.forget('grass')\r\n      expect(rect.remember('grass')).toBe(undefined)\r\n      expect(rect.remember('one')).toBe(1)\r\n    })\r\n    it('accepts multiple arguments as different memories', function() {\r\n      rect.remember({ grass: 'might be purple', two: 2, sea: true })\r\n      rect.forget('grass', 'sea')\r\n      expect(rect.remember('grass')).toBe(undefined)\r\n      expect(rect.remember('sea')).toBe(undefined)\r\n      expect(rect.remember('two')).toBe(2)\r\n    })\r\n    it('clears the whole memory without arguments', function() {\r\n      rect.remember({ grass: 'is never pink', three: 3, tree: true })\r\n      rect.forget()\r\n      expect(rect.remember('grass')).toBe(undefined)\r\n      expect(rect.remember('tree')).toBe(undefined)\r\n      expect(rect.remember('three')).toBe(undefined)\r\n    })\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/nested.js":"describe('Nested', function() {\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('()', function() {\r\n    it('creates a nested svg of type SVG.Nested', function() {\r\n      expect(draw.nested() instanceof SVG.Nested).toBeTruthy()\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/number.js":"describe('Number', function() {\r\n  var number\r\n\r\n  beforeEach(function() {\r\n    number = new SVG.Number\r\n  })\r\n\r\n  describe('new', function() {\r\n    it('is zero', function() {\r\n      expect(number.value).toBe(0)\r\n    })\r\n    it('has a blank unit', function() {\r\n      expect(number.unit).toBe('')\r\n    })\r\n    it('accepts the unit as a second argument', function() {\r\n      number = new SVG.Number(30, '%')\r\n      expect(number.value).toBe(30)\r\n      expect(number.unit).toBe('%')\r\n    })\r\n    it('parses a pixel value', function() {\r\n      number = new SVG.Number('20px')\r\n      expect(number.value).toBe(20)\r\n      expect(number.unit).toBe('px')\r\n    })\r\n    it('parses a percent value', function() {\r\n      number = new SVG.Number('99%')\r\n      expect(number.value).toBe(0.99)\r\n      expect(number.unit).toBe('%')\r\n    })\r\n    it('parses a seconds value', function() {\r\n      number = new SVG.Number('2s')\r\n      expect(number.value).toBe(2000)\r\n      expect(number.unit).toBe('s')\r\n    })\r\n    it('parses a negative percent value', function() {\r\n      number = new SVG.Number('-89%')\r\n      expect(number.value).toBe(-0.89)\r\n      expect(number.unit).toBe('%')\r\n    })\r\n    it('falls back to 0 if given value is NaN', function() {\r\n      number = new SVG.Number(NaN)\r\n      expect(number.value).toBe(0)\r\n    })\r\n    it('falls back to maximum value if given number is positive infinite', function() {\r\n      number = new SVG.Number(1.7976931348623157E+10308)\r\n      expect(number.value).toBe(3.4e+38)\r\n    })\r\n    it('falls back to minimum value if given number is negative infinite', function() {\r\n      number = new SVG.Number(-1.7976931348623157E+10308)\r\n      expect(number.value).toBe(-3.4e+38)\r\n    })\r\n  })\r\n\r\n  describe('toString()', function() {\r\n    it('converts the number to a string', function() {\r\n      expect(number.toString()).toBe('0')\r\n    })\r\n    it('appends the unit', function() {\r\n      number.value = 1.21\r\n      number.unit = 'px'\r\n      expect(number.toString()).toBe('1.21px')\r\n    })\r\n    it('converts percent values properly', function() {\r\n      number.value = 1.36\r\n      number.unit = '%'\r\n      expect(number.toString()).toBe('136%')\r\n    })\r\n    it('converts second values properly', function() {\r\n      number.value = 2500\r\n      number.unit = 's'\r\n      expect(number.toString()).toBe('2.5s')\r\n    })\r\n  })\r\n\r\n  describe('valueOf()', function() {\r\n    it('returns a numeric value for default units', function() {\r\n      expect(typeof number.valueOf()).toBe('number')\r\n      number = new SVG.Number('12')\r\n      expect(typeof number.valueOf()).toBe('number')\r\n      number = new SVG.Number(13)\r\n      expect(typeof number.valueOf()).toBe('number')\r\n    })\r\n    it('returns a numeric value for pixel units', function() {\r\n      number = new SVG.Number('10px')\r\n      expect(typeof number.valueOf()).toBe('number')\r\n    })\r\n    it('returns a numeric value for percent units', function() {\r\n      number = new SVG.Number('20%')\r\n      expect(typeof number.valueOf()).toBe('number')\r\n    })\r\n    it('converts to a primitive when multiplying', function() {\r\n      number.value = 80\r\n      expect(number * 4).toBe(320)\r\n    })\r\n  })\r\n\r\n  describe('to()', function() {\r\n    beforeEach(function() {\r\n      number = number.plus(4)\r\n    })\r\n    it('returns a new instance', function() {\r\n      expect(number.to('em')).not.toBe(number)\r\n      expect(number.to('em') instanceof SVG.Number).toBeTruthy()\r\n    })\r\n    it('changes the unit value', function() {\r\n      number = number.to('%')\r\n      expect(number.unit).toBe('%')\r\n    })\r\n    it('changes the output value', function() {\r\n      var oldNumber = number.valueOf()\r\n      number = number.to('%')\r\n      expect(number.toString()).toBe('400%')\r\n    })\r\n  })\r\n\r\n  describe('plus()', function() {\r\n    it('returns a new instance', function() {\r\n      expect(number.plus(4.5)).not.toBe(number)\r\n      expect(number.plus(4.5) instanceof SVG.Number).toBeTruthy()\r\n    })\r\n    it('adds a given number', function() {\r\n      expect(number.plus(3.5).valueOf()).toBe(3.5)\r\n    })\r\n    it('adds a given percentage value', function() {\r\n      expect(number.plus('225%').valueOf()).toBe(2.25)\r\n    })\r\n    it('adds a given pixel value', function() {\r\n      expect(number.plus('83px').valueOf()).toBe(83)\r\n    })\r\n    it('use the unit of this number as the unit of the returned number by default', function (){\r\n      expect(new SVG.Number('12s').plus('3%').unit).toBe('s')\r\n    })\r\n    it('use the unit of the passed number as the unit of the returned number when this number as no unit', function() {\r\n      expect(number.plus('15%').unit).toBe('%')\r\n    })\r\n  })\r\n\r\n  describe('minus()', function() {\r\n    it('subtracts a given number', function() {\r\n      expect(number.minus(3.7).valueOf()).toBe(-3.7)\r\n    })\r\n    it('subtracts a given percentage value', function() {\r\n      expect(number.minus('223%').valueOf()).toBe(-2.23)\r\n    })\r\n    it('subtracts a given pixel value', function() {\r\n      expect(number.minus('85px').valueOf()).toBe(-85)\r\n    })\r\n    it('use the unit of this number as the unit of the returned number by default', function (){\r\n      expect(new SVG.Number('12s').minus('3%').unit).toBe('s')\r\n    })\r\n    it('use the unit of the passed number as the unit of the returned number when this number as no unit', function() {\r\n      expect(number.minus('15%').unit).toBe('%')\r\n    })\r\n  })\r\n\r\n  describe('times()', function() {\r\n    beforeEach(function() {\r\n      number = number.plus(4)\r\n    })\r\n    it('multiplies with a given number', function() {\r\n      expect(number.times(3).valueOf()).toBe(12)\r\n    })\r\n    it('multiplies with a given percentage value', function() {\r\n      expect(number.times('110%').valueOf()).toBe(4.4)\r\n    })\r\n    it('multiplies with a given pixel value', function() {\r\n      expect(number.times('85px').valueOf()).toBe(340)\r\n    })\r\n    it('use the unit of this number as the unit of the returned number by default', function (){\r\n      expect(new SVG.Number('12s').times('3%').unit).toBe('s')\r\n    })\r\n    it('use the unit of the passed number as the unit of the returned number when this number as no unit', function() {\r\n      expect(number.times('15%').unit).toBe('%')\r\n    })\r\n  })\r\n\r\n  describe('divide()', function() {\r\n    beforeEach(function() {\r\n      number = number.plus(90)\r\n    })\r\n    it('divides by a given number', function() {\r\n      expect(number.divide(3).valueOf()).toBe(30)\r\n    })\r\n    it('divides by a given percentage value', function() {\r\n      expect(number.divide('3000%').valueOf()).toBe(3)\r\n    })\r\n    it('divides by a given pixel value', function() {\r\n      expect(number.divide('45px').valueOf()).toBe(2)\r\n    })\r\n    it('use the unit of this number as the unit of the returned number by default', function (){\r\n      expect(new SVG.Number('12s').divide('3%').unit).toBe('s')\r\n    })\r\n    it('use the unit of the passed number as the unit of the returned number when this number as no unit', function() {\r\n      expect(number.divide('15%').unit).toBe('%')\r\n    })\r\n  })\r\n\r\n  describe('morph()', function() {\r\n    it('returns itself', function() {\r\n      expect(number.morph(new SVG.Number)).toBe(number)\r\n    })\r\n    it('prepares the color for morphing', function() {\r\n      var destination = new SVG.Number\r\n      number.morph(destination)\r\n      expect(number.destination).toEqual(destination)\r\n    })\r\n    it('if the passed object as a relative attribute set to true, destination is relative to the current value', function() {\r\n      var n1 = new SVG.Number(3)\r\n        , n2 = new SVG.Number(7)\r\n\r\n      n2.relative = true\r\n      n1.morph(n2)\r\n      expect(n1.destination.value).toBe(n1.value + n2.value)\r\n    })\r\n  })\r\n\r\n  describe('at()', function() {\r\n    it('returns a new instance', function() {\r\n      var destination = new SVG.Number(200)\r\n      var morphed = number.morph(destination).at(0.4)\r\n      expect(morphed).not.toBe(number)\r\n      expect(morphed).not.toBe(destination)\r\n    })\r\n    it('morphes number to a given position', function() {\r\n      var destination = new SVG.Number(200)\r\n      var morphed = number.morph(destination).at(0.4)\r\n      expect(morphed.valueOf()).toBe(80)\r\n    })\r\n    it('morphes number to a given percentage position', function() {\r\n      var destination = new SVG.Number('100%')\r\n      var morphed = number.morph(destination).at(0.72)\r\n      expect(morphed.toString()).toBe('72%')\r\n    })\r\n    it('use the unit of the destination number as the unit of the returned number by default', function() {\r\n      expect(new SVG.Number('100s').morph('50%').at(0.5).unit).toBe('%')\r\n    })\r\n    it('use the unit of this number as the unit of the returned number when the destination number as no unit', function() {\r\n      expect(expect(new SVG.Number('100s').morph(50).at(0.5).unit).toBe('s'))\r\n    })\r\n    it('returns itself when no destination specified', function() {\r\n      expect(number.at(0.5)).toBe(number)\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/path.js":"describe('Path', function() {\r\n  var path\r\n\r\n  beforeEach(function() {\r\n    path = draw.path(svgPath)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('()', function() {\r\n    it('falls back to a single point without an argument', function() {\r\n      path = draw.path()\r\n      expect(path.attr('d')).toBe('M0 0 ')\r\n    })\r\n  })\r\n\r\n  describe('array()', function() {\r\n    it('returns an instance of SVG.PathArray', function() {\r\n      expect(path.array() instanceof SVG.PathArray).toBeTruthy()\r\n    })\r\n    it('returns the value stored in the private variable _array', function() {\r\n      expect(path.array()).toBe(path._array)\r\n    })\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(path.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      path.x(123)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(path.y()).toBe(0)\r\n    })\r\n    it('sets the value of y with the first argument', function() {\r\n      path.y(345)\r\n      var box = path.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(path.cx()).toBe(50)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      path.cx(123)\r\n      var box = path.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(path.cy()).toBe(50)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      path.cy(345)\r\n      var box = path.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      path.move(123,456)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(123)\r\n      expect(box.y).toBe(456)\r\n    })\r\n    it('sets the x and y position when scaled to half its size', function() {\r\n      path.scale(0.5, 0, 0).move(123,456)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(123)\r\n      expect(box.y).toBe(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      path.move(50,60)\r\n      path.dx(100)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(150)\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      path.move(50, 60)\r\n      path.dy(120)\r\n      var box = path.bbox()\r\n      expect(box.y).toBe(180)\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      path.move(50,60)\r\n      path.dmove(80, 25)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(130)\r\n      expect(box.y).toBe(85)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      path.center(321,567)\r\n      var box = path.bbox()\r\n      expect(box.x).toBe(271)\r\n      expect(box.y).toBe(517)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width of the element', function() {\r\n      path.width(234)\r\n      var box = path.bbox()\r\n      expect(box.width).toBeCloseTo(234)\r\n    })\r\n    it('gets the width of the element without an argument', function() {\r\n      path.width(456)\r\n      expect(path.width()).toBeCloseTo(456)\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height of the element', function() {\r\n      path.height(654)\r\n      var box = path.bbox()\r\n      expect(box.height).toBeCloseTo(654)\r\n    })\r\n    it('gets the height of the element without an argument', function() {\r\n      path.height(321)\r\n      expect(path.height()).toBeCloseTo(321)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('defines the width and height of the element', function() {\r\n      path.size(987,654)\r\n      var box = path.bbox()\r\n      expect(box.width).toBeCloseTo(987)\r\n      expect(box.height).toBeCloseTo(654)\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = path.bbox()\r\n      path.size(500)\r\n      expect(path.width()).toBeCloseTo(500)\r\n      expect(path.width() / path.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = path.bbox()\r\n      path.size(null, 525)\r\n      expect(path.height()).toBe(525)\r\n      expect(path.width() / path.height()).toBeCloseTo(box.width / box.height)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box1 = path.rbox()\r\n        , box2 = path.scale(2).rbox()\r\n\r\n      expect(box1.width * 2).toBe(box2.width)\r\n      expect(box1.height * 2).toBe(box2.height)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box1 = path.rbox()\r\n        , box2 = path.scale(2, 3.5).rbox()\r\n\r\n      expect(box1.width * 2).toBe(box2.width)\r\n      expect(box1.height * 3.5).toBe(box2.height)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      path.transform({ x: 12, y: 12 })\r\n      expect(path.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('changes the d attribute of the underlying path node when a string is passed', function() {\r\n      var pathString = 'm 3,2 c 0,0 -0,13 8,14 L 5,4'\r\n        , pathArray = new SVG.PathArray(pathString)\r\n\r\n      expect(path.plot(pathString)).toBe(path)\r\n      expect(path.attr('d')).toBe(pathString)\r\n    })\r\n    it('clears the array cache when a value is passed', function() {\r\n      path = draw.path([ ['M', 50, 60], ['A', 60, 60, 0, 0, 0, 50, -60], ['z'] ])\r\n      expect(path._array instanceof SVG.PathArray).toBeTruthy()\r\n      path.plot('m 3,2 c 0,0 -0,13 8,14 L 5,4')\r\n      expect(path._array).toBeUndefined()\r\n    })\r\n    it('applies a given path string value as is', function() {\r\n      var pathString = 'm 3,2 c 0,0 -0,13 8,14 L 5,4'\r\n\r\n      path = draw.path(pathString)\r\n      expect(path.attr('d')).toBe(pathString)\r\n    })\r\n    it('does not parse and cache a given string value to SVG.PathArray', function() {\r\n      path = draw.path('m 3,2 c 0,0 -0,13 8,14 L 5,4')\r\n      expect(path._array).toBeUndefined()\r\n    })\r\n    it('caches a given array value', function() {\r\n      path = draw.path([ ['M', 50, 60], ['A', 60, 60, 0, 0, 0, 50, -60], ['H', 100], ['L', 20, 30], ['Z'] ])\r\n      expect(path._array instanceof SVG.PathArray).toBeTruthy()\r\n    })\r\n    it('returns the path array when no arguments are passed', function () {\r\n      expect(path.plot()).toBe(path.array())\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('clears the cached SVG.PathArray instance', function() {\r\n      path = draw.path(svgPath)\r\n      path.clear()\r\n      expect(path._array).toBeUndefined()\r\n    })\r\n  })\r\n\r\n  describe('toString()', function() {\r\n    it('renders path array correctly to string', function() {\r\n      path = path.plot(['M', 50, 60, 'A', 60, 60, 0, 0, 0, 50, -60, 'H', 100, 'V', 100, 'L', 20, 30, 'C', 10, 20, 30, 40, 50, 60 ])\r\n      expect(path.node.getAttribute('d')).toBe('M50 60A60 60 0 0 0 50 -60H100V100L20 30C10 20 30 40 50 60 ')\r\n    })\r\n  })\r\n\r\n  describe('length()', function() {\r\n    it('gets the total length of the path', function() {\r\n      expect(path.length()).toBe(path.node.getTotalLength())\r\n    })\r\n  })\r\n\r\n  describe('pointAt()', function() {\r\n    it('gets a point at given length', function() {\r\n      expect(path.pointAt(100)).toEqual(path.node.getPointAtLength(100))\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/pattern.js":"describe('Pattern', function() {\r\n  var rect, pattern\r\n\r\n  beforeEach(function() {\r\n    rect = draw.rect(100,100)\r\n    pattern = draw.pattern(20, 30, function(add) {\r\n      add.rect(10,10).move(10,10)\r\n      add.circle(30)\r\n    })\r\n  })\r\n\r\n  afterEach(function() {\r\n    rect.remove()\r\n    pattern.remove()\r\n  })\r\n\r\n  it('is an instance of SVG.Pattern', function() {\r\n    expect(pattern instanceof SVG.Pattern).toBe(true)\r\n  })\r\n\r\n  it('allows creation of a new gradient without block', function() {\r\n    pattern = draw.pattern(10,30)\r\n    expect(pattern.children().length).toBe(0)\r\n  })\r\n\r\n  describe('fill()', function() {\r\n    it('returns the id of the pattern wrapped in url()', function() {\r\n      expect(pattern.fill()).toBe('url(#' + pattern.attr('id') + ')')\r\n    })\r\n  })\r\n\r\n  describe('attr()', function() {\r\n    it('will catch transform attribues and convert them to patternTransform', function() {\r\n      expect(pattern.translate(100,100).attr('patternTransform')).toBe('matrix(1,0,0,1,100,100)')\r\n    })\r\n  })\r\n\r\n  describe('toString()', function() {\r\n    it('returns the id of the pattern wrapped in url()', function() {\r\n      expect(pattern + '').toBe('url(#' + pattern.attr('id') + ')')\r\n    })\r\n    it('is called when instance is passed as an attribute value', function() {\r\n      rect.attr('fill', pattern)\r\n      expect(rect.attr('fill')).toBe('url(#' + pattern.attr('id') + ')')\r\n    })\r\n    it('is called when instance is passed in a fill() method', function() {\r\n      rect.fill(pattern)\r\n      expect(rect.attr('fill')).toBe('url(#' + pattern.attr('id') + ')')\r\n    })\r\n  })\r\n\r\n  describe('update()', function() {\r\n\r\n    it('removes all existing children first', function() {\r\n      pattern = draw.pattern(30, 30, function(add) {\r\n        add.rect(10,10).move(10,10)\r\n        add.circle(30)\r\n      })\r\n      expect(pattern.children().length).toBe(2)\r\n      pattern.update(function(add) {\r\n        add.rect(10,10).move(10,10)\r\n        add.circle(30)\r\n      })\r\n      expect(pattern.children().length).toBe(2)\r\n    })\r\n\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/point.js":"describe('Point', function() {\r\n  var point\r\n\r\n  describe('initialization', function() {\r\n\r\n    describe('without a source', function() {\r\n\r\n      beforeEach(function() {\r\n        point = new SVG.Point\r\n      })\r\n\r\n      it('creates a new point with default values', function() {\r\n        expect(point.x).toBe(0)\r\n        expect(point.y).toBe(0)\r\n      })\r\n\r\n    })\r\n\r\n    describe('with x and y given', function() {\r\n      it('creates a point with given values', function() {\r\n        var point = new SVG.Point(2,4)\r\n\r\n        expect(point.x).toBe(2)\r\n        expect(point.y).toBe(4)\r\n      })\r\n    })\r\n\r\n    describe('with only x given', function() {\r\n      it('creates a point using the given value for both x and y', function() {\r\n        var point = new SVG.Point(7)\r\n\r\n        expect(point.x).toBe(7)\r\n        expect(point.y).toBe(7)\r\n      })\r\n    })\r\n\r\n    describe('with array given', function() {\r\n      it('creates a point from array', function() {\r\n        var point = new SVG.Point([2,4])\r\n\r\n        expect(point.x).toBe(2)\r\n        expect(point.y).toBe(4)\r\n      })\r\n    })\r\n\r\n    describe('with object given', function() {\r\n      it('creates a point from object', function() {\r\n        var point = new SVG.Point({x:2,y:4})\r\n\r\n        expect(point.x).toBe(2)\r\n        expect(point.y).toBe(4)\r\n      })\r\n    })\r\n\r\n    describe('with SVG.Point given', function() {\r\n      it('creates a point from SVG.Point', function() {\r\n        var point = new SVG.Point(new SVG.Point(2,4))\r\n\r\n        expect(point.x).toBe(2)\r\n        expect(point.y).toBe(4)\r\n      })\r\n    })\r\n\r\n    describe('with native SVGPoint given', function() {\r\n      it('creates a point from native SVGPoint', function() {\r\n        var point = new SVG.Point(new SVG.Point(2,4).native())\r\n\r\n        expect(point.x).toBe(2)\r\n        expect(point.y).toBe(4)\r\n      })\r\n    })\r\n\r\n  })\r\n\r\n  describe('clone()', function() {\r\n    it('returns cloned point', function() {\r\n      var point1 = new SVG.Point(1,1)\r\n        , point2 = point1.clone()\r\n\r\n      expect(point1).toEqual(point2)\r\n      expect(point1).not.toBe(point2)\r\n    })\r\n  })\r\n\r\n  describe('morph()', function() {\r\n    it('stores a given point for morphing', function() {\r\n      var point1 = new SVG.Point(1,1)\r\n        , point2 = new SVG.Point(2,2)\r\n\r\n      point1.morph(point2)\r\n\r\n      expect(point1.destination).toEqual(point2)\r\n    })\r\n    it('stores a clone, not the given matrix itself', function() {\r\n      var point1 = new SVG.Point(1,1)\r\n        , point2 = new SVG.Point(2,2)\r\n\r\n      point1.morph(point2)\r\n\r\n      expect(point1.destination).not.toBe(point2)\r\n    })\r\n    it('allow passing the point by directly passing its coordinates', function() {\r\n      var point1 = new SVG.Point(1,1)\r\n        , point2 = new SVG.Point(2,2)\r\n\r\n      point1.morph(point2.x, point2.y)\r\n\r\n      expect(point1.destination).toEqual(point2)\r\n    })\r\n  })\r\n\r\n  describe('at()', function() {\r\n    it('returns a morphed point at a given position', function() {\r\n      var point1 = new SVG.Point(1,1)\r\n        , point2 = new SVG.Point(2,2)\r\n        , point3 = point1.morph(point2).at(0.5)\r\n\r\n      expect(point3).toEqual(new SVG.Point(1.5, 1.5))\r\n    })\r\n    it('returns itself when no destination specified', function() {\r\n      var point = new SVG.Point(1,1)\r\n      expect(point.at(0.4)).toBe(point)\r\n    })\r\n  })\r\n\r\n  describe('transform()', function() {\r\n    it('returns a point transformed with given matrix', function() {\r\n      var point = new SVG.Point(1,5)\r\n        , matrix = new SVG.Matrix(0,0,1,0,0,1)\r\n\r\n      expect(point.transform(matrix)).toEqual(new SVG.Point(5,1))\r\n    })\r\n  })\r\n\r\n  describe('native()', function() {\r\n    it('returns native SVGPoint', function() {\r\n      expect(new SVG.Point().native() instanceof window.SVGPoint).toBeTruthy()\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/polygon.js":"describe('Polygon', function() {\r\n  var polygon\r\n\r\n  beforeEach(function() {\r\n    polygon = draw.polygon('0,0 100,0 100,100 0,100')\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('()', function(){\r\n    it('falls back to a single point without an argument', function() {\r\n      polygon = draw.polygon()\r\n      expect(polygon.attr('points')).toBe('0,0')\r\n    })\r\n  })\r\n\r\n\r\n  describe('array()', function() {\r\n    it('returns an instance of SVG.PointArray', function() {\r\n      expect(polygon.array() instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n    it('returns the value stored in the private variable _array', function() {\r\n      expect(polygon.array()).toBe(polygon._array)\r\n    })\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(polygon.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      polygon.x(123)\r\n      var box = polygon.bbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(polygon.y()).toBe(0)\r\n    })\r\n    it('sets the value of y with the first argument', function() {\r\n      polygon.y(345)\r\n      var box = polygon.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(polygon.cx()).toBe(50)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      polygon.cx(123)\r\n      var box = polygon.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(polygon.cy()).toBe(50)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      polygon.cy(345)\r\n      var box = polygon.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      polygon.move(123,456)\r\n      var box = polygon.bbox()\r\n      expect(box.x).toBe(123)\r\n      expect(box.y).toBe(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      polygon.move(50,60)\r\n      polygon.dx(100)\r\n      var box = polygon.bbox()\r\n      expect(box.x).toBe(150)\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      polygon.move(50, 60)\r\n      polygon.dy(120)\r\n      var box = polygon.bbox()\r\n      expect(box.y).toBe(180)\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      polygon.move(50,60)\r\n      polygon.dmove(80, 25)\r\n      var box = polygon.bbox()\r\n      expect(box.x).toBe(130)\r\n      expect(box.y).toBe(85)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      polygon.center(321,567)\r\n      var box = polygon.bbox()\r\n      expect(box.x).toBe(271)\r\n      expect(box.y).toBe(517)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width and height of the element', function() {\r\n      polygon.width(987)\r\n      var box = polygon.bbox()\r\n      expect(box.width).toBeCloseTo(987)\r\n    })\r\n    it('gets the width and height of the element without an argument', function() {\r\n      polygon.width(789)\r\n      expect(polygon.width()).toBeCloseTo(789)\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height and height of the element', function() {\r\n      polygon.height(987)\r\n      var box = polygon.bbox()\r\n      expect(box.height).toBeCloseTo(987)\r\n    })\r\n    it('gets the height and height of the element without an argument', function() {\r\n      polygon.height(789)\r\n      expect(polygon.height()).toBeCloseTo(789)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      polygon.size(987,654)\r\n      var box = polygon.bbox()\r\n      expect(box.width).toBeCloseTo(987)\r\n      expect(box.height).toBeCloseTo(654)\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = polygon.bbox()\r\n      polygon.size(500)\r\n      expect(polygon.width()).toBe(500)\r\n      expect(polygon.width() / polygon.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = polygon.bbox()\r\n      polygon.size(null, 525)\r\n      expect(polygon.height()).toBe(525)\r\n      expect(polygon.width() / polygon.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box1 = polygon.rbox()\r\n        , box2 = polygon.scale(2).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box1 = polygon.rbox()\r\n        , box2 = polygon.scale(2, 3.5).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      polygon.transform({ x: 12, y: 12 })\r\n      expect(polygon.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('changes the points attribute of the underlying polygon node when a string is passed', function() {\r\n      var pointString = '100,50 75,20 200,100'\r\n        , pointArray = new SVG.PointArray(pointString)\r\n\r\n      expect(polygon.plot(pointString)).toBe(polygon)\r\n      expect(polygon.attr('points')).toBe(pointArray.toString())\r\n    })\r\n    it('returns the point array when no arguments are passed', function () {\r\n      expect(polygon.plot()).toBe(polygon.array())\r\n    })\r\n    it('clears the array cache when a value is passed', function() {\r\n      polygon = draw.polygon([100,50,75,20,200,100])\r\n      expect(polygon._array instanceof SVG.PointArray).toBeTruthy()\r\n      polygon.plot('100,50 75,20 200,100')\r\n      expect(polygon._array).toBeUndefined()\r\n    })\r\n    it('applies a given polygon string value as is', function() {\r\n      var polyString = '100,50,75,20,200,100'\r\n\r\n      polygon = draw.polygon(polyString)\r\n      expect(polygon.attr('points')).toBe(polyString)\r\n    })\r\n    it('does not parse and cache a given string value to SVG.PointArray', function() {\r\n      polygon = draw.polygon('100,50 75,20 200,100')\r\n      expect(polygon._array).toBeUndefined()\r\n    })\r\n    it('caches a given array value', function() {\r\n      polygon = draw.polygon([100,50,75,20,200,100])\r\n      expect(polygon._array instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('clears the cached SVG.PointArray instance', function() {\r\n      polygon = draw.polygon([100,50,75,20,200,100])\r\n      polygon.clear()\r\n      expect(polygon._array).toBeUndefined()\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/polyline.js":"describe('Polyline', function() {\r\n  var polyline\r\n\r\n  beforeEach(function() {\r\n    polyline = draw.polyline('0,0 100,0 100,100 0,100')\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('()', function(){\r\n    it('falls back to a single point without an argument', function() {\r\n      polyline = draw.polyline()\r\n      expect(polyline.attr('points')).toBe('0,0')\r\n    })\r\n  })\r\n\r\n\r\n  describe('array()', function() {\r\n    it('returns an instance of SVG.PointArray', function() {\r\n      expect(polyline.array() instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n    it('returns the value stored in the private variable _array', function() {\r\n      expect(polyline.array()).toBe(polyline._array)\r\n    })\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(polyline.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      polyline.x(123)\r\n      var box = polyline.bbox()\r\n      expect(box.x).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(polyline.y()).toBe(0)\r\n    })\r\n    it('sets the value of y with the first argument', function() {\r\n      polyline.y(345)\r\n      var box = polyline.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      expect(polyline.cx()).toBe(50)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      polyline.cx(123)\r\n      var box = polyline.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      expect(polyline.cy()).toBe(50)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      polyline.cy(345)\r\n      var box = polyline.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      polyline.move(123,456)\r\n      var box = polyline.bbox()\r\n      expect(box.x).toBe(123)\r\n      expect(box.y).toBe(456)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      polyline.move(50,60)\r\n      polyline.dx(100)\r\n      var box = polyline.bbox()\r\n      expect(box.x).toBe(150)\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      polyline.move(50, 60)\r\n      polyline.dy(120)\r\n      var box = polyline.bbox()\r\n      expect(box.y).toBe(180)\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      polyline.move(50,60)\r\n      polyline.dmove(80, 25)\r\n      var box = polyline.bbox()\r\n      expect(box.x).toBe(130)\r\n      expect(box.y).toBe(85)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      polyline.center(321,567)\r\n      var box = polyline.bbox()\r\n      expect(box.x).toBe(271)\r\n      expect(box.y).toBe(517)\r\n    })\r\n  })\r\n\r\n  describe('width()', function() {\r\n    it('sets the width and height of the element', function() {\r\n      polyline.width(987)\r\n      var box = polyline.bbox()\r\n      expect(box.width).toBeCloseTo(987, 1)\r\n    })\r\n    it('gets the width and height of the element without an argument', function() {\r\n      polyline.width(789)\r\n      expect(polyline.width()).toBeCloseTo(789)\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height and height of the element', function() {\r\n      polyline.height(987)\r\n      var box = polyline.bbox()\r\n      expect(box.height).toBeCloseTo(987)\r\n    })\r\n    it('gets the height and height of the element without an argument', function() {\r\n      polyline.height(789)\r\n      expect(polyline.height()).toBeCloseTo(789)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      polyline.size(987,654)\r\n      var box = polyline.bbox()\r\n      expect(box.width).toBeCloseTo(987)\r\n      expect(box.height).toBeCloseTo(654)\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = polyline.bbox()\r\n      polyline.size(500)\r\n      expect(polyline.width()).toBe(500)\r\n      expect(polyline.width() / polyline.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = polyline.bbox()\r\n      polyline.size(null, 525)\r\n      expect(polyline.height()).toBe(525)\r\n      expect(polyline.width() / polyline.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box1 = polyline.rbox()\r\n        , box2 = polyline.scale(2).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box1 = polyline.rbox()\r\n        , box2 = polyline.scale(2, 3.5).rbox()\r\n\r\n      expect(box2.width).toBe(box1.width * 2)\r\n      expect(box2.height).toBe(box1.height * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      polyline.transform({ x: 12, y: 12 })\r\n      expect(polyline.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('change the points attribute of the underlying polyline node when a string is passed', function() {\r\n      var pointString = '100,50 75,20 200,100'\r\n        , pointArray = new SVG.PointArray(pointString)\r\n\r\n      expect(polyline.plot(pointString)).toBe(polyline)\r\n      expect(polyline.attr('points')).toBe(pointArray.toString())\r\n    })\r\n    it('return the point array when no arguments are passed', function () {\r\n      expect(polyline.plot()).toBe(polyline.array())\r\n    })\r\n    it('clears the array cache when a value is passed', function() {\r\n      polyline = draw.polyline([100,50,75,20,200,100])\r\n      expect(polyline._array instanceof SVG.PointArray).toBeTruthy()\r\n      polyline.plot('100,50 75,20 200,100')\r\n      expect(polyline._array).toBeUndefined()\r\n    })\r\n    it('applies a given polyline string value as is', function() {\r\n      var polyString = '100,50,75,20,200,100'\r\n\r\n      polyline = draw.polyline(polyString)\r\n      expect(polyline.attr('points')).toBe(polyString)\r\n    })\r\n    it('does not parse and cache a given string value to SVG.PointArray', function() {\r\n      polyline = draw.polyline('100,50 75,20 200,100')\r\n      expect(polyline._array).toBeUndefined()\r\n    })\r\n    it('caches a given array value', function() {\r\n      polyline = draw.polyline([100,50,75,20,200,100])\r\n      expect(polyline._array instanceof SVG.PointArray).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('clears the cached SVG.PointArray instance', function() {\r\n      polyline = draw.polyline([100,50,75,20,200,100])\r\n      polyline.clear()\r\n      expect(polyline._array).toBeUndefined()\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/rect.js":"describe('Rect', function() {\r\n  var rect\r\n  \r\n  beforeEach(function() {\r\n    rect = draw.rect(220,100)\r\n  })\r\n  \r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n  \r\n  describe('x()', function() {\r\n    it('should return the value of x without an argument', function() {\r\n      expect(rect.x()).toBe(0)\r\n    })\r\n    it('should set the value of x with the first argument', function() {\r\n      rect.x(123)\r\n      expect(rect.node.getAttribute('x')).toBe('123')\r\n    })\r\n  })\r\n  \r\n  describe('y()', function() {\r\n    it('should return the value of y without an argument', function() {\r\n      expect(rect.y()).toBe(0)\r\n    })\r\n    it('should set the value of y with the first argument', function() {\r\n      rect.y(345)\r\n      expect(rect.node.getAttribute('y')).toBe('345')\r\n    })\r\n  })\r\n  \r\n  describe('cx()', function() {\r\n    it('should return the value of cx without an argument', function() {\r\n      expect(rect.cx()).toBe(110)\r\n    })\r\n    it('should set the value of cx with the first argument', function() {\r\n      rect.cx(123)\r\n      var box = rect.bbox()\r\n      expect(box.cx).toBe(123)\r\n    })\r\n  })\r\n  \r\n  describe('cy()', function() {\r\n    it('should return the value of cy without an argument', function() {\r\n      expect(rect.cy()).toBe(50)\r\n    })\r\n    it('should set the value of cy with the first argument', function() {\r\n      rect.cy(345)\r\n      var box = rect.bbox()\r\n      expect(box.cy).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('radius()', function() {\r\n    it('should set the rx and ry', function() {\r\n      rect.radius(10,20)\r\n      expect(rect.node.getAttribute('rx')).toBe('10')\r\n      expect(rect.node.getAttribute('ry')).toBe('20')\r\n    })\r\n    it('should set the rx and ry if only rx given', function() {\r\n      rect.radius(30)\r\n      expect(rect.node.getAttribute('rx')).toBe('30')\r\n      expect(rect.node.getAttribute('ry')).toBe('30')\r\n    })\r\n  })\r\n  \r\n  describe('move()', function() {\r\n    it('should set the x and y position', function() {\r\n      rect.move(123,456)\r\n      expect(rect.node.getAttribute('x')).toBe('123')\r\n      expect(rect.node.getAttribute('y')).toBe('456')\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('moves the x positon of the element relative to the current position', function() {\r\n      rect.move(50,60)\r\n      rect.dx(100)\r\n      expect(rect.node.getAttribute('x')).toBe('150')\r\n    })\r\n  })\r\n\r\n  describe('dy()', function() {\r\n    it('moves the y positon of the element relative to the current position', function() {\r\n      rect.move(50,60)\r\n      rect.dy(120)\r\n      expect(rect.node.getAttribute('y')).toBe('180')\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    it('moves the x and y positon of the element relative to the current position', function() {\r\n      rect.move(50,60)\r\n      rect.dmove(80, 25)\r\n      expect(rect.node.getAttribute('x')).toBe('130')\r\n      expect(rect.node.getAttribute('y')).toBe('85')\r\n    })\r\n  })\r\n  \r\n  describe('center()', function() {\r\n    it('should set the cx and cy position', function() {\r\n      rect.center(321,567)\r\n      var box = rect.bbox()\r\n      expect(box.cx).toBe(321)\r\n      expect(box.cy).toBe(567)\r\n    })\r\n  })\r\n  \r\n  describe('width()', function() {\r\n    it('sets the width of the element', function() {\r\n      rect.width(789)\r\n      expect(rect.node.getAttribute('width')).toBe('789')\r\n    })\r\n    it('gets the width of the element if the argument is null', function() {\r\n      expect(rect.width().toString()).toBe(rect.node.getAttribute('width'))\r\n    })\r\n  })\r\n\r\n  describe('height()', function() {\r\n    it('sets the height of the element', function() {\r\n      rect.height(1236)\r\n      expect(rect.node.getAttribute('height')).toBe('1236')\r\n    })\r\n    it('gets the height of the element if the argument is null', function() {\r\n      expect(rect.height().toString()).toBe(rect.node.getAttribute('height'))\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      rect.size(987,654)\r\n      expect(rect.node.getAttribute('width')).toBe('987')\r\n      expect(rect.node.getAttribute('height')).toBe('654')\r\n    })\r\n    it('defines the width and height proportionally with only the width value given', function() {\r\n      var box = rect.bbox()\r\n      rect.size(500)\r\n      expect(rect.width()).toBe(500)\r\n      expect(rect.width() / rect.height()).toBe(box.width / box.height)\r\n    })\r\n    it('defines the width and height proportionally with only the height value given', function() {\r\n      var box = rect.bbox()\r\n      rect.size(null, 525)\r\n      expect(rect.height()).toBe(525)\r\n      expect(rect.width() / rect.height()).toBe(box.width / box.height)\r\n    })\r\n  })\r\n  \r\n  describe('scale()', function() {\r\n    it('should scale the element universally with one argument', function() {\r\n      var box = rect.scale(2).rbox()\r\n      \r\n      expect(box.width).toBe(rect.attr('width') * 2)\r\n      expect(box.height).toBe(rect.attr('height') * 2)\r\n    })\r\n    it('should scale the element over individual x and y axes with two arguments', function() {\r\n      var box = rect.scale(2, 3.5).rbox()\r\n      \r\n      expect(box.width).toBe(rect.attr('width') * 2)\r\n      expect(box.height).toBe(rect.attr('height') * 3.5)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('should set the translation of an element', function() {\r\n      rect.transform({ x: 12, y: 12 })\r\n      expect(rect.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n  \r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/regex.js":"describe('Regex', function() {\r\n\r\n  describe('matchers', function() {\r\n\r\n    describe('numberAndUnit', function() {\r\n      var match\r\n\r\n      it('is true with a positive unit value', function() {\r\n        match = ('10%').match(SVG.regex.numberAndUnit)\r\n        expect(match[1]).toBe('10')\r\n        expect(match[5]).toBe('%')\r\n      })\r\n      it('is true with a negative unit value', function() {\r\n        match = ('-11%').match(SVG.regex.numberAndUnit)\r\n        expect(match[1]).toBe('-11')\r\n        expect(match[5]).toBe('%')\r\n      })\r\n      it('is false with a positive unit value', function() {\r\n        match = ('NotAUnit').match(SVG.regex.numberAndUnit)\r\n        expect(match).toBeNull()\r\n      })\r\n\r\n      it('is true with a number', function() {\r\n        [\"1\", \"-1\", \"+15\", \"1.55\", \".5\", \"5.\", \"1.3e2\", \"1E-4\", \"1e+12\"].forEach(function(s) {\r\n          expect(SVG.regex.numberAndUnit.test(s)).toBeTruthy()\r\n        })\r\n      })\r\n      it('is false with a faulty number', function() {\r\n        [\"+-1\", \"1.2.3\", \"1+1\", \"1e4.5\", \".5.\", \"1f5\", \".\"].forEach(function(s) {\r\n          expect(SVG.regex.numberAndUnit.test(s)).toBeFalsy()\r\n        })\r\n      })\r\n      it('is true with a number with unit', function() {\r\n        [\"1px\", \"-1em\", \"+15%\", \"1.55s\", \".5pt\", \"5.deg\", \"1.3e2rad\", \"1E-4grad\", \"1e+12cm\"].forEach(function(s) {\r\n          expect(SVG.regex.numberAndUnit.test(s)).toBeTruthy()\r\n        })\r\n      })\r\n      it('is false with a faulty number or wrong unit', function() {\r\n        [\"1em1\", \"-1eq,5\"].forEach(function(s) {\r\n          expect(SVG.regex.numberAndUnit.test(s)).toBeFalsy()\r\n        })\r\n      })\r\n\r\n    })\r\n  })\r\n\r\n  describe('testers', function() {\r\n\r\n    describe('isHex', function() {\r\n      it('is true with a three based hex', function() {\r\n        expect(SVG.regex.isHex.test('#f09')).toBeTruthy()\r\n      })\r\n      it('is true with a six based hex', function() {\r\n        expect(SVG.regex.isHex.test('#fe0198')).toBeTruthy()\r\n      })\r\n      it('is false with a faulty hex', function() {\r\n        expect(SVG.regex.isHex.test('###')).toBeFalsy()\r\n        expect(SVG.regex.isHex.test('#0')).toBeFalsy()\r\n        expect(SVG.regex.isHex.test('f06')).toBeFalsy()\r\n      })\r\n    })\r\n\r\n    describe('isRgb', function() {\r\n      it('is true with an rgb value', function() {\r\n        expect(SVG.regex.isRgb.test('rgb(255,66,100)')).toBeTruthy()\r\n      })\r\n      it('is false with a non-rgb value', function() {\r\n        expect(SVG.regex.isRgb.test('hsb(255, 100, 100)')).toBeFalsy()\r\n      })\r\n    })\r\n\r\n    describe('isNumber', function() {\r\n\r\n      it('is true with a number', function() {\r\n        [\"1\", \"-1\", \"+15\", \"1.55\", \".5\", \"5.\", \"1.3e2\", \"1E-4\", \"1e+12\"].forEach(function(s) {\r\n          expect(SVG.regex.isNumber.test(s)).toBeTruthy()\r\n        })\r\n      })\r\n\r\n      it('is false with a faulty number', function() {\r\n        [\"1a\", \"+-1\", \"1.2.3\", \"1+1\", \"1e4.5\", \".5.\", \"1f5\", \".\"].forEach(function(s) {\r\n          expect(SVG.regex.isNumber.test(s)).toBeFalsy()\r\n        })\r\n      })\r\n\r\n    })\r\n\r\n\r\n\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/selector.js":"describe('Selector', function() {\r\n\r\n  describe('get()', function() {\r\n    it('gets an element\\'s instance by id', function() {\r\n      var rect = draw.rect(111, 333)\r\n      \r\n      expect(SVG.get(rect.attr('id'))).toBe(rect)\r\n    })\r\n    it('makes all the element\\'s methods available', function() {\r\n      var element = draw.group()\r\n        , got = SVG.get(element.attr('id'))\r\n      \r\n      expect(got.attr()).toEqual(element.attr())\r\n    })\r\n    it('gets a referenced element by attribute value', function() {\r\n      var rect = draw.defs().rect(100, 100)\r\n        , use  = draw.use(rect)\r\n        , mark = draw.marker(10, 10)\r\n        , path = draw.path(svgPath).marker('end', mark)\r\n\r\n      expect(SVG.get(use.attr('href'))).toBe(rect)\r\n      expect(SVG.get(path.attr('marker-end'))).toBe(mark)\r\n    })\r\n  })\r\n\r\n  describe('select()', function() {\r\n    var e1, e2, e3, e4 ,e5\r\n\r\n    beforeEach(function() {\r\n      e1 = draw.rect(100, 100).addClass('selectable-element')\r\n      e2 = draw.rect(100, 100).addClass('unselectable-element')\r\n      e3 = draw.rect(100, 100).addClass('selectable-element')\r\n      e4 = draw.rect(100, 100).addClass('unselectable-element')\r\n      e5 = draw.rect(100, 100).addClass('selectable-element')\r\n    })\r\n    it('gets all elements with a given class name', function() {\r\n      expect(SVG.select('rect.selectable-element').valueOf()).toEqual([e1, e3, e5])\r\n    })\r\n    it('returns an instance of SVG.Set', function() {\r\n      expect(SVG.select('rect.selectable-element') instanceof SVG.Set).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('Parent#select()', function() {\r\n    it('gets all elements with a given class name inside a given element', function() {\r\n      var group = draw.group()\r\n        , e1 = draw.rect(100, 100).addClass('selectable-element')\r\n        , e2 = draw.rect(100, 100).addClass('unselectable-element')\r\n        , e3 = group.rect(100, 100).addClass('selectable-element')\r\n        , e4 = draw.rect(100, 100).addClass('unselectable-element')\r\n        , e5 = group.rect(100, 100).addClass('selectable-element')\r\n\r\n      expect(group.select('rect.selectable-element').valueOf()).toEqual([e3, e5])\r\n    })\r\n  })\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/set.js":"describe('Set', function() {\r\n  var set, e1, e2, e3, e4, e5\r\n\r\n  beforeEach(function() {\r\n    draw.attr('viewBox', null)\r\n    set = draw.set()\r\n    e1  = draw.rect(100,100).attr('id', 'e1').move(200,250)\r\n    e2  = draw.ellipse(100,100).attr('id', 'e2')\r\n    e3  = draw.line(0,0,100,100).attr('id', 'e3')\r\n    e4  = draw.circle(50).attr('id', 'e4')\r\n    e5  = draw.polyline('0,0 10,20 30,50 80,100').attr('id', 'e5')\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  it('creates the set method on SVG.Container instances', function() {\r\n    expect(draw.set() instanceof SVG.Set).toBeTruthy()\r\n  })\r\n\r\n  it('creates a set with initial value', function() {\r\n    var members = [1, 2, 4]\r\n\r\n    expect(draw.set(members).valueOf()).toBe(members)\r\n  })  \r\n\r\n  describe('add()', function() {\r\n    it('returns the set instance', function() {\r\n      expect(set.add(e1)).toBe(set)\r\n    })\r\n    it('stores given element', function() {\r\n      set.add(e1).add(e2).add(e3)\r\n      expect(set.valueOf()).toEqual([e1,e2,e3])\r\n      expect(set.members.length).toBe(3)\r\n    })\r\n    it('accepts multiple elements at once', function() {\r\n      set.add(e1, e2, e3, e4, e5)\r\n      expect(set.valueOf()).toEqual([e1, e2, e3, e4, e5])\r\n      expect(set.members.length).toBe(5)\r\n    })\r\n  })\r\n\r\n  describe('remove()', function() {\r\n    it('returns the set instance', function() {\r\n      set.add(e1)\r\n      expect(set.remove(e1)).toBe(set)\r\n    })\r\n    it('removes given element', function() {\r\n      set.add(e1).add(e2).add(e3).remove(e2)\r\n      expect(set.valueOf()).toEqual([e1,e3])\r\n      expect(set.members.length).toBe(2)\r\n    })\r\n  })\r\n\r\n  describe('each()', function() {\r\n    it('returns the set instance', function() {\r\n      expect(set.each(function(){})).toBe(set)\r\n    })\r\n    it('iterates over all members of the set', function() {\r\n      var ids = []\r\n      set.add(e1).add(e2).add(e3)\r\n\r\n      set.each(function() {\r\n        ids.push(this.attr('id'))\r\n      })\r\n\r\n      expect(ids.length).toBe(3)\r\n      expect(ids).toEqual(['e1','e2','e3'])\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('returns the set instance', function() {\r\n      expect(set.clear()).toBe(set)\r\n    })\r\n    it('removes all members from set', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5).clear()\r\n      expect(set.members.length).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('get()', function() {\r\n    it('returns member at given index', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n      expect(set.get(2)).toBe(e3)\r\n    })\r\n  })\r\n\r\n  describe('first()', function() {\r\n    it('returns first member', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n      expect(set.first()).toBe(e1)\r\n    })\r\n  })\r\n\r\n  describe('last()', function() {\r\n    it('returns last member', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n      expect(set.last()).toBe(e5)\r\n    })\r\n  })\r\n\r\n  describe('has()', function() {\r\n    it('checks if a given element is present in set', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n      expect(set.has(e4)).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('length()', function() {\r\n    it('gets the length of the set', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n      expect(set.length()).toBe(5)\r\n    })\r\n  })\r\n\r\n  describe('index()', function() {\r\n    it('returns the index of a given element within the set', function() {\r\n      set.add(e1).add(e2).add(e3).add(e5)\r\n      expect(set.index(e1)).toBe(0)\r\n      expect(set.index(e2)).toBe(1)\r\n      expect(set.index(e3)).toBe(2)\r\n      expect(set.index(e4)).toBe(-1)\r\n      expect(set.index(e5)).toBe(3)\r\n    })\r\n  })\r\n\r\n  describe('valueOf()', function() {\r\n    it('returns the members array', function() {\r\n      set.add(e1)\r\n      expect(set.valueOf()).toBe(set.members)\r\n    })\r\n  })\r\n\r\n  describe('bbox()', function() {\r\n    it('returns the bounding box of all elements', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n\r\n      var box = set.bbox()\r\n\r\n      expect(box.x).toBeCloseTo(0)\r\n      expect(box.y).toBeCloseTo(0, 0)\r\n      expect(box.width).toBeCloseTo(300)\r\n      expect(box.height).toBeCloseTo(350)\r\n    })\r\n    it('returns an instance of SVG.RBox', function() {\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5)\r\n\r\n      expect(set.bbox() instanceof SVG.RBox).toBeTruthy()\r\n    })\r\n    it('returns an empty bounding box wiht no members', function() {\r\n      var box = set.bbox()\r\n\r\n      expect(box.x).toBe(0)\r\n      expect(box.y).toBe(0)\r\n      expect(box.width).toBe(0)\r\n      expect(box.height).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('method alias', function() {\r\n\r\n    describe('attr()', function() {\r\n      it('is applied to every member of the set', function() {\r\n        var fills = []\r\n\r\n        set.add(e1).add(e2).add(e3).add(e4).add(e5).attr('fill', '#ff0099')\r\n        set.each(function() {\r\n          fills.push(this.attr('fill'))\r\n        })\r\n\r\n        expect(fills).toEqual(['#ff0099','#ff0099','#ff0099','#ff0099','#ff0099'])\r\n      })\r\n    })\r\n\r\n  })\r\n\r\n  describe('method inheritance', function() {\r\n\r\n    beforeEach(function() {\r\n      SVG.extend(SVG.Element, {\r\n        orange: function() {\r\n          this.fill('#ff6600')\r\n        }\r\n      })\r\n    })\r\n\r\n    it('inherits newly added element methods after initialisation', function() {\r\n      expect(typeof set.orange).toBe('function')\r\n    })\r\n\r\n    it('applies newly inherited methods properly to members', function() {\r\n      var fills = []\r\n\r\n      set.add(e1).add(e2).add(e3).add(e4).add(e5).orange()\r\n      set.each(function() {\r\n        fills.push(this.attr('fill'))\r\n      })\r\n\r\n      expect(fills).toEqual(['#ff6600','#ff6600','#ff6600','#ff6600','#ff6600'])\r\n    })\r\n\r\n  })\r\n\r\n})\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/sugar.js":"describe('Sugar', function() {\r\n\r\n  var rect\r\n\r\n  beforeEach(function() {\r\n    draw.attr('viewBox', null)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('fill()', function() {\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n    })\r\n\r\n    it('returns the node reference', function() {\r\n      expect(rect.fill('red')).toBe(rect)\r\n    })\r\n\r\n    it('sets the given value', function() {\r\n      expect(rect.fill('red').attr('fill')).toBe('red')\r\n    })\r\n\r\n    it('sets the given value with object given', function() {\r\n      rect.fill({color: 'red', opacity: 0.5, rule: 'odd'})\r\n      expect(rect.attr('fill')).toBe('red')\r\n      expect(rect.attr('fill-opacity')).toBe(0.5)\r\n      expect(rect.attr('fill-rule')).toBe('odd')\r\n    })\r\n\r\n    it('is a nop with no argument given and returns node reference', function() {\r\n      rect.fill('red')\r\n      expect(rect.fill()).toBe(rect)\r\n      expect(rect.attr('fill')).toBe('red')\r\n    })\r\n  })\r\n\r\n  describe('rotate()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'transform')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.transform.calls.reset()\r\n    })\r\n\r\n    it('redirects to transform()', function() {\r\n      rect.rotate(1,2,3)\r\n      expect(rect.transform).toHaveBeenCalledWith({ rotation: 1, cx: 2, cy: 3 })\r\n    })\r\n  })\r\n\r\n  describe('skew()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'transform')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.transform.calls.reset()\r\n    })\r\n\r\n    it('redirects to transform() with no argument', function() {\r\n      rect.skew()\r\n      expect(rect.transform).toHaveBeenCalledWith({ skewX: undefined, skewY: undefined, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with one argument', function() {\r\n      rect.skew(5)\r\n      expect(rect.transform).toHaveBeenCalledWith({ skew: 5, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with two argument', function() {\r\n      rect.skew(5, 6)\r\n      expect(rect.transform).toHaveBeenCalledWith({ skewX: 5, skewY: 6, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with three arguments', function() {\r\n      rect.skew(5, 6, 7)\r\n      expect(rect.transform).toHaveBeenCalledWith({ skew: 5, cx: 6, cy: 7 })\r\n    })\r\n\r\n    it('redirects to transform() with four arguments', function() {\r\n      rect.skew(5, 6, 7, 8)\r\n      expect(rect.transform).toHaveBeenCalledWith({ skewX: 5, skewY: 6, cx: 7, cy: 8 })\r\n    })\r\n  })\r\n\r\n  describe('scale()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'transform')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.transform.calls.reset()\r\n    })\r\n\r\n    it('redirects to transform() with no argument', function() {\r\n      rect.scale()\r\n      expect(rect.transform).toHaveBeenCalledWith({ scaleX: undefined, scaleY: undefined, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with one argument', function() {\r\n      rect.scale(5)\r\n      expect(rect.transform).toHaveBeenCalledWith({ scale: 5, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with two argument', function() {\r\n      rect.scale(5, 6)\r\n      expect(rect.transform).toHaveBeenCalledWith({ scaleX: 5, scaleY: 6, cx: undefined, cy: undefined })\r\n    })\r\n\r\n    it('redirects to transform() with three arguments', function() {\r\n      rect.scale(5, 6, 7)\r\n      expect(rect.transform).toHaveBeenCalledWith({ scale: 5, cx: 6, cy: 7 })\r\n    })\r\n\r\n    it('redirects to transform() with four arguments', function() {\r\n      rect.scale(5, 6, 7, 8)\r\n      expect(rect.transform).toHaveBeenCalledWith({ scaleX: 5, scaleY: 6, cx: 7, cy: 8 })\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'transform')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.transform.calls.reset()\r\n    })\r\n\r\n    it('redirects to transform()', function() {\r\n      rect.translate(1,2)\r\n      expect(rect.transform).toHaveBeenCalledWith({ x: 1, y: 2 })\r\n    })\r\n  })\r\n\r\n  describe('flip()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'transform')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.transform.calls.reset()\r\n    })\r\n\r\n    it('redirects to transform()', function() {\r\n      rect.flip('x',2)\r\n      expect(rect.transform).toHaveBeenCalledWith({ flip: 'x', offset: 2 })\r\n    })\r\n\r\n    it('sets flip to \"both\" when calling without anything', function() {\r\n      rect.flip()\r\n      expect(rect.transform).toHaveBeenCalledWith({ flip: 'both', offset: undefined })\r\n    })\r\n\r\n    // this works because only x and y are valid flip values. Evereything else flips on both axis\r\n    it('sets flip to number and offset to number when called with offset only', function() {\r\n      rect.flip(5)\r\n      expect(rect.transform).toHaveBeenCalledWith({ flip: 5, offset: 5 })\r\n    })\r\n  })\r\n\r\n  describe('matrix()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'attr')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.attr.calls.reset()\r\n    })\r\n\r\n    it('redirects to attr() directly with one argument', function() {\r\n      rect.matrix([1,2,3,4,5,6])\r\n      expect(rect.attr).toHaveBeenCalledWith('transform', new SVG.Matrix([1,2,3,4,5,6]))\r\n    })\r\n\r\n    it('redirects to attr() directly with 6 arguments', function() {\r\n      rect.matrix(1,2,3,4,5,6)\r\n      expect(rect.attr).toHaveBeenCalledWith('transform', new SVG.Matrix([1,2,3,4,5,6]))\r\n    })\r\n  })\r\n\r\n  describe('opacity()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'attr')\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.attr.calls.reset()\r\n    })\r\n\r\n    it('redirects to attr() directly', function() {\r\n      rect.opacity(0.5)\r\n      expect(rect.attr).toHaveBeenCalledWith('opacity', 0.5)\r\n    })\r\n  })\r\n\r\n  describe('dx() / dy()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'x').and.callThrough()\r\n      spyOn(rect, 'y').and.callThrough()\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.x.calls.reset()\r\n      rect.y.calls.reset()\r\n    })\r\n\r\n    it('redirects to x() / y() with adding the current value', function() {\r\n      rect.dx(5)\r\n      rect.dy(5)\r\n      expect(rect.x).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('5')), true)\r\n      expect(rect.y).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('5')), true)\r\n    })\r\n\r\n    it('allows to add a percentage value', function() {\r\n      rect.move('5%', '5%')\r\n\r\n      rect.dx('5%')\r\n      rect.dy('5%')\r\n\r\n      expect(rect.x).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('10%')), true)\r\n      expect(rect.y).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('10%')), true)\r\n    })\r\n\r\n    it('allows to add a percentage value when no x/y is set', function() {\r\n      rect.dx('5%')\r\n      rect.dy('5%')\r\n\r\n      expect(rect.x).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('5%')), true)\r\n      expect(rect.y).toHaveBeenCalledWith(jasmine.objectContaining(new SVG.Number('5%')), true)\r\n    })\r\n  })\r\n\r\n  describe('dmove()', function() {\r\n    var rect, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      spyOn(rect, 'dx').and.callThrough()\r\n      spyOn(rect, 'dy').and.callThrough()\r\n    })\r\n\r\n    afterEach(function() {\r\n      rect.remove()\r\n      rect.dx.calls.reset()\r\n      rect.dy.calls.reset()\r\n    })\r\n\r\n    it('redirects to dx() / dy() directly', function() {\r\n      rect.dmove(5,5)\r\n      expect(rect.dx).toHaveBeenCalledWith(5)\r\n      expect(rect.dy).toHaveBeenCalledWith(5)\r\n    })\r\n  })\r\n\r\n  describe('font()', function() {\r\n    var text, spy, undefined\r\n\r\n    beforeEach(function() {\r\n      text = draw.text(loremIpsum)\r\n      spyOn(text, 'leading')\r\n      spyOn(text, 'attr')\r\n    })\r\n\r\n    afterEach(function() {\r\n      text.remove()\r\n      text.leading.calls.reset()\r\n      text.attr.calls.reset()\r\n    })\r\n\r\n    it('sets leading when given', function() {\r\n      text.font({leading: 3})\r\n      expect(text.leading).toHaveBeenCalledWith(3)\r\n    })\r\n\r\n    it('sets text-anchor when anchor given', function() {\r\n      text.font({anchor: 'start'})\r\n      expect(text.attr).toHaveBeenCalledWith('text-anchor', 'start')\r\n    })\r\n\r\n    it('sets all font properties via attr()', function() {\r\n      text.font({\r\n        size: 20,\r\n        family: 'Verdana',\r\n        weight: 'bold',\r\n        stretch: 'wider',\r\n        variant: 'small-caps',\r\n        style: 'italic'\r\n      })\r\n      expect(text.attr).toHaveBeenCalledWith('font-size', 20)\r\n      expect(text.attr).toHaveBeenCalledWith('font-family', 'Verdana')\r\n      expect(text.attr).toHaveBeenCalledWith('font-weight', 'bold')\r\n      expect(text.attr).toHaveBeenCalledWith('font-stretch', 'wider')\r\n      expect(text.attr).toHaveBeenCalledWith('font-variant', 'small-caps')\r\n      expect(text.attr).toHaveBeenCalledWith('font-style', 'italic')\r\n    })\r\n\r\n    it('redirects all other stuff directly to attr()', function() {\r\n      text.font({\r\n        foo:'bar',\r\n        bar:'baz'\r\n      })\r\n      expect(text.attr).toHaveBeenCalledWith('foo', 'bar')\r\n      expect(text.attr).toHaveBeenCalledWith('bar', 'baz')\r\n    })\r\n\r\n    it('sets key value pair when called with 2 parameters', function() {\r\n      text.font('size', 20)\r\n      expect(text.attr).toHaveBeenCalledWith('font-size', 20)\r\n    })\r\n\r\n    it('gets value if called with one parameter', function() {\r\n      text.font('size')\r\n      expect(text.attr).toHaveBeenCalledWith('font-size', undefined)\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/svg.js":"describe('SVG', function() {\r\n\r\n  describe('()', function() {\r\n    var drawing, wrapper\r\n\r\n    beforeEach(function() {\r\n      wrapper = document.createElement('svg')\r\n      document.documentElement.appendChild(wrapper)\r\n      drawing = SVG(wrapper)\r\n    })\r\n\r\n    afterEach(function() {\r\n      wrapper.parentNode.removeChild(wrapper)\r\n    })\r\n\r\n    it('creates a new svg drawing', function() {\r\n      expect(drawing.type).toBe('svg')\r\n    })\r\n    it('creates an instance of SVG.Doc', function() {\r\n      expect(drawing instanceof SVG.Doc).toBe(true)\r\n    })\r\n    \r\n    if(parserInDoc){\r\n      it('sets no default size in svg documents', function() {\r\n        expect(drawing.width()).toBe(0)\r\n        expect(drawing.height()).toBe(0)\r\n      })\r\n    }else{\r\n      it('sets size to 100% in html documents', function() {\r\n        expect(drawing.width()).toBe('100%')\r\n        expect(drawing.height()).toBe('100%')\r\n      })\r\n    }\r\n  })\r\n\r\n  describe('create()', function() {\r\n    it('creates an element with given node name and return it', function() {\r\n      var element = SVG.create('rect')\r\n\r\n      expect(element.nodeName).toBe('rect')\r\n    })\r\n    it('increases the global id sequence', function() {\r\n      var did = SVG.did\r\n        , element = SVG.create('rect')\r\n\r\n      expect(did + 1).toBe(SVG.did)\r\n    })\r\n    it('adds a unique id containing the node name', function() {\r\n      var did = SVG.did\r\n        , element = SVG.create('rect')\r\n\r\n      expect(element.getAttribute('id')).toBe('SvgjsRect' + did)\r\n    })\r\n  })\r\n\r\n  describe('extend()', function() {\r\n    it('adds all functions in the given object to the target object', function() {\r\n      SVG.extend(SVG.Rect, {\r\n        soft: function() {\r\n          return this.opacity(0.2)\r\n        }\r\n      })\r\n\r\n      expect(typeof SVG.Rect.prototype.soft).toBe('function')\r\n      expect(draw.rect(100,100).soft().attr('opacity')).toBe(0.2)\r\n    })\r\n    it('accepts and extend multiple modules at once', function() {\r\n      SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Path, {\r\n        soft: function() {\r\n          return this.opacity(0.5)\r\n        }\r\n      })\r\n\r\n      expect(typeof SVG.Rect.prototype.soft).toBe('function')\r\n      expect(draw.rect(100,100).soft().attr('opacity')).toBe(0.5)\r\n      expect(typeof SVG.Ellipse.prototype.soft).toBe('function')\r\n      expect(draw.ellipse(100,100).soft().attr('opacity')).toBe(0.5)\r\n      expect(typeof SVG.Path.prototype.soft).toBe('function')\r\n      expect(draw.path().soft().attr('opacity')).toBe(0.5)\r\n    })\r\n    it('ignores non existant objects', function() {\r\n      SVG.extend(SVG.Rect, SVG.Bogus, {\r\n        soft: function() {\r\n          return this.opacity(0.3)\r\n        }\r\n      })\r\n\r\n      expect(typeof SVG.Rect.prototype.soft).toBe('function')\r\n      expect(draw.rect(100,100).soft().attr('opacity')).toBe(0.3)\r\n      expect(typeof SVG.Bogus).toBe('undefined')\r\n    })\r\n  })\r\n\r\n  describe('prepare()', function() {\r\n    var drawing, wrapper, parser\r\n\r\n    beforeEach(function() {\r\n      wrapper = document.createElement('svg')\r\n      document.documentElement.appendChild(wrapper)\r\n      drawing = SVG(wrapper)\r\n    })\r\n\r\n    it('creates a parser element when calling SVG()', function() {\r\n      expect(SVG.parser.draw.nodeName).toBe('svg')\r\n    })\r\n    it('hides the parser', function() {\r\n      expect(window.stripped(SVG.parser.draw.getAttribute('style'))).toBe('overflow:hidden;top:-100%;left:-100%;position:absolute;opacity:0')\r\n    })\r\n    it('holds polyline and path', function() {\r\n      expect(SVG.select('polyline', SVG.parser.draw).first().type).toBe('polyline')\r\n      expect(SVG.select('path', SVG.parser.draw).first().type).toBe('path')\r\n    })\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/symbol.js":"describe('Symbol', function() {\r\n  describe('()', function() {\r\n    var element\r\n\r\n    beforeEach(function() {\r\n      element = draw.symbol()\r\n    })\r\n\r\n    it('creates an instance of SVG.Symbol', function() {\r\n      expect(element instanceof SVG.Symbol).toBeTruthy()\r\n    })\r\n    it('is an instance of SVG.Container', function() {\r\n      expect(element instanceof SVG.Container).toBeTruthy()\r\n    })\r\n  })\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/text.js":"// IMPORTANT!!!\r\n// The native getBBox() on text elements isn't always accurate in the decimals.\r\n// Therefore sometimes some rounding is used to make test work as expected.\r\n\r\ndescribe('Text', function() {\r\n  var text\r\n\r\n  beforeEach(function() {\r\n    text = draw.text(loremIpsum).size(5)\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('leading()', function() {\r\n    it('returns the leading value of the text without an argument', function() {\r\n      expect(text.leading() instanceof SVG.Number)\r\n      expect(text.leading().valueOf()).toBe(1.3)\r\n    })\r\n    it('sets the leading value of the text with the first argument', function() {\r\n      expect(text.leading(1.5).dom.leading.valueOf()).toBe(1.5)\r\n    })\r\n  })\r\n\r\n  describe('rebuild()', function() {\r\n    it('disables the rebuild if called with false', function() {\r\n      expect(text.rebuild(false)._rebuild).toBeFalsy()\r\n    })\r\n    it('enables the rebuild if called with true', function() {\r\n      expect(text.rebuild(true)._rebuild).toBeTruthy()\r\n    })\r\n    it('rebuilds the text without an argument given', function() {\r\n      var dy = text.lines().get(2).attr('dy')\r\n      text.leading(1.7)\r\n      expect(dy == text.lines().get(2).attr('dy')).toBeFalsy()\r\n    })\r\n  })\r\n\r\n  describe('x()', function() {\r\n    it('returns the value of x without an argument', function() {\r\n      expect(text.x()).toBe(0)\r\n    })\r\n    it('sets the value of x with the first argument', function() {\r\n      text.x(123)\r\n      expect(text.node.getAttribute('x')).toBeCloseTo(123)\r\n    })\r\n    it('sets the value of all lines', function() {\r\n      text.x(200)\r\n      text.lines().each(function() {\r\n        expect(this.x()).toBe(200)\r\n      })\r\n    })\r\n    it('sets the value of y with a percent value', function() {\r\n      text.x('40%')\r\n      expect(text.node.getAttribute('x')).toBe('40%')\r\n    })\r\n    it('returns the value of x when x is a percentual value', function() {\r\n      expect(text.x('45%').x()).toBe('45%')\r\n    })\r\n    // Woow this test is old. The functionality not even implemented anymore\r\n    // Was a good feature. Maybe we add it back?\r\n    /*it('sets the value of x based on the anchor with the first argument', function() {\r\n      text.x(123, true)\r\n      var box = text.bbox()\r\n      expect(box.x).toBeCloseTo(123)\r\n    })*/\r\n  })\r\n\r\n  describe('y()', function() {\r\n    it('returns the value of y without an argument', function() {\r\n      expect(text.y(0).y()).toBeCloseTo(0)\r\n    })\r\n    it('returns the value of y when y is a percentual value', function() {\r\n      expect(text.y('45%').y()).toBe('45%')\r\n    })\r\n    it('sets the value of y with the first argument', function() {\r\n      text.y(345)\r\n      var box = text.bbox()\r\n      expect(box.y).toBe(345)\r\n    })\r\n    it('sets the value of y with a percent value', function() {\r\n      text.y('40%')\r\n      expect(text.node.getAttribute('y')).toBe('40%')\r\n    })\r\n  })\r\n\r\n  describe('cx()', function() {\r\n    it('returns the value of cx without an argument', function() {\r\n      var box = text.bbox()\r\n      expect(text.cx()).toBeCloseTo(box.x + box.width / 2)\r\n    })\r\n    it('sets the value of cx with the first argument', function() {\r\n      text.cx(123)\r\n      var box = text.bbox()\r\n      // this is a hack. it should be exactly 123 since you set it. But bbox with text is a thing...\r\n      expect(box.cx).toBeCloseTo(box.x + box.width/2)\r\n    })\r\n    // not implemented anymore\r\n    /*it('sets the value of cx based on the anchor with the first argument', function() {\r\n      text.cx(123, true)\r\n      var box = text.bbox()\r\n      expect(box.cx).toBeCloseTo(123)\r\n    })*/\r\n  })\r\n\r\n  describe('cy()', function() {\r\n    it('returns the value of cy without an argument', function() {\r\n      var box = text.bbox()\r\n      expect(text.cy()).toBe(box.cy)\r\n    })\r\n    it('sets the value of cy with the first argument', function() {\r\n      text.cy(345)\r\n      var box = text.bbox()\r\n      expect(Math.round(box.cy * 10) / 10).toBe(345)\r\n    })\r\n  })\r\n\r\n  describe('move()', function() {\r\n    it('sets the x and y position', function() {\r\n      text.move(123,456)\r\n      expect(text.node.getAttribute('x')).toBe('123')\r\n      expect(text.y()).toBeCloseTo(456)\r\n    })\r\n  })\r\n\r\n  describe('center()', function() {\r\n    it('sets the cx and cy position', function() {\r\n      text.center(321, 567)\r\n      var box = text.bbox()\r\n      expect(+text.node.getAttribute('x') + box.width / 2).toBeCloseTo(321, 1)\r\n      expect(text.y() + box.height / 2).toBeCloseTo(567)\r\n    })\r\n  })\r\n\r\n  describe('size()', function() {\r\n    it('should define the width and height of the element', function() {\r\n      text.size(50)\r\n      expect(text.attr('font-size').valueOf()).toBe(50)\r\n    })\r\n  })\r\n\r\n  describe('translate()', function() {\r\n    it('sets the translation of an element', function() {\r\n      text.transform({ x: 12, y: 12 })\r\n      expect(text.node.getAttribute('transform')).toBe('matrix(1,0,0,1,12,12)')\r\n    })\r\n  })\r\n\r\n  describe('text()', function() {\r\n    it('adds content in a nested tspan', function() {\r\n      text.text('It is a bear!')\r\n      expect(text.node.childNodes[0].nodeType).toBe(1)\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('It is a bear!')\r\n    })\r\n    it('adds content in a nested tspan even with an empty string', function() {\r\n      text.text('')\r\n      expect(text.node.childNodes[0].nodeType).toBe(1)\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('')\r\n    })\r\n    it('creates multiple lines with a newline separated string', function() {\r\n      text.text('It is\\nJUST\\na bear!')\r\n      expect(text.node.childNodes.length).toBe(3)\r\n    })\r\n    it('restores the content from the dom', function() {\r\n      text.text('It is\\nJUST\\na bear!')\r\n      expect(text.text()).toBe('It is\\nJUST\\na bear!')\r\n    })\r\n    it('gets the given content of a text element without an argument', function() {\r\n      text.text('It is another bear!')\r\n      expect(text.node.childNodes[0].nodeType).toBe(1)\r\n      expect(text.text()).toMatch('It is another bear!')\r\n    })\r\n    it('accepts a block as first arguments', function() {\r\n      text.text(function(add) {\r\n        add.tspan('mastaba')\r\n        add.plain('hut')\r\n      })\r\n      expect(text.node.childNodes[0].nodeType).toBe(1)\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('mastaba')\r\n      expect(text.node.childNodes[1].nodeType).toBe(3)\r\n      expect(text.node.childNodes[1].data).toBe('hut')\r\n    })\r\n  })\r\n\r\n  describe('plain()', function() {\r\n    it('adds content without a tspan', function() {\r\n      text.plain('It is a bear!')\r\n      expect(text.node.childNodes[0].nodeType).toBe(3)\r\n      expect(text.node.childNodes[0].data).toBe('It is a bear!')\r\n    })\r\n    it('clears content before adding new content', function() {\r\n      text.plain('It is not a bear!')\r\n      expect(text.node.childNodes.length).toBe(1)\r\n      expect(text.node.childNodes[0].data).toBe('It is not a bear!')\r\n    })\r\n    it('restores the content from the dom', function() {\r\n      text.plain('Just plain text!')\r\n      expect(text.text()).toBe('Just plain text!')\r\n    })\r\n  })\r\n\r\n  describe('tspan()', function() {\r\n    it('adds content in a tspan', function() {\r\n      text.tspan('It is a bear!')\r\n      expect(text.node.childNodes[0].nodeType).toBe(1)\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('It is a bear!')\r\n    })\r\n    it('clears content before adding new content', function() {\r\n      text.tspan('It is not a bear!')\r\n      expect(text.node.childNodes.length).toBe(1)\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('It is not a bear!')\r\n    })\r\n  })\r\n\r\n  describe('clear()', function() {\r\n    it('removes all content', function() {\r\n      text.text(function(add) {\r\n        add.tspan('The first.')\r\n        add.tspan('The second.')\r\n        add.tspan('The third.')\r\n      })\r\n      expect(text.node.childNodes.length).toBe(3)\r\n      text.clear()\r\n      expect(text.node.childNodes.length).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('lines()', function() {\r\n    it('gets an array of individual lines as an instance of SVG.Set', function() {\r\n      var l1, l2, l3\r\n      text.text(function(add) {\r\n        l1 = add.tspan('The first.')\r\n        l2 = add.tspan('The second.')\r\n        l3 = add.tspan('The third.')\r\n      })\r\n      expect(text.lines().length()).toBe(3)\r\n      expect(text.lines().get(0)).toBe(l1)\r\n      expect(text.lines().get(1)).toBe(l2)\r\n      expect(text.lines().get(2)).toBe(l3)\r\n    })\r\n  })\r\n\r\n  describe('length()', function() {\r\n    it('gets total length of text', function() {\r\n      text.text(function(add) {\r\n        add.tspan('The first.')\r\n        add.tspan('The second.')\r\n        add.tspan('The third.')\r\n      })\r\n      expect(text.length()).toBeCloseTo(text.lines().get(0).length() + text.lines().get(1).length() + text.lines().get(2).length(), 3)\r\n    })\r\n  })\r\n\r\n  describe('build()', function() {\r\n    it('enables adding multiple plain text nodes when given true', function() {\r\n      text.clear().build(true)\r\n      text.plain('A great piece!')\r\n      text.plain('Another great piece!')\r\n      expect(text.node.childNodes[0].data).toBe('A great piece!')\r\n      expect(text.node.childNodes[1].data).toBe('Another great piece!')\r\n    })\r\n    it('enables adding multiple tspan nodes when given true', function() {\r\n      text.clear().build(true)\r\n      text.tspan('A great piece!')\r\n      text.tspan('Another great piece!')\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('A great piece!')\r\n      expect(text.node.childNodes[1].childNodes[0].data).toBe('Another great piece!')\r\n    })\r\n    it('disables adding multiple plain text nodes when given false', function() {\r\n      text.clear().build(true)\r\n      text.plain('A great piece!')\r\n      text.build(false).plain('Another great piece!')\r\n      expect(text.node.childNodes[0].data).toBe('Another great piece!')\r\n      expect(text.node.childNodes[1]).toBe(undefined)\r\n    })\r\n    it('disables adding multiple tspan nodes when given false', function() {\r\n      text.clear().build(true)\r\n      text.tspan('A great piece!')\r\n      text.build(false).tspan('Another great piece!')\r\n      expect(text.node.childNodes[0].childNodes[0].data).toBe('Another great piece!')\r\n      expect(text.node.childNodes[1]).toBe(undefined)\r\n    })\r\n  })\r\n\r\n  describe('setData()', function() {\r\n    it('read all data from the svgjs:data attribute and assign it to el.dom', function(){\r\n\r\n      text.attr('svgjs:data', '{\"foo\":\"bar\",\"leading\":\"3px\"}')\r\n      text.setData(JSON.parse(text.attr('svgjs:data')))\r\n\r\n      expect(text.dom.foo).toBe('bar')\r\n      expect(text.dom.leading instanceof SVG.Number).toBeTruthy()\r\n      expect(text.dom.leading.value).toBe(3)\r\n      expect(text.dom.leading.unit).toBe('px')\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/textpath.js":"describe('TextPath', function() {\r\n  var text\r\n    , data = 'M 100 200 C 200 100 300  0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'\r\n\r\n  beforeEach(function() {\r\n    text = draw.text('We go up, then we go down, then up again')\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('path()', function() {\r\n    it('returns the text element', function() {\r\n      expect(text.path(data)).toBe(text)\r\n    })\r\n    it('creates a textPath node in the text element', function() {\r\n      text.path(data)\r\n      expect(text.node.firstChild.nodeName).toBe('textPath')\r\n    })\r\n  })\r\n\r\n  describe('textPath()', function() {\r\n    it('creates a reference to the textPath', function() {\r\n      expect(text.path(data).textPath() instanceof SVG.TextPath).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('track()', function() {\r\n    it('creates a reference to the path', function() {\r\n      expect(text.path(data).track() instanceof SVG.Path).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('array()', function() {\r\n    it('return the path array of the underlying path', function() {\r\n      expect(text.path(data).array()).toEqual(new SVG.PathArray(data))\r\n    })\r\n    it('return null if there is no underlying path', function () {\r\n      expect(text.array()).toBe(null)\r\n    })\r\n  })\r\n\r\n  describe('plot()', function() {\r\n    it('change the array of the underlying path when a string is passed', function() {\r\n      expect(text.path().plot(data)).toBe(text)\r\n      expect(text.array()).toEqual(new SVG.PathArray(data))\r\n    })\r\n    it('do nothing when a string is passed and there is no underlying path', function() {\r\n      expect(text.plot(data)).toBe(text)\r\n      expect(text.array()).toEqual(null)\r\n    })\r\n    it('return the path array of the underlying path when no arguments is passed', function () {\r\n      text.path(data)\r\n      expect(text.plot()).toBe(text.array())\r\n      expect(text.plot()).not.toBe(null)\r\n    })\r\n    it('return null when no arguments is passed and there is no underlying path', function () {\r\n      expect(text.plot()).toBe(null)\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/transformations.js":"describe('Transformations:', function() {\r\n  var translated, scaled, rotated, skewed\r\n\r\n  beforeEach(function() {\r\n    translated = draw.rect(100,100).translate(100,100)\r\n    scaled = draw.rect(100,100).scale(2)\r\n    rotated = draw.rect(100,100).rotate(45, 50, 50)\r\n    skewed = draw.rect(100,100).skew(30)\r\n  })\r\n\r\n  /* SVG.Transformation is not tested because it is an abstract prototype */\r\n\r\n  describe('SVG.Transformation', function() {\r\n    it('marks the transformation as inversed when inverse flag given', function() {\r\n      var trans = new SVG.Transformation([], true)\r\n      expect(trans.inversed).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('SVG.Translate', function() {\r\n    var trans\r\n    \r\n    beforeEach(function(){\r\n      trans = new SVG.Translate(translated.transform())\r\n    })\r\n  \r\n\r\n    it('creates an object of type SVG.Transformation', function() {\r\n      expect(trans instanceof SVG.Transformation).toBeTruthy()\r\n    })\r\n\r\n    it('uses transformedX and transformedY as arguments', function() {\r\n      expect(trans.arguments).toEqual(['transformedX', 'transformedY'])\r\n    })\r\n\r\n    it('s method is translate()', function() {\r\n      expect(trans.method).toEqual('translate')\r\n    })\r\n\r\n    it('sets the necessary parameters at creation', function() {\r\n      expect(trans.transformedX).toBe(100)\r\n      expect(trans.transformedY).toBe(100)\r\n    })\r\n\r\n    describe('undo', function() {\r\n      it('sets the undo matrix which can undo the translation', function() {\r\n        var extracted = (new SVG.Matrix(1,0,0,1,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.toString()).toEqual('matrix(1,0,0,1,-20,-20)')\r\n\r\n        var extracted = (new SVG.Matrix(10,0,0,10,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.toString()).toEqual('matrix(1,0,0,1,-2,-2)')\r\n        \r\n        var extracted = (new SVG.Matrix(10,50,50,30,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.e).toBeCloseTo(-extracted.transformedX)\r\n        expect(trans._undo.f).toBeCloseTo(-extracted.transformedY)\r\n      })\r\n    })\r\n\r\n    describe('at', function() {\r\n      it('creates a matrix at a certain position', function() {\r\n        expect(trans.at(0.3).toString()).toEqual('matrix(1,0,0,1,30,30)')\r\n      })\r\n      it('returns the inversed matrix from a specific position when created with inverse flag', function() {\r\n        expect((new SVG.Translate(translated.transform(), true)).at(0.3).toString()).toEqual('matrix(1,0,0,1,-30,-30)')\r\n      })\r\n      it('returns the resulting transformation which has to be made to set an absolute translation', function() {\r\n        trans.undo(new SVG.Matrix(10,50,50,30,20,20).extract())\r\n\r\n        expect(trans.at(0.4).a).toEqual(1)\r\n        expect(trans.at(0.4).b).toEqual(0)\r\n        expect(trans.at(0.4).c).toEqual(0)\r\n        expect(trans.at(0.4).d).toEqual(1)\r\n        expect(trans.at(0.4).e).toBeCloseTo(100 * 0.4 + trans._undo.e * 0.4)\r\n        expect(trans.at(0.4).f).toBeCloseTo(100 * 0.4 + trans._undo.f * 0.4)\r\n      })\r\n    })\r\n  })\r\n  \r\n  describe('SVG.Rotate', function() {\r\n    var trans\r\n    \r\n    beforeEach(function(){\r\n      trans = new SVG.Rotate(45, 50, 50)\r\n    })\r\n  \r\n\r\n    it('creates an object of type SVG.Transformation', function() {\r\n      expect(trans instanceof SVG.Transformation).toBeTruthy()\r\n    })\r\n\r\n    it('uses rotation, cx and cy as arguments', function() {\r\n      expect(trans.arguments).toEqual(['rotation', 'cx', 'cy'])\r\n    })\r\n\r\n    it('s method is rotate()', function() {\r\n      expect(trans.method).toEqual('rotate')\r\n    })\r\n\r\n    it('sets the necessary parameters at creation', function() {\r\n      expect(trans.rotation).toBe(45)\r\n      expect(trans.cx).toBe(50)\r\n      expect(trans.cy).toBe(50)\r\n    })\r\n\r\n    describe('undo', function() {\r\n      it('sets an undo object which holds rotation', function() {\r\n        var extracted = (new SVG.Matrix(1,0,0,1,0,0)).rotate(20, 50, 50).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.rotation).toBeCloseTo(20)\r\n      })\r\n    })\r\n\r\n    describe('at', function() {\r\n      it('creates a matrix at a certain position', function() {\r\n        expect(trans.at(0.3).toString()).toEqual((new SVG.Matrix()).rotate(0.3 * 45, 50, 50).toString())\r\n      })\r\n      it('returns the resulting transformation which has to be made to set an absolute translation', function() {\r\n        trans.undo((new SVG.Matrix()).rotate(20, 50, 50).extract())\r\n\r\n        expect(trans.at(0.4).a).toBeCloseTo(1,1)\r\n        expect(trans.at(0.4).b).toEqual(jasmine.any(Number))\r\n        expect(trans.at(0.4).c).toEqual(jasmine.any(Number))\r\n        expect(trans.at(0.4).d).toBeCloseTo(1,1)\r\n        expect(trans.at(0.4).e).toEqual(jasmine.any(Number))\r\n        expect(trans.at(0.4).f).toEqual(jasmine.any(Number))\r\n      })\r\n    })\r\n  })\r\n  \r\n\r\n  describe('SVG.Scale', function() {\r\n    var trans\r\n    \r\n    beforeEach(function(){\r\n      trans = new SVG.Scale(2,2,50,50)\r\n    })\r\n  \r\n\r\n    it('creates an object of type SVG.Transformation', function() {\r\n      expect(trans instanceof SVG.Transformation).toBeTruthy()\r\n    })\r\n\r\n    it('uses scaleX, scaleY, cx and cy as arguments', function() {\r\n      expect(trans.arguments).toEqual(['scaleX', 'scaleY', 'cx', 'cy'])\r\n    })\r\n\r\n    it('s method is scale()', function() {\r\n      expect(trans.method).toEqual('scale')\r\n    })\r\n\r\n    it('sets the necessary parameters at creation', function() {\r\n      expect(trans.scaleX).toBe(2)\r\n      expect(trans.scaleY).toBe(2)\r\n      expect(trans.cx).toBe(50)\r\n      expect(trans.cy).toBe(50)\r\n    })\r\n\r\n    describe('undo', function() {\r\n      it('sets the undo matrix which can undo the translation', function() {\r\n        var extracted = (new SVG.Matrix(4,0,0,4,0,0)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.toString()).toEqual('matrix(0.25,0,0,0.25,37.5,37.5)')\r\n\r\n        var extracted = (new SVG.Matrix(10,0,0,10,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.a).toBeCloseTo(1/extracted.scaleX)\r\n        expect(trans._undo.d).toBeCloseTo(1/extracted.scaleY)\r\n        expect(trans._undo.e).toBeCloseTo(45)\r\n        expect(trans._undo.f).toBeCloseTo(45)\r\n        \r\n        var extracted = (new SVG.Matrix(10,50,50,30,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.a).toBeCloseTo(1/extracted.scaleX)\r\n        expect(trans._undo.d).toBeCloseTo(1/extracted.scaleY)\r\n      })\r\n    })\r\n\r\n    describe('at', function() {\r\n      it('creates a matrix at a certain position', function() {\r\n        expect(trans.at(0.75).toString()).toEqual('matrix(1.75,0,0,1.75,-37.5,-37.5)')\r\n      })\r\n      it('returns the inversed matrix from a specific position when created with inverse flag', function() {\r\n        var morphed = (new SVG.Scale(scaled.transform(2,2,50,50), true)).at(0.25)\r\n        \r\n        expect(morphed.a).toBeCloseTo(0.8)\r\n        expect(morphed.d).toBeCloseTo(0.8)\r\n      })\r\n      it('returns the resulting transformation which has to be made to set an absolute translation', function() {\r\n        \r\n        var morphed = trans.undo((new SVG.Matrix(10,0,0,10,0,0)).extract()).at(0.5)\r\n\r\n        expect(morphed.a).toBeCloseTo(0.6)\r\n        expect(morphed.b).toEqual(0)\r\n        expect(morphed.c).toEqual(0)\r\n        expect(morphed.d).toBeCloseTo(0.6)\r\n        expect(morphed.e).toBeCloseTo(20)\r\n        expect(morphed.f).toBeCloseTo(20)\r\n      })\r\n    })\r\n  })  \r\n\r\n  describe('SVG.Skew', function() {\r\n    var trans\r\n    \r\n    beforeEach(function(){\r\n      trans = new SVG.Skew(30,-30,50,50)\r\n    })\r\n  \r\n\r\n    it('creates an object of type SVG.Transformation', function() {\r\n      expect(trans instanceof SVG.Transformation).toBeTruthy()\r\n    })\r\n\r\n    it('uses scaleX, scaleY, cx and cy as arguments', function() {\r\n      expect(trans.arguments).toEqual(['skewX', 'skewY', 'cx', 'cy'])\r\n    })\r\n\r\n    it('s method is skew()', function() {\r\n      expect(trans.method).toEqual('skew')\r\n    })\r\n\r\n    it('sets the necessary parameters at creation', function() {\r\n      expect(trans.skewX).toBe(30)\r\n      expect(trans.skewY).toBe(-30)\r\n      expect(trans.cx).toBe(50)\r\n      expect(trans.cy).toBe(50)\r\n    })\r\n\r\n    describe('undo', function() {\r\n      it('sets the undo matrix which can undo the translation', function() {\r\n        var extracted = (new SVG.Matrix()).skew(90, 90, 0, 0).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.a).toBeCloseTo(0)\r\n        expect(trans._undo.b).toBeCloseTo(0)\r\n        expect(trans._undo.c).toBeCloseTo(0)\r\n        expect(trans._undo.d).toBeCloseTo(0)\r\n        expect(trans._undo.e).toBeCloseTo(50)\r\n        expect(trans._undo.f).toBeCloseTo(50)\r\n\r\n        var extracted = (new SVG.Matrix(10,0,0,10,20,20)).extract()\r\n        trans.undo(extracted)\r\n        expect(trans._undo.a).toBeCloseTo(1)\r\n        expect(trans._undo.b).toBeCloseTo(0)\r\n        expect(trans._undo.c).toBeCloseTo(0)\r\n        expect(trans._undo.d).toBeCloseTo(1)\r\n        expect(trans._undo.e).toBeCloseTo(0)\r\n        expect(trans._undo.f).toBeCloseTo(0)\r\n      })\r\n    })\r\n\r\n    describe('at', function() {\r\n      it('creates a matrix at a certain position', function() {\r\n        expect(trans.at(0.75)).toEqual((new SVG.Matrix()).morph((new SVG.Matrix()).skew(30, -30, 50, 50)).at(0.75))\r\n      })\r\n      it('returns the inversed matrix from a specific position when created with inverse flag', function() {\r\n        var morphed = (new SVG.Scale(skewed.transform(20,-20,50,50), true)).at(0.25)\r\n        \r\n        expect(morphed.a).toBeCloseTo(0.963)\r\n        expect(morphed.b).toBeCloseTo(0)\r\n        expect(morphed.c).toBeCloseTo(0)\r\n        expect(morphed.d).toBeCloseTo(0.963)\r\n        expect(morphed.e).toBeCloseTo(0)\r\n        expect(morphed.f).toBeCloseTo(0)\r\n      })\r\n      it('returns the resulting transformation which has to be made to set an absolute translation', function() {\r\n        \r\n        var morphed = trans.undo((new SVG.Matrix(10,0,0,10,0,0)).skew(20, 30, 20, 10).extract()).at(0.5)\r\n\r\n        expect(morphed.a).toBeCloseTo(1.266)\r\n        expect(morphed.b).toBeCloseTo(-0.7310)\r\n        expect(morphed.c).toBeCloseTo(0.1351)\r\n        expect(morphed.d).toBeCloseTo(0.9220)\r\n        expect(morphed.e).toBeCloseTo(-20.05593)\r\n        expect(morphed.f).toBeCloseTo(40.4468)\r\n      })\r\n    })\r\n  })\r\n\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/tspan.js":"describe('Tspan', function() {\r\n  var text, tspan\r\n\r\n  beforeEach(function() {\r\n    text = draw.text(loremIpsum)\r\n    tspan = text.tspan('Hello World')\r\n  })\r\n\r\n  afterEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('newLine()', function() {\r\n    it('converts the tspan to a line', function() {\r\n      tspan = text.tspan('Hello World')\r\n      expect(tspan.newLine().dom.newLined).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  describe('text()', function() {\r\n    it('returns the text of the tspan without newline when not newlined', function() {\r\n      tspan = text.tspan('Hello World')\r\n      expect(tspan.text()).toBe('Hello World')\r\n    })\r\n    it('returns the text of the tspan with newline when newlined', function() {\r\n      tspan = text.tspan('Hello World').newLine()\r\n      expect(tspan.text()).toBe('Hello World\\n')\r\n    })\r\n    it('calls the function when function given', function() {\r\n      var spy = jasmine.createSpy('dummy')\r\n      tspan = text.tspan('Hello World')\r\n      tspan.text(spy)\r\n      expect(spy).toHaveBeenCalledWith(tspan)\r\n    })\r\n  })\r\n\r\n  describe('dx()', function() {\r\n    it('gets the dx value with no argument', function() {\r\n      tspan.attr('dx', 25)\r\n      expect(tspan.dx()).toBe(25)\r\n    })\r\n    it('sets the dx value whith the first argument', function() {\r\n      expect(tspan.dx(25).attr('dx')).toBe(25)\r\n    })\r\n  })\r\n})\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/use.js":"describe('Use', function() {\r\n  var use\r\n\r\n  describe('on a container element', function() {\r\n    var rect\r\n\r\n    beforeEach(function() {\r\n      rect = draw.rect(100,100)\r\n      use = draw.use(rect)\r\n    })\r\n\r\n    it('creates an instance of SVG.Use', function() {\r\n      expect(use instanceof SVG.Use).toBe(true)\r\n    })\r\n\r\n    it('sets the target element id to its href attribute', function() {\r\n      expect(use.node.getAttributeNS(SVG.xlink, 'href')).toBe('#' + rect)\r\n    })\r\n\r\n    it('adopts the geometry of the target element', function() {\r\n      expect(use.bbox()).toEqual(rect.bbox())\r\n    })\r\n  })\r\n\r\n  describe('on an external path', function() {\r\n    var file = 'http://upload.wikimedia.org/wikipedia/commons/8/84/Example.svg'\r\n      , id = 'flowRoot1882'\r\n\r\n    beforeEach(function() {\r\n      use = draw.use(id, file)\r\n    })\r\n\r\n    it('creates an instance of SVG.Use', function() {\r\n      expect(use instanceof SVG.Use).toBe(true)\r\n    })\r\n\r\n    it('sets the target element id and file path to its href attribute', function() {\r\n      expect(use.node.getAttributeNS(SVG.xlink, 'href')).toBe(file + '#' + id)\r\n    })\r\n\r\n  })\r\n  \r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/utils.js":"describe('SVG.utils', function() {\r\n  describe('degrees()', function() {\r\n    it('converts radiant to degrees', function() {\r\n      expect(SVG.utils.degrees(Math.PI)).toBe(180)\r\n    })\r\n    it('maps to 0 - 360 degree only', function() {\r\n      expect(SVG.utils.degrees(2.5 * Math.PI)).toBe(90)\r\n    })\r\n  })\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/spec/viewbox.js":"describe('Viewbox', function() {\r\n  var viewbox\r\n\r\n  beforeEach(function() {\r\n    draw.clear()\r\n  })\r\n\r\n  describe('initialization', function() {\r\n\r\n\r\n    it('creates a new viewbox with default values', function() {\r\n      viewbox = new SVG.ViewBox()\r\n\r\n      expect(viewbox.x).toBe(0)\r\n      expect(viewbox.y).toBe(0)\r\n      expect(viewbox.width).toBe(0)\r\n      expect(viewbox.height).toBe(0)\r\n    })\r\n\r\n\r\n\r\n    it('creates a new viewbox from parsed string', function() {\r\n      viewbox = new SVG.ViewBox('10. 100 200 300')\r\n\r\n      expect(viewbox.x).toBe(10)\r\n      expect(viewbox.y).toBe(100)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(300)\r\n    })\r\n\r\n\r\n\r\n    it('creates a new viewbox from array', function() {\r\n      viewbox = new SVG.ViewBox([10, 100, 200, 300])\r\n\r\n      expect(viewbox.x).toBe(10)\r\n      expect(viewbox.y).toBe(100)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(300)\r\n    })\r\n\r\n\r\n\r\n    it('creates a new viewbox from object', function() {\r\n      viewbox = new SVG.ViewBox({x:10, y:100, width:200, height:300})\r\n\r\n      expect(viewbox.x).toBe(10)\r\n      expect(viewbox.y).toBe(100)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(300)\r\n    })\r\n\r\n\r\n\r\n    it('creates a new viewbox from 4 arguments given', function() {\r\n      viewbox = new SVG.ViewBox(10, 100, 200, 300)\r\n\r\n      expect(viewbox.x).toBe(10)\r\n      expect(viewbox.y).toBe(100)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(300)\r\n    })\r\n\r\n\r\n    it('creates a new viewbox from parsed string with exponential values', function() {\r\n      viewbox = new SVG.ViewBox('-1.12e1 1e-2 +2e2 +.3e+4')\r\n\r\n      expect(viewbox.x).toBe(-11.2)\r\n      expect(viewbox.y).toBe(0.01)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(3000)\r\n    })\r\n\r\n    it('creates a new viewbox with element given', function() {\r\n      draw.attr('viewBox', '-1.12e1 1e-2 +2e2 +.3e+4')\r\n      viewbox = new SVG.ViewBox(draw)\r\n\r\n      expect(viewbox.x).toBe(-11.2)\r\n      expect(viewbox.y).toBe(0.01)\r\n      expect(viewbox.width).toBe(200)\r\n      expect(viewbox.height).toBe(3000)\r\n    })\r\n\r\n  })\r\n\r\n\r\n  describe('viewbox()', function() {\r\n\r\n    beforeEach(function() {\r\n      draw.attr('viewBox', null)\r\n    })\r\n    afterEach(function() {\r\n      draw.attr('viewBox', null)\r\n    })\r\n\r\n    it('should set the viewbox when four arguments are provided', function() {\r\n      draw.viewbox(0,0,100,100)\r\n      expect(draw.node.getAttribute('viewBox')).toBe('0 0 100 100')\r\n    })\r\n    it('should set the viewbox when an object is provided as first argument', function() {\r\n      draw.viewbox({ x: 0, y: 0, width: 50, height: 50 })\r\n      expect(draw.node.getAttribute('viewBox')).toBe('0 0 50 50')\r\n    })\r\n    it('should set the viewbox when a string is provided as first argument', function() {\r\n      draw.viewbox('0 0 50 50')\r\n      expect(draw.node.getAttribute('viewBox')).toBe('0 0 50 50')\r\n    })\r\n    it('should set the viewbox when an array is provided as first argument', function() {\r\n      draw.viewbox([0, 0, 50, 50])\r\n      expect(draw.node.getAttribute('viewBox')).toBe('0 0 50 50')\r\n    })\r\n    it('should accept negative values', function() {\r\n      draw.size(100,100).viewbox(-100, -100, 50, 50)\r\n      expect(draw.node.getAttribute('viewBox')).toEqual('-100 -100 50 50')\r\n    })\r\n    it('should get the viewbox if no arguments are given', function() {\r\n      draw.viewbox(0, 0, 100, 100)\r\n      expect(draw.viewbox()).toEqual(new SVG.ViewBox(draw))\r\n    })\r\n    it('should define the zoom of the viewbox in relation to the canvas size', function() {\r\n      draw.size(100,100).viewbox(0,0,50,50)\r\n      expect(draw.viewbox().zoom).toEqual(100 / 50)\r\n    })\r\n\r\n  })\r\n\r\n  describe('morph()', function() {\r\n    it('stores a given viewbox for morphing', function() {\r\n      var viewbox1 = new SVG.ViewBox(10, 100, 200, 300)\r\n        , viewbox2 = new SVG.ViewBox(50, -100, 300, 300)\r\n\r\n      viewbox1.morph(viewbox2)\r\n\r\n      expect(viewbox1.destination).toEqual(viewbox2)\r\n    })\r\n    it('stores a clone, not the given viewbox itself', function() {\r\n      var viewbox1 = new SVG.ViewBox(10, 100, 200, 300)\r\n        , viewbox2 = new SVG.ViewBox(50, -100, 300, 300)\r\n\r\n      viewbox1.morph(viewbox2)\r\n\r\n      expect(viewbox1.destination).not.toBe(viewbox2)\r\n    })\r\n  })\r\n\r\n  describe('at()', function() {\r\n    it('returns a morphed viewbox at a given position', function() {\r\n      var viewbox1 = new SVG.ViewBox(10, 100, 200, 300)\r\n        , viewbox2 = new SVG.ViewBox(50, -100, 300, 300)\r\n        , viewbox3 = viewbox1.morph(viewbox2).at(0.5)\r\n\r\n      expect(viewbox1.toString()).toBe('10 100 200 300')\r\n      expect(viewbox2.toString()).toBe('50 -100 300 300')\r\n      expect(viewbox3.toString()).toBe('30 0 250 300')\r\n    })\r\n    it('returns itself when no destination given', function() {\r\n      var viewbox = new SVG.ViewBox(10, 100, 200, 300)\r\n      expect(viewbox.at(0.5)).toBe(viewbox)\r\n    })\r\n  })\r\n\r\n})","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/lib/jasmine-2.5.2/boot.js":"/**\r\n Starting with version 2.0, this file \"boots\" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.\r\n\r\n If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.\r\n\r\n The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.\r\n\r\n [jasmine-gem]: http://github.com/pivotal/jasmine-gem\r\n */\r\n\r\n(function() {\r\n\r\n  /**\r\n   * ## Require &amp; Instantiate\r\n   *\r\n   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.\r\n   */\r\n  window.jasmine = jasmineRequire.core(jasmineRequire);\r\n\r\n  /**\r\n   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.\r\n   */\r\n  jasmineRequire.html(jasmine);\r\n\r\n  /**\r\n   * Create the Jasmine environment. This is used to run all specs in a project.\r\n   */\r\n  var env = jasmine.getEnv();\r\n\r\n  /**\r\n   * ## The Global Interface\r\n   *\r\n   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.\r\n   */\r\n  var jasmineInterface = jasmineRequire.interface(jasmine, env);\r\n\r\n  /**\r\n   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.\r\n   */\r\n  extend(window, jasmineInterface);\r\n\r\n  /**\r\n   * ## Runner Parameters\r\n   *\r\n   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.\r\n   */\r\n\r\n  var queryString = new jasmine.QueryString({\r\n    getWindowLocation: function() { return window.location; }\r\n  });\r\n\r\n  var catchingExceptions = queryString.getParam(\"catch\");\r\n  env.catchExceptions(typeof catchingExceptions === \"undefined\" ? true : catchingExceptions);\r\n\r\n  var throwingExpectationFailures = queryString.getParam(\"throwFailures\");\r\n  env.throwOnExpectationFailure(throwingExpectationFailures);\r\n\r\n  var random = queryString.getParam(\"random\");\r\n  env.randomizeTests(random);\r\n\r\n  var seed = queryString.getParam(\"seed\");\r\n  if (seed) {\r\n    env.seed(seed);\r\n  }\r\n\r\n  /**\r\n   * ## Reporters\r\n   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).\r\n   */\r\n  var htmlReporter = new jasmine.HtmlReporter({\r\n    env: env,\r\n    onRaiseExceptionsClick: function() { queryString.navigateWithNewParam(\"catch\", !env.catchingExceptions()); },\r\n    onThrowExpectationsClick: function() { queryString.navigateWithNewParam(\"throwFailures\", !env.throwingExpectationFailures()); },\r\n    onRandomClick: function() { queryString.navigateWithNewParam(\"random\", !env.randomTests()); },\r\n    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },\r\n    getContainer: function() { return document.body; },\r\n    createElement: function() { return document.createElement.apply(document, arguments); },\r\n    createTextNode: function() { return document.createTextNode.apply(document, arguments); },\r\n    timer: new jasmine.Timer()\r\n  });\r\n\r\n  /**\r\n   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.\r\n   */\r\n  env.addReporter(jasmineInterface.jsApiReporter);\r\n  env.addReporter(htmlReporter);\r\n\r\n  /**\r\n   * Filter which specs will be run by matching the start of the full name against the `spec` query param.\r\n   */\r\n  var specFilter = new jasmine.HtmlSpecFilter({\r\n    filterString: function() { return queryString.getParam(\"spec\"); }\r\n  });\r\n\r\n  env.specFilter = function(spec) {\r\n    return specFilter.matches(spec.getFullName());\r\n  };\r\n\r\n  /**\r\n   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.\r\n   */\r\n  window.setTimeout = window.setTimeout;\r\n  window.setInterval = window.setInterval;\r\n  window.clearTimeout = window.clearTimeout;\r\n  window.clearInterval = window.clearInterval;\r\n\r\n  /**\r\n   * ## Execution\r\n   *\r\n   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.\r\n   */\r\n  var currentWindowOnload = window.onload;\r\n\r\n  window.onload = function() {\r\n    if (currentWindowOnload) {\r\n      currentWindowOnload();\r\n    }\r\n    htmlReporter.initialize();\r\n    env.execute();\r\n  };\r\n\r\n  /**\r\n   * Helper function for readability above.\r\n   */\r\n  function extend(destination, source) {\r\n    for (var property in source) destination[property] = source[property];\r\n    return destination;\r\n  }\r\n\r\n}());\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/lib/jasmine-2.5.2/console.js":"/*\r\nCopyright (c) 2008-2016 Pivotal Labs\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\nfunction getJasmineRequireObj() {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    return exports;\r\n  } else {\r\n    window.jasmineRequire = window.jasmineRequire || {};\r\n    return window.jasmineRequire;\r\n  }\r\n}\r\n\r\ngetJasmineRequireObj().console = function(jRequire, j$) {\r\n  j$.ConsoleReporter = jRequire.ConsoleReporter();\r\n};\r\n\r\ngetJasmineRequireObj().ConsoleReporter = function() {\r\n\r\n  var noopTimer = {\r\n    start: function(){},\r\n    elapsed: function(){ return 0; }\r\n  };\r\n\r\n  function ConsoleReporter(options) {\r\n    var print = options.print,\r\n      showColors = options.showColors || false,\r\n      onComplete = options.onComplete || function() {},\r\n      timer = options.timer || noopTimer,\r\n      specCount,\r\n      failureCount,\r\n      failedSpecs = [],\r\n      pendingCount,\r\n      ansi = {\r\n        green: '\\x1B[32m',\r\n        red: '\\x1B[31m',\r\n        yellow: '\\x1B[33m',\r\n        none: '\\x1B[0m'\r\n      },\r\n      failedSuites = [];\r\n\r\n    print('ConsoleReporter is deprecated and will be removed in a future version.');\r\n\r\n    this.jasmineStarted = function() {\r\n      specCount = 0;\r\n      failureCount = 0;\r\n      pendingCount = 0;\r\n      print('Started');\r\n      printNewline();\r\n      timer.start();\r\n    };\r\n\r\n    this.jasmineDone = function() {\r\n      printNewline();\r\n      for (var i = 0; i < failedSpecs.length; i++) {\r\n        specFailureDetails(failedSpecs[i]);\r\n      }\r\n\r\n      if(specCount > 0) {\r\n        printNewline();\r\n\r\n        var specCounts = specCount + ' ' + plural('spec', specCount) + ', ' +\r\n          failureCount + ' ' + plural('failure', failureCount);\r\n\r\n        if (pendingCount) {\r\n          specCounts += ', ' + pendingCount + ' pending ' + plural('spec', pendingCount);\r\n        }\r\n\r\n        print(specCounts);\r\n      } else {\r\n        print('No specs found');\r\n      }\r\n\r\n      printNewline();\r\n      var seconds = timer.elapsed() / 1000;\r\n      print('Finished in ' + seconds + ' ' + plural('second', seconds));\r\n      printNewline();\r\n\r\n      for(i = 0; i < failedSuites.length; i++) {\r\n        suiteFailureDetails(failedSuites[i]);\r\n      }\r\n\r\n      onComplete(failureCount === 0);\r\n    };\r\n\r\n    this.specDone = function(result) {\r\n      specCount++;\r\n\r\n      if (result.status == 'pending') {\r\n        pendingCount++;\r\n        print(colored('yellow', '*'));\r\n        return;\r\n      }\r\n\r\n      if (result.status == 'passed') {\r\n        print(colored('green', '.'));\r\n        return;\r\n      }\r\n\r\n      if (result.status == 'failed') {\r\n        failureCount++;\r\n        failedSpecs.push(result);\r\n        print(colored('red', 'F'));\r\n      }\r\n    };\r\n\r\n    this.suiteDone = function(result) {\r\n      if (result.failedExpectations && result.failedExpectations.length > 0) {\r\n        failureCount++;\r\n        failedSuites.push(result);\r\n      }\r\n    };\r\n\r\n    return this;\r\n\r\n    function printNewline() {\r\n      print('\\n');\r\n    }\r\n\r\n    function colored(color, str) {\r\n      return showColors ? (ansi[color] + str + ansi.none) : str;\r\n    }\r\n\r\n    function plural(str, count) {\r\n      return count == 1 ? str : str + 's';\r\n    }\r\n\r\n    function repeat(thing, times) {\r\n      var arr = [];\r\n      for (var i = 0; i < times; i++) {\r\n        arr.push(thing);\r\n      }\r\n      return arr;\r\n    }\r\n\r\n    function indent(str, spaces) {\r\n      var lines = (str || '').split('\\n');\r\n      var newArr = [];\r\n      for (var i = 0; i < lines.length; i++) {\r\n        newArr.push(repeat(' ', spaces).join('') + lines[i]);\r\n      }\r\n      return newArr.join('\\n');\r\n    }\r\n\r\n    function specFailureDetails(result) {\r\n      printNewline();\r\n      print(result.fullName);\r\n\r\n      for (var i = 0; i < result.failedExpectations.length; i++) {\r\n        var failedExpectation = result.failedExpectations[i];\r\n        printNewline();\r\n        print(indent(failedExpectation.message, 2));\r\n        print(indent(failedExpectation.stack, 2));\r\n      }\r\n\r\n      printNewline();\r\n    }\r\n\r\n    function suiteFailureDetails(result) {\r\n      for (var i = 0; i < result.failedExpectations.length; i++) {\r\n        printNewline();\r\n        print(colored('red', 'An error was thrown in an afterAll'));\r\n        printNewline();\r\n        print(colored('red', 'AfterAll ' + result.failedExpectations[i].message));\r\n\r\n      }\r\n      printNewline();\r\n    }\r\n  }\r\n\r\n  return ConsoleReporter;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/lib/jasmine-2.5.2/jasmine-html.js":"/*\r\nCopyright (c) 2008-2016 Pivotal Labs\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\njasmineRequire.html = function(j$) {\r\n  j$.ResultsNode = jasmineRequire.ResultsNode();\r\n  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);\r\n  j$.QueryString = jasmineRequire.QueryString();\r\n  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();\r\n};\r\n\r\njasmineRequire.HtmlReporter = function(j$) {\r\n\r\n  var noopTimer = {\r\n    start: function() {},\r\n    elapsed: function() { return 0; }\r\n  };\r\n\r\n  function HtmlReporter(options) {\r\n    var env = options.env || {},\r\n      getContainer = options.getContainer,\r\n      createElement = options.createElement,\r\n      createTextNode = options.createTextNode,\r\n      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n      onRandomClick = options.onRandomClick || function() {},\r\n      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n      timer = options.timer || noopTimer,\r\n      results = [],\r\n      specsExecuted = 0,\r\n      failureCount = 0,\r\n      pendingSpecCount = 0,\r\n      htmlReporterMain,\r\n      symbols,\r\n      failedSuites = [];\r\n\r\n    this.initialize = function() {\r\n      clearPrior();\r\n      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n        createDom('div', {className: 'jasmine-banner'},\r\n          createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n          createDom('span', {className: 'jasmine-version'}, j$.version)\r\n        ),\r\n        createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n        createDom('div', {className: 'jasmine-alert'}),\r\n        createDom('div', {className: 'jasmine-results'},\r\n          createDom('div', {className: 'jasmine-failures'})\r\n        )\r\n      );\r\n      getContainer().appendChild(htmlReporterMain);\r\n    };\r\n\r\n    var totalSpecsDefined;\r\n    this.jasmineStarted = function(options) {\r\n      totalSpecsDefined = options.totalSpecsDefined || 0;\r\n      timer.start();\r\n    };\r\n\r\n    var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n    var topResults = new j$.ResultsNode({}, '', null),\r\n      currentParent = topResults;\r\n\r\n    this.suiteStarted = function(result) {\r\n      currentParent.addChild(result, 'suite');\r\n      currentParent = currentParent.last();\r\n    };\r\n\r\n    this.suiteDone = function(result) {\r\n      if (result.status == 'failed') {\r\n        failedSuites.push(result);\r\n      }\r\n\r\n      if (currentParent == topResults) {\r\n        return;\r\n      }\r\n\r\n      currentParent = currentParent.parent;\r\n    };\r\n\r\n    this.specStarted = function(result) {\r\n      currentParent.addChild(result, 'spec');\r\n    };\r\n\r\n    var failures = [];\r\n    this.specDone = function(result) {\r\n      if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n        console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n      }\r\n\r\n      if (result.status != 'disabled') {\r\n        specsExecuted++;\r\n      }\r\n\r\n      if (!symbols){\r\n        symbols = find('.jasmine-symbol-summary');\r\n      }\r\n\r\n      symbols.appendChild(createDom('li', {\r\n          className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n          id: 'spec_' + result.id,\r\n          title: result.fullName\r\n        }\r\n      ));\r\n\r\n      if (result.status == 'failed') {\r\n        failureCount++;\r\n\r\n        var failure =\r\n          createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n            createDom('div', {className: 'jasmine-description'},\r\n              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n            ),\r\n            createDom('div', {className: 'jasmine-messages'})\r\n          );\r\n        var messages = failure.childNodes[1];\r\n\r\n        for (var i = 0; i < result.failedExpectations.length; i++) {\r\n          var expectation = result.failedExpectations[i];\r\n          messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n          messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n        }\r\n\r\n        failures.push(failure);\r\n      }\r\n\r\n      if (result.status == 'pending') {\r\n        pendingSpecCount++;\r\n      }\r\n    };\r\n\r\n    this.jasmineDone = function(doneResult) {\r\n      var banner = find('.jasmine-banner');\r\n      var alert = find('.jasmine-alert');\r\n      var order = doneResult && doneResult.order;\r\n      alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n      banner.appendChild(\r\n        createDom('div', { className: 'jasmine-run-options' },\r\n          createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n          createDom('div', { className: 'jasmine-payload' },\r\n            createDom('div', { className: 'jasmine-exceptions' },\r\n              createDom('input', {\r\n                className: 'jasmine-raise',\r\n                id: 'jasmine-raise-exceptions',\r\n                type: 'checkbox'\r\n              }),\r\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n            createDom('div', { className: 'jasmine-throw-failures' },\r\n              createDom('input', {\r\n                className: 'jasmine-throw',\r\n                id: 'jasmine-throw-failures',\r\n                type: 'checkbox'\r\n              }),\r\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n            createDom('div', { className: 'jasmine-random-order' },\r\n              createDom('input', {\r\n                className: 'jasmine-random',\r\n                id: 'jasmine-random-order',\r\n                type: 'checkbox'\r\n              }),\r\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n          )\r\n        ));\r\n\r\n      var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n      raiseCheckbox.checked = !env.catchingExceptions();\r\n      raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n      var throwCheckbox = find('#jasmine-throw-failures');\r\n      throwCheckbox.checked = env.throwingExpectationFailures();\r\n      throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n      var randomCheckbox = find('#jasmine-random-order');\r\n      randomCheckbox.checked = env.randomTests();\r\n      randomCheckbox.onclick = onRandomClick;\r\n\r\n      var optionsMenu = find('.jasmine-run-options'),\r\n          optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n          optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n          isOpen = /\\bjasmine-open\\b/;\r\n\r\n      optionsTrigger.onclick = function() {\r\n        if (isOpen.test(optionsPayload.className)) {\r\n          optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n        } else {\r\n          optionsPayload.className += ' jasmine-open';\r\n        }\r\n      };\r\n\r\n      if (specsExecuted < totalSpecsDefined) {\r\n        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n        var skippedLink = order && order.random ? '?random=true' : '?';\r\n        alert.appendChild(\r\n          createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n            createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n          )\r\n        );\r\n      }\r\n      var statusBarMessage = '';\r\n      var statusBarClassName = 'jasmine-bar ';\r\n\r\n      if (totalSpecsDefined > 0) {\r\n        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n        statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n      } else {\r\n        statusBarClassName += 'jasmine-skipped';\r\n        statusBarMessage += 'No specs found';\r\n      }\r\n\r\n      var seedBar;\r\n      if (order && order.random) {\r\n        seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n          ', randomized with seed ',\r\n          createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n        );\r\n      }\r\n\r\n      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n      var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n      var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n      for(var i = 0; i < failedSuites.length; i++) {\r\n        var failedSuite = failedSuites[i];\r\n        for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n          alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n        }\r\n      }\r\n\r\n      var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n      for(i = 0; i < globalFailures.length; i++) {\r\n        var failure = globalFailures[i];\r\n        alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n      }\r\n\r\n      var results = find('.jasmine-results');\r\n      results.appendChild(summary);\r\n\r\n      summaryList(topResults, summary);\r\n\r\n      function summaryList(resultsTree, domParent) {\r\n        var specListNode;\r\n        for (var i = 0; i < resultsTree.children.length; i++) {\r\n          var resultNode = resultsTree.children[i];\r\n          if (resultNode.type == 'suite') {\r\n            var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n              createDom('li', {className: 'jasmine-suite-detail'},\r\n                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n              )\r\n            );\r\n\r\n            summaryList(resultNode, suiteListNode);\r\n            domParent.appendChild(suiteListNode);\r\n          }\r\n          if (resultNode.type == 'spec') {\r\n            if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n              specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n              domParent.appendChild(specListNode);\r\n            }\r\n            var specDescription = resultNode.result.description;\r\n            if(noExpectations(resultNode.result)) {\r\n              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n            }\r\n            if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n              specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n            }\r\n            specListNode.appendChild(\r\n              createDom('li', {\r\n                  className: 'jasmine-' + resultNode.result.status,\r\n                  id: 'spec-' + resultNode.result.id\r\n                },\r\n                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      if (failures.length) {\r\n        alert.appendChild(\r\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n            createDom('span', {}, 'Spec List | '),\r\n            createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n        alert.appendChild(\r\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n            createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n            createDom('span', {}, ' | Failures ')));\r\n\r\n        find('.jasmine-failures-menu').onclick = function() {\r\n          setMenuModeTo('jasmine-failure-list');\r\n        };\r\n        find('.jasmine-spec-list-menu').onclick = function() {\r\n          setMenuModeTo('jasmine-spec-list');\r\n        };\r\n\r\n        setMenuModeTo('jasmine-failure-list');\r\n\r\n        var failureNode = find('.jasmine-failures');\r\n        for (i = 0; i < failures.length; i++) {\r\n          failureNode.appendChild(failures[i]);\r\n        }\r\n      }\r\n    };\r\n\r\n    return this;\r\n\r\n    function find(selector) {\r\n      return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n    }\r\n\r\n    function clearPrior() {\r\n      // return the reporter\r\n      var oldReporter = find('');\r\n\r\n      if(oldReporter) {\r\n        getContainer().removeChild(oldReporter);\r\n      }\r\n    }\r\n\r\n    function createDom(type, attrs, childrenVarArgs) {\r\n      var el = createElement(type);\r\n\r\n      for (var i = 2; i < arguments.length; i++) {\r\n        var child = arguments[i];\r\n\r\n        if (typeof child === 'string') {\r\n          el.appendChild(createTextNode(child));\r\n        } else {\r\n          if (child) {\r\n            el.appendChild(child);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (var attr in attrs) {\r\n        if (attr == 'className') {\r\n          el[attr] = attrs[attr];\r\n        } else {\r\n          el.setAttribute(attr, attrs[attr]);\r\n        }\r\n      }\r\n\r\n      return el;\r\n    }\r\n\r\n    function pluralize(singular, count) {\r\n      var word = (count == 1 ? singular : singular + 's');\r\n\r\n      return '' + count + ' ' + word;\r\n    }\r\n\r\n    function specHref(result) {\r\n      return addToExistingQueryString('spec', result.fullName);\r\n    }\r\n\r\n    function seedHref(seed) {\r\n      return addToExistingQueryString('seed', seed);\r\n    }\r\n\r\n    function defaultQueryString(key, value) {\r\n      return '?' + key + '=' + value;\r\n    }\r\n\r\n    function setMenuModeTo(mode) {\r\n      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n    }\r\n\r\n    function noExpectations(result) {\r\n      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n        result.status === 'passed';\r\n    }\r\n  }\r\n\r\n  return HtmlReporter;\r\n};\r\n\r\njasmineRequire.HtmlSpecFilter = function() {\r\n  function HtmlSpecFilter(options) {\r\n    var filterString = options && options.filterString() && options.filterString().replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\r\n    var filterPattern = new RegExp(filterString);\r\n\r\n    this.matches = function(specName) {\r\n      return filterPattern.test(specName);\r\n    };\r\n  }\r\n\r\n  return HtmlSpecFilter;\r\n};\r\n\r\njasmineRequire.ResultsNode = function() {\r\n  function ResultsNode(result, type, parent) {\r\n    this.result = result;\r\n    this.type = type;\r\n    this.parent = parent;\r\n\r\n    this.children = [];\r\n\r\n    this.addChild = function(result, type) {\r\n      this.children.push(new ResultsNode(result, type, this));\r\n    };\r\n\r\n    this.last = function() {\r\n      return this.children[this.children.length - 1];\r\n    };\r\n  }\r\n\r\n  return ResultsNode;\r\n};\r\n\r\njasmineRequire.QueryString = function() {\r\n  function QueryString(options) {\r\n\r\n    this.navigateWithNewParam = function(key, value) {\r\n      options.getWindowLocation().search = this.fullStringWithNewParam(key, value);\r\n    };\r\n\r\n    this.fullStringWithNewParam = function(key, value) {\r\n      var paramMap = queryStringToParamMap();\r\n      paramMap[key] = value;\r\n      return toQueryString(paramMap);\r\n    };\r\n\r\n    this.getParam = function(key) {\r\n      return queryStringToParamMap()[key];\r\n    };\r\n\r\n    return this;\r\n\r\n    function toQueryString(paramMap) {\r\n      var qStrPairs = [];\r\n      for (var prop in paramMap) {\r\n        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));\r\n      }\r\n      return '?' + qStrPairs.join('&');\r\n    }\r\n\r\n    function queryStringToParamMap() {\r\n      var paramStr = options.getWindowLocation().search.substring(1),\r\n        params = [],\r\n        paramMap = {};\r\n\r\n      if (paramStr.length > 0) {\r\n        params = paramStr.split('&');\r\n        for (var i = 0; i < params.length; i++) {\r\n          var p = params[i].split('=');\r\n          var value = decodeURIComponent(p[1]);\r\n          if (value === 'true' || value === 'false') {\r\n            value = JSON.parse(value);\r\n          }\r\n          paramMap[decodeURIComponent(p[0])] = value;\r\n        }\r\n      }\r\n\r\n      return paramMap;\r\n    }\r\n\r\n  }\r\n\r\n  return QueryString;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-svg.js/node_modules/svg.js/spec/lib/jasmine-2.5.2/jasmine.js":"/*\r\nCopyright (c) 2008-2016 Pivotal Labs\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\nvar getJasmineRequireObj = (function (jasmineGlobal) {\r\n  var jasmineRequire;\r\n\r\n  if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {\r\n    if (typeof global !== 'undefined') {\r\n      jasmineGlobal = global;\r\n    } else {\r\n      jasmineGlobal = {};\r\n    }\r\n    jasmineRequire = exports;\r\n  } else {\r\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\r\n      jasmineGlobal = window;\r\n    }\r\n    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};\r\n  }\r\n\r\n  function getJasmineRequire() {\r\n    return jasmineRequire;\r\n  }\r\n\r\n  getJasmineRequire().core = function(jRequire) {\r\n    var j$ = {};\r\n\r\n    jRequire.base(j$, jasmineGlobal);\r\n    j$.util = jRequire.util();\r\n    j$.errors = jRequire.errors();\r\n    j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n    j$.Any = jRequire.Any(j$);\r\n    j$.Anything = jRequire.Anything(j$);\r\n    j$.CallTracker = jRequire.CallTracker(j$);\r\n    j$.MockDate = jRequire.MockDate();\r\n    j$.Clock = jRequire.Clock();\r\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n    j$.Env = jRequire.Env(j$);\r\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n    j$.Expectation = jRequire.Expectation();\r\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n    j$.JsApiReporter = jRequire.JsApiReporter();\r\n    j$.matchersUtil = jRequire.matchersUtil(j$);\r\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n    j$.pp = jRequire.pp(j$);\r\n    j$.QueueRunner = jRequire.QueueRunner(j$);\r\n    j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n    j$.Spec = jRequire.Spec(j$);\r\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n    j$.SpyStrategy = jRequire.SpyStrategy(j$);\r\n    j$.StringMatching = jRequire.StringMatching(j$);\r\n    j$.Suite = jRequire.Suite(j$);\r\n    j$.Timer = jRequire.Timer();\r\n    j$.TreeProcessor = jRequire.TreeProcessor();\r\n    j$.version = jRequire.version();\r\n    j$.Order = jRequire.Order();\r\n\r\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n    return j$;\r\n  };\r\n\r\n  return getJasmineRequire;\r\n})(this);\r\n\r\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\r\n  var availableMatchers = [\r\n      'toBe',\r\n      'toBeCloseTo',\r\n      'toBeDefined',\r\n      'toBeFalsy',\r\n      'toBeGreaterThan',\r\n      'toBeGreaterThanOrEqual',\r\n      'toBeLessThanOrEqual',\r\n      'toBeLessThan',\r\n      'toBeNaN',\r\n      'toBeNull',\r\n      'toBeTruthy',\r\n      'toBeUndefined',\r\n      'toContain',\r\n      'toEqual',\r\n      'toHaveBeenCalled',\r\n      'toHaveBeenCalledWith',\r\n      'toHaveBeenCalledTimes',\r\n      'toMatch',\r\n      'toThrow',\r\n      'toThrowError'\r\n    ],\r\n    matchers = {};\r\n\r\n  for (var i = 0; i < availableMatchers.length; i++) {\r\n    var name = availableMatchers[i];\r\n    matchers[name] = jRequire[name](j$);\r\n  }\r\n\r\n  return matchers;\r\n};\r\n\r\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\r\n  j$.unimplementedMethod_ = function() {\r\n    throw new Error('unimplemented method');\r\n  };\r\n\r\n  j$.MAX_PRETTY_PRINT_DEPTH = 40;\r\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\r\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\r\n\r\n  j$.getGlobal = function() {\r\n    return jasmineGlobal;\r\n  };\r\n\r\n  j$.getEnv = function(options) {\r\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\r\n    //jasmine. singletons in here (setTimeout blah blah).\r\n    return env;\r\n  };\r\n\r\n  j$.isArray_ = function(value) {\r\n    return j$.isA_('Array', value);\r\n  };\r\n\r\n  j$.isString_ = function(value) {\r\n    return j$.isA_('String', value);\r\n  };\r\n\r\n  j$.isNumber_ = function(value) {\r\n    return j$.isA_('Number', value);\r\n  };\r\n\r\n  j$.isFunction_ = function(value) {\r\n    return j$.isA_('Function', value);\r\n  };\r\n\r\n  j$.isA_ = function(typeName, value) {\r\n    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\r\n  };\r\n\r\n  j$.isDomNode = function(obj) {\r\n    return obj.nodeType > 0;\r\n  };\r\n\r\n  j$.fnNameFor = function(func) {\r\n    if (func.name) {\r\n      return func.name;\r\n    }\r\n\r\n    var matches = func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/);\r\n    return matches ? matches[1] : '<anonymous>';\r\n  };\r\n\r\n  j$.any = function(clazz) {\r\n    return new j$.Any(clazz);\r\n  };\r\n\r\n  j$.anything = function() {\r\n    return new j$.Anything();\r\n  };\r\n\r\n  j$.objectContaining = function(sample) {\r\n    return new j$.ObjectContaining(sample);\r\n  };\r\n\r\n  j$.stringMatching = function(expected) {\r\n    return new j$.StringMatching(expected);\r\n  };\r\n\r\n  j$.arrayContaining = function(sample) {\r\n    return new j$.ArrayContaining(sample);\r\n  };\r\n\r\n  j$.createSpy = function(name, originalFn) {\r\n\r\n    var spyStrategy = new j$.SpyStrategy({\r\n        name: name,\r\n        fn: originalFn,\r\n        getSpy: function() { return spy; }\r\n      }),\r\n      callTracker = new j$.CallTracker(),\r\n      spy = function() {\r\n        var callData = {\r\n          object: this,\r\n          args: Array.prototype.slice.apply(arguments)\r\n        };\r\n\r\n        callTracker.track(callData);\r\n        var returnValue = spyStrategy.exec.apply(this, arguments);\r\n        callData.returnValue = returnValue;\r\n\r\n        return returnValue;\r\n      };\r\n\r\n    for (var prop in originalFn) {\r\n      if (prop === 'and' || prop === 'calls') {\r\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\r\n      }\r\n\r\n      spy[prop] = originalFn[prop];\r\n    }\r\n\r\n    spy.and = spyStrategy;\r\n    spy.calls = callTracker;\r\n\r\n    return spy;\r\n  };\r\n\r\n  j$.isSpy = function(putativeSpy) {\r\n    if (!putativeSpy) {\r\n      return false;\r\n    }\r\n    return putativeSpy.and instanceof j$.SpyStrategy &&\r\n      putativeSpy.calls instanceof j$.CallTracker;\r\n  };\r\n\r\n  j$.createSpyObj = function(baseName, methodNames) {\r\n    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {\r\n      methodNames = baseName;\r\n      baseName = 'unknown';\r\n    }\r\n\r\n    if (!j$.isArray_(methodNames) || methodNames.length === 0) {\r\n      throw 'createSpyObj requires a non-empty array of method names to create spies for';\r\n    }\r\n    var obj = {};\r\n    for (var i = 0; i < methodNames.length; i++) {\r\n      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\r\n    }\r\n    return obj;\r\n  };\r\n};\r\n\r\ngetJasmineRequireObj().util = function() {\r\n\r\n  var util = {};\r\n\r\n  util.inherit = function(childClass, parentClass) {\r\n    var Subclass = function() {\r\n    };\r\n    Subclass.prototype = parentClass.prototype;\r\n    childClass.prototype = new Subclass();\r\n  };\r\n\r\n  util.htmlEscape = function(str) {\r\n    if (!str) {\r\n      return str;\r\n    }\r\n    return str.replace(/&/g, '&amp;')\r\n      .replace(/</g, '&lt;')\r\n      .replace(/>/g, '&gt;');\r\n  };\r\n\r\n  util.argsToArray = function(args) {\r\n    var arrayOfArgs = [];\r\n    for (var i = 0; i < args.length; i++) {\r\n      arrayOfArgs.push(args[i]);\r\n    }\r\n    return arrayOfArgs;\r\n  };\r\n\r\n  util.isUndefined = function(obj) {\r\n    return obj === void 0;\r\n  };\r\n\r\n  util.arrayContains = function(array, search) {\r\n    var i = array.length;\r\n    while (i--) {\r\n      if (array[i] === search) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n\r\n  util.clone = function(obj) {\r\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\r\n      return obj.slice();\r\n    }\r\n\r\n    var cloned = {};\r\n    for (var prop in obj) {\r\n      if (obj.hasOwnProperty(prop)) {\r\n        cloned[prop] = obj[prop];\r\n      }\r\n    }\r\n\r\n    return cloned;\r\n  };\r\n\r\n  return util;\r\n};\r\n\r\ngetJasmineRequireObj().Spec = function(j$) {\r\n  function Spec(attrs) {\r\n    this.expectationFactory = attrs.expectationFactory;\r\n    this.resultCallback = attrs.resultCallback || function() {};\r\n    this.id = attrs.id;\r\n    this.description = attrs.description || '';\r\n    this.queueableFn = attrs.queueableFn;\r\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n    this.userContext = attrs.userContext || function() { return {}; };\r\n    this.onStart = attrs.onStart || function() {};\r\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n    if (!this.queueableFn.fn) {\r\n      this.pend();\r\n    }\r\n\r\n    this.result = {\r\n      id: this.id,\r\n      description: this.description,\r\n      fullName: this.getFullName(),\r\n      failedExpectations: [],\r\n      passedExpectations: [],\r\n      pendingReason: ''\r\n    };\r\n  }\r\n\r\n  Spec.prototype.addExpectationResult = function(passed, data, isError) {\r\n    var expectationResult = this.expectationResultFactory(data);\r\n    if (passed) {\r\n      this.result.passedExpectations.push(expectationResult);\r\n    } else {\r\n      this.result.failedExpectations.push(expectationResult);\r\n\r\n      if (this.throwOnExpectationFailure && !isError) {\r\n        throw new j$.errors.ExpectationFailed();\r\n      }\r\n    }\r\n  };\r\n\r\n  Spec.prototype.expect = function(actual) {\r\n    return this.expectationFactory(actual, this);\r\n  };\r\n\r\n  Spec.prototype.execute = function(onComplete, enabled) {\r\n    var self = this;\r\n\r\n    this.onStart(this);\r\n\r\n    if (!this.isExecutable() || this.markedPending || enabled === false) {\r\n      complete(enabled);\r\n      return;\r\n    }\r\n\r\n    var fns = this.beforeAndAfterFns();\r\n    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n    this.queueRunnerFactory({\r\n      queueableFns: allFns,\r\n      onException: function() { self.onException.apply(self, arguments); },\r\n      onComplete: complete,\r\n      userContext: this.userContext()\r\n    });\r\n\r\n    function complete(enabledAgain) {\r\n      self.result.status = self.status(enabledAgain);\r\n      self.resultCallback(self.result);\r\n\r\n      if (onComplete) {\r\n        onComplete();\r\n      }\r\n    }\r\n  };\r\n\r\n  Spec.prototype.onException = function onException(e) {\r\n    if (Spec.isPendingSpecException(e)) {\r\n      this.pend(extractCustomPendingMessage(e));\r\n      return;\r\n    }\r\n\r\n    if (e instanceof j$.errors.ExpectationFailed) {\r\n      return;\r\n    }\r\n\r\n    this.addExpectationResult(false, {\r\n      matcherName: '',\r\n      passed: false,\r\n      expected: '',\r\n      actual: '',\r\n      error: e\r\n    }, true);\r\n  };\r\n\r\n  Spec.prototype.disable = function() {\r\n    this.disabled = true;\r\n  };\r\n\r\n  Spec.prototype.pend = function(message) {\r\n    this.markedPending = true;\r\n    if (message) {\r\n      this.result.pendingReason = message;\r\n    }\r\n  };\r\n\r\n  Spec.prototype.getResult = function() {\r\n    this.result.status = this.status();\r\n    return this.result;\r\n  };\r\n\r\n  Spec.prototype.status = function(enabled) {\r\n    if (this.disabled || enabled === false) {\r\n      return 'disabled';\r\n    }\r\n\r\n    if (this.markedPending) {\r\n      return 'pending';\r\n    }\r\n\r\n    if (this.result.failedExpectations.length > 0) {\r\n      return 'failed';\r\n    } else {\r\n      return 'passed';\r\n    }\r\n  };\r\n\r\n  Spec.prototype.isExecutable = function() {\r\n    return !this.disabled;\r\n  };\r\n\r\n  Spec.prototype.getFullName = function() {\r\n    return this.getSpecName(this);\r\n  };\r\n\r\n  var extractCustomPendingMessage = function(e) {\r\n    var fullMessage = e.toString(),\r\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\r\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\r\n\r\n    return fullMessage.substr(boilerplateEnd);\r\n  };\r\n\r\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\r\n\r\n  Spec.isPendingSpecException = function(e) {\r\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\r\n  };\r\n\r\n  return Spec;\r\n};\r\n\r\nif (typeof window == void 0 && typeof exports == 'object') {\r\n  exports.Spec = jasmineRequire.Spec;\r\n}\r\n\r\n/*jshint bitwise: false*/\r\n\r\ngetJasmineRequireObj().Order = function() {\r\n  function Order(options) {\r\n    this.random = 'random' in options ? options.random : true;\r\n    var seed = this.seed = options.seed || generateSeed();\r\n    this.sort = this.random ? randomOrder : naturalOrder;\r\n\r\n    function naturalOrder(items) {\r\n      return items;\r\n    }\r\n\r\n    function randomOrder(items) {\r\n      var copy = items.slice();\r\n      copy.sort(function(a, b) {\r\n        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\r\n      });\r\n      return copy;\r\n    }\r\n\r\n    function generateSeed() {\r\n      return String(Math.random()).slice(-5);\r\n    }\r\n\r\n    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\r\n    // used to get a different output when the key changes slighly.\r\n    // We use your return to sort the children randomly in a consistent way when\r\n    // used in conjunction with a seed\r\n\r\n    function jenkinsHash(key) {\r\n      var hash, i;\r\n      for(hash = i = 0; i < key.length; ++i) {\r\n        hash += key.charCodeAt(i);\r\n        hash += (hash << 10);\r\n        hash ^= (hash >> 6);\r\n      }\r\n      hash += (hash << 3);\r\n      hash ^= (hash >> 11);\r\n      hash += (hash << 15);\r\n      return hash;\r\n    }\r\n\r\n  }\r\n\r\n  return Order;\r\n};\r\n\r\ngetJasmineRequireObj().Env = function(j$) {\r\n  function Env(options) {\r\n    options = options || {};\r\n\r\n    var self = this;\r\n    var global = options.global || j$.getGlobal();\r\n\r\n    var totalSpecsDefined = 0;\r\n\r\n    var catchExceptions = true;\r\n\r\n    var realSetTimeout = j$.getGlobal().setTimeout;\r\n    var realClearTimeout = j$.getGlobal().clearTimeout;\r\n    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\r\n\r\n    var runnableResources = {};\r\n\r\n    var currentSpec = null;\r\n    var currentlyExecutingSuites = [];\r\n    var currentDeclarationSuite = null;\r\n    var throwOnExpectationFailure = false;\r\n    var random = false;\r\n    var seed = null;\r\n\r\n    var currentSuite = function() {\r\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n    };\r\n\r\n    var currentRunnable = function() {\r\n      return currentSpec || currentSuite();\r\n    };\r\n\r\n    var reporter = new j$.ReportDispatcher([\r\n      'jasmineStarted',\r\n      'jasmineDone',\r\n      'suiteStarted',\r\n      'suiteDone',\r\n      'specStarted',\r\n      'specDone'\r\n    ]);\r\n\r\n    this.specFilter = function() {\r\n      return true;\r\n    };\r\n\r\n    this.addCustomEqualityTester = function(tester) {\r\n      if(!currentRunnable()) {\r\n        throw new Error('Custom Equalities must be added in a before function or a spec');\r\n      }\r\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n    };\r\n\r\n    this.addMatchers = function(matchersToAdd) {\r\n      if(!currentRunnable()) {\r\n        throw new Error('Matchers must be added in a before function or a spec');\r\n      }\r\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n      for (var matcherName in matchersToAdd) {\r\n        customMatchers[matcherName] = matchersToAdd[matcherName];\r\n      }\r\n    };\r\n\r\n    j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n    var nextSpecId = 0;\r\n    var getNextSpecId = function() {\r\n      return 'spec' + nextSpecId++;\r\n    };\r\n\r\n    var nextSuiteId = 0;\r\n    var getNextSuiteId = function() {\r\n      return 'suite' + nextSuiteId++;\r\n    };\r\n\r\n    var expectationFactory = function(actual, spec) {\r\n      return j$.Expectation.Factory({\r\n        util: j$.matchersUtil,\r\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n        customMatchers: runnableResources[spec.id].customMatchers,\r\n        actual: actual,\r\n        addExpectationResult: addExpectationResult\r\n      });\r\n\r\n      function addExpectationResult(passed, result) {\r\n        return spec.addExpectationResult(passed, result);\r\n      }\r\n    };\r\n\r\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n      if(runnableResources[parentRunnableId]){\r\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n      }\r\n\r\n      runnableResources[id] = resources;\r\n    };\r\n\r\n    var clearResourcesForRunnable = function(id) {\r\n        spyRegistry.clearSpies();\r\n        delete runnableResources[id];\r\n    };\r\n\r\n    var beforeAndAfterFns = function(suite) {\r\n      return function() {\r\n        var befores = [],\r\n          afters = [];\r\n\r\n        while(suite) {\r\n          befores = befores.concat(suite.beforeFns);\r\n          afters = afters.concat(suite.afterFns);\r\n\r\n          suite = suite.parentSuite;\r\n        }\r\n\r\n        return {\r\n          befores: befores.reverse(),\r\n          afters: afters\r\n        };\r\n      };\r\n    };\r\n\r\n    var getSpecName = function(spec, suite) {\r\n      var fullName = [spec.description],\r\n          suiteFullName = suite.getFullName();\r\n\r\n      if (suiteFullName !== '') {\r\n        fullName.unshift(suiteFullName);\r\n      }\r\n      return fullName.join(' ');\r\n    };\r\n\r\n    // TODO: we may just be able to pass in the fn instead of wrapping here\r\n    var buildExpectationResult = j$.buildExpectationResult,\r\n        exceptionFormatter = new j$.ExceptionFormatter(),\r\n        expectationResultFactory = function(attrs) {\r\n          attrs.messageFormatter = exceptionFormatter.message;\r\n          attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n          return buildExpectationResult(attrs);\r\n        };\r\n\r\n    // TODO: fix this naming, and here's where the value comes in\r\n    this.catchExceptions = function(value) {\r\n      catchExceptions = !!value;\r\n      return catchExceptions;\r\n    };\r\n\r\n    this.catchingExceptions = function() {\r\n      return catchExceptions;\r\n    };\r\n\r\n    var maximumSpecCallbackDepth = 20;\r\n    var currentSpecCallbackDepth = 0;\r\n\r\n    function clearStack(fn) {\r\n      currentSpecCallbackDepth++;\r\n      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n        currentSpecCallbackDepth = 0;\r\n        realSetTimeout(fn, 0);\r\n      } else {\r\n        fn();\r\n      }\r\n    }\r\n\r\n    var catchException = function(e) {\r\n      return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n    };\r\n\r\n    this.throwOnExpectationFailure = function(value) {\r\n      throwOnExpectationFailure = !!value;\r\n    };\r\n\r\n    this.throwingExpectationFailures = function() {\r\n      return throwOnExpectationFailure;\r\n    };\r\n\r\n    this.randomizeTests = function(value) {\r\n      random = !!value;\r\n    };\r\n\r\n    this.randomTests = function() {\r\n      return random;\r\n    };\r\n\r\n    this.seed = function(value) {\r\n      if (value) {\r\n        seed = value;\r\n      }\r\n      return seed;\r\n    };\r\n\r\n    var queueRunnerFactory = function(options) {\r\n      options.catchException = catchException;\r\n      options.clearStack = options.clearStack || clearStack;\r\n      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n      options.fail = self.fail;\r\n\r\n      new j$.QueueRunner(options).execute();\r\n    };\r\n\r\n    var topSuite = new j$.Suite({\r\n      env: this,\r\n      id: getNextSuiteId(),\r\n      description: 'Jasmine__TopLevel__Suite',\r\n      expectationFactory: expectationFactory,\r\n      expectationResultFactory: expectationResultFactory\r\n    });\r\n    defaultResourcesForRunnable(topSuite.id);\r\n    currentDeclarationSuite = topSuite;\r\n\r\n    this.topSuite = function() {\r\n      return topSuite;\r\n    };\r\n\r\n    this.execute = function(runnablesToRun) {\r\n      if(!runnablesToRun) {\r\n        if (focusedRunnables.length) {\r\n          runnablesToRun = focusedRunnables;\r\n        } else {\r\n          runnablesToRun = [topSuite.id];\r\n        }\r\n      }\r\n\r\n      var order = new j$.Order({\r\n        random: random,\r\n        seed: seed\r\n      });\r\n\r\n      var processor = new j$.TreeProcessor({\r\n        tree: topSuite,\r\n        runnableIds: runnablesToRun,\r\n        queueRunnerFactory: queueRunnerFactory,\r\n        nodeStart: function(suite) {\r\n          currentlyExecutingSuites.push(suite);\r\n          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n          reporter.suiteStarted(suite.result);\r\n        },\r\n        nodeComplete: function(suite, result) {\r\n          if (!suite.disabled) {\r\n            clearResourcesForRunnable(suite.id);\r\n          }\r\n          currentlyExecutingSuites.pop();\r\n          reporter.suiteDone(result);\r\n        },\r\n        orderChildren: function(node) {\r\n          return order.sort(node.children);\r\n        }\r\n      });\r\n\r\n      if(!processor.processTree().valid) {\r\n        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\r\n      }\r\n\r\n      reporter.jasmineStarted({\r\n        totalSpecsDefined: totalSpecsDefined\r\n      });\r\n\r\n      currentlyExecutingSuites.push(topSuite);\r\n\r\n      processor.execute(function() {\r\n        clearResourcesForRunnable(topSuite.id);\r\n        currentlyExecutingSuites.pop();\r\n\r\n        reporter.jasmineDone({\r\n          order: order,\r\n          failedExpectations: topSuite.result.failedExpectations\r\n        });\r\n      });\r\n    };\r\n\r\n    this.addReporter = function(reporterToAdd) {\r\n      reporter.addReporter(reporterToAdd);\r\n    };\r\n\r\n    this.provideFallbackReporter = function(reporterToAdd) {\r\n      reporter.provideFallbackReporter(reporterToAdd);\r\n    };\r\n\r\n    this.clearReporters = function() {\r\n      reporter.clearReporters();\r\n    };\r\n\r\n    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n      if(!currentRunnable()) {\r\n        throw new Error('Spies must be created in a before function or a spec');\r\n      }\r\n      return runnableResources[currentRunnable().id].spies;\r\n    }});\r\n\r\n    this.allowRespy = function(allow){\r\n      spyRegistry.allowRespy(allow);\r\n    };\r\n\r\n    this.spyOn = function() {\r\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n    };\r\n\r\n    var suiteFactory = function(description) {\r\n      var suite = new j$.Suite({\r\n        env: self,\r\n        id: getNextSuiteId(),\r\n        description: description,\r\n        parentSuite: currentDeclarationSuite,\r\n        expectationFactory: expectationFactory,\r\n        expectationResultFactory: expectationResultFactory,\r\n        throwOnExpectationFailure: throwOnExpectationFailure\r\n      });\r\n\r\n      return suite;\r\n    };\r\n\r\n    this.describe = function(description, specDefinitions) {\r\n      var suite = suiteFactory(description);\r\n      if (specDefinitions.length > 0) {\r\n        throw new Error('describe does not expect any arguments');\r\n      }\r\n      if (currentDeclarationSuite.markedPending) {\r\n        suite.pend();\r\n      }\r\n      addSpecsToSuite(suite, specDefinitions);\r\n      return suite;\r\n    };\r\n\r\n    this.xdescribe = function(description, specDefinitions) {\r\n      var suite = suiteFactory(description);\r\n      suite.pend();\r\n      addSpecsToSuite(suite, specDefinitions);\r\n      return suite;\r\n    };\r\n\r\n    var focusedRunnables = [];\r\n\r\n    this.fdescribe = function(description, specDefinitions) {\r\n      var suite = suiteFactory(description);\r\n      suite.isFocused = true;\r\n\r\n      focusedRunnables.push(suite.id);\r\n      unfocusAncestor();\r\n      addSpecsToSuite(suite, specDefinitions);\r\n\r\n      return suite;\r\n    };\r\n\r\n    function addSpecsToSuite(suite, specDefinitions) {\r\n      var parentSuite = currentDeclarationSuite;\r\n      parentSuite.addChild(suite);\r\n      currentDeclarationSuite = suite;\r\n\r\n      var declarationError = null;\r\n      try {\r\n        specDefinitions.call(suite);\r\n      } catch (e) {\r\n        declarationError = e;\r\n      }\r\n\r\n      if (declarationError) {\r\n        self.it('encountered a declaration exception', function() {\r\n          throw declarationError;\r\n        });\r\n      }\r\n\r\n      currentDeclarationSuite = parentSuite;\r\n    }\r\n\r\n    function findFocusedAncestor(suite) {\r\n      while (suite) {\r\n        if (suite.isFocused) {\r\n          return suite.id;\r\n        }\r\n        suite = suite.parentSuite;\r\n      }\r\n\r\n      return null;\r\n    }\r\n\r\n    function unfocusAncestor() {\r\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n      if (focusedAncestor) {\r\n        for (var i = 0; i < focusedRunnables.length; i++) {\r\n          if (focusedRunnables[i] === focusedAncestor) {\r\n            focusedRunnables.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var specFactory = function(description, fn, suite, timeout) {\r\n      totalSpecsDefined++;\r\n      var spec = new j$.Spec({\r\n        id: getNextSpecId(),\r\n        beforeAndAfterFns: beforeAndAfterFns(suite),\r\n        expectationFactory: expectationFactory,\r\n        resultCallback: specResultCallback,\r\n        getSpecName: function(spec) {\r\n          return getSpecName(spec, suite);\r\n        },\r\n        onStart: specStarted,\r\n        description: description,\r\n        expectationResultFactory: expectationResultFactory,\r\n        queueRunnerFactory: queueRunnerFactory,\r\n        userContext: function() { return suite.clonedSharedUserContext(); },\r\n        queueableFn: {\r\n          fn: fn,\r\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n        },\r\n        throwOnExpectationFailure: throwOnExpectationFailure\r\n      });\r\n\r\n      if (!self.specFilter(spec)) {\r\n        spec.disable();\r\n      }\r\n\r\n      return spec;\r\n\r\n      function specResultCallback(result) {\r\n        clearResourcesForRunnable(spec.id);\r\n        currentSpec = null;\r\n        reporter.specDone(result);\r\n      }\r\n\r\n      function specStarted(spec) {\r\n        currentSpec = spec;\r\n        defaultResourcesForRunnable(spec.id, suite.id);\r\n        reporter.specStarted(spec.result);\r\n      }\r\n    };\r\n\r\n    this.it = function(description, fn, timeout) {\r\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n      if (currentDeclarationSuite.markedPending) {\r\n        spec.pend();\r\n      }\r\n      currentDeclarationSuite.addChild(spec);\r\n      return spec;\r\n    };\r\n\r\n    this.xit = function() {\r\n      var spec = this.it.apply(this, arguments);\r\n      spec.pend('Temporarily disabled with xit');\r\n      return spec;\r\n    };\r\n\r\n    this.fit = function(description, fn, timeout){\r\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n      currentDeclarationSuite.addChild(spec);\r\n      focusedRunnables.push(spec.id);\r\n      unfocusAncestor();\r\n      return spec;\r\n    };\r\n\r\n    this.expect = function(actual) {\r\n      if (!currentRunnable()) {\r\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n      }\r\n\r\n      return currentRunnable().expect(actual);\r\n    };\r\n\r\n    this.beforeEach = function(beforeEachFunction, timeout) {\r\n      currentDeclarationSuite.beforeEach({\r\n        fn: beforeEachFunction,\r\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n      });\r\n    };\r\n\r\n    this.beforeAll = function(beforeAllFunction, timeout) {\r\n      currentDeclarationSuite.beforeAll({\r\n        fn: beforeAllFunction,\r\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n      });\r\n    };\r\n\r\n    this.afterEach = function(afterEachFunction, timeout) {\r\n      currentDeclarationSuite.afterEach({\r\n        fn: afterEachFunction,\r\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n      });\r\n    };\r\n\r\n    this.afterAll = function(afterAllFunction, timeout) {\r\n      currentDeclarationSuite.afterAll({\r\n        fn: afterAllFunction,\r\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n      });\r\n    };\r\n\r\n    this.pending = function(message) {\r\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n      if(message) {\r\n        fullMessage += message;\r\n      }\r\n      throw fullMessage;\r\n    };\r\n\r\n    this.fail = function(error) {\r\n      var message = 'Failed';\r\n      if (error) {\r\n        message += ': ';\r\n        message += error.message || error;\r\n      }\r\n\r\n      currentRunnable().addExpectationResult(false, {\r\n        matcherName: '',\r\n        passed: false,\r\n        expected: '',\r\n        actual: '',\r\n        message: message,\r\n        error: error && error.message ? error : null\r\n      });\r\n    };\r\n  }\r\n\r\n  return Env;\r\n};\r\n\r\ngetJasmineRequireObj().JsApiReporter = function() {\r\n\r\n  var noopTimer = {\r\n    start: function(){},\r\n    elapsed: function(){ return 0; }\r\n  };\r\n\r\n  function JsApiReporter(options) {\r\n    var timer = options.timer || noopTimer,\r\n        status = 'loaded';\r\n\r\n    this.started = false;\r\n    this.finished = false;\r\n    this.runDetails = {};\r\n\r\n    this.jasmineStarted = function() {\r\n      this.started = true;\r\n      status = 'started';\r\n      timer.start();\r\n    };\r\n\r\n    var executionTime;\r\n\r\n    this.jasmineDone = function(runDetails) {\r\n      this.finished = true;\r\n      this.runDetails = runDetails;\r\n      executionTime = timer.elapsed();\r\n      status = 'done';\r\n    };\r\n\r\n    this.status = function() {\r\n      return status;\r\n    };\r\n\r\n    var suites = [],\r\n      suites_hash = {};\r\n\r\n    this.suiteStarted = function(result) {\r\n      suites_hash[result.id] = result;\r\n    };\r\n\r\n    this.suiteDone = function(result) {\r\n      storeSuite(result);\r\n    };\r\n\r\n    this.suiteResults = function(index, length) {\r\n      return suites.slice(index, index + length);\r\n    };\r\n\r\n    function storeSuite(result) {\r\n      suites.push(result);\r\n      suites_hash[result.id] = result;\r\n    }\r\n\r\n    this.suites = function() {\r\n      return suites_hash;\r\n    };\r\n\r\n    var specs = [];\r\n\r\n    this.specDone = function(result) {\r\n      specs.push(result);\r\n    };\r\n\r\n    this.specResults = function(index, length) {\r\n      return specs.slice(index, index + length);\r\n    };\r\n\r\n    this.specs = function() {\r\n      return specs;\r\n    };\r\n\r\n    this.executionTime = function() {\r\n      return executionTime;\r\n    };\r\n\r\n  }\r\n\r\n  return JsApiReporter;\r\n};\r\n\r\ngetJasmineRequireObj().CallTracker = function(j$) {\r\n\r\n  function CallTracker() {\r\n    var calls = [];\r\n    var opts = {};\r\n\r\n    function argCloner(context) {\r\n      var clonedArgs = [];\r\n      var argsAsArray = j$.util.argsToArray(context.args);\r\n      for(var i = 0; i < argsAsArray.length; i++) {\r\n        if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\\[object/)) {\r\n          clonedArgs.push(j$.util.clone(argsAsArray[i]));\r\n        } else {\r\n          clonedArgs.push(argsAsArray[i]);\r\n        }\r\n      }\r\n      context.args = clonedArgs;\r\n    }\r\n\r\n    this.track = function(context) {\r\n      if(opts.cloneArgs) {\r\n        argCloner(context);\r\n      }\r\n      calls.push(context);\r\n    };\r\n\r\n    this.any = function() {\r\n      return !!calls.length;\r\n    };\r\n\r\n    this.count = function() {\r\n      return calls.length;\r\n    };\r\n\r\n    this.argsFor = function(index) {\r\n      var call = calls[index];\r\n      return call ? call.args : [];\r\n    };\r\n\r\n    this.all = function() {\r\n      return calls;\r\n    };\r\n\r\n    this.allArgs = function() {\r\n      var callArgs = [];\r\n      for(var i = 0; i < calls.length; i++){\r\n        callArgs.push(calls[i].args);\r\n      }\r\n\r\n      return callArgs;\r\n    };\r\n\r\n    this.first = function() {\r\n      return calls[0];\r\n    };\r\n\r\n    this.mostRecent = function() {\r\n      return calls[calls.length - 1];\r\n    };\r\n\r\n    this.reset = function() {\r\n      calls = [];\r\n    };\r\n\r\n    this.saveArgumentsByValue = function() {\r\n      opts.cloneArgs = true;\r\n    };\r\n\r\n  }\r\n\r\n  return CallTracker;\r\n};\r\n\r\ngetJasmineRequireObj().Clock = function() {\r\n  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\r\n    var self = this,\r\n      realTimingFunctions = {\r\n        setTimeout: global.setTimeout,\r\n        clearTimeout: global.clearTimeout,\r\n        setInterval: global.setInterval,\r\n        clearInterval: global.clearInterval\r\n      },\r\n      fakeTimingFunctions = {\r\n        setTimeout: setTimeout,\r\n        clearTimeout: clearTimeout,\r\n        setInterval: setInterval,\r\n        clearInterval: clearInterval\r\n      },\r\n      installed = false,\r\n      delayedFunctionScheduler,\r\n      timer;\r\n\r\n\r\n    self.install = function() {\r\n      if(!originalTimingFunctionsIntact()) {\r\n        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\r\n      }\r\n      replace(global, fakeTimingFunctions);\r\n      timer = fakeTimingFunctions;\r\n      delayedFunctionScheduler = delayedFunctionSchedulerFactory();\r\n      installed = true;\r\n\r\n      return self;\r\n    };\r\n\r\n    self.uninstall = function() {\r\n      delayedFunctionScheduler = null;\r\n      mockDate.uninstall();\r\n      replace(global, realTimingFunctions);\r\n\r\n      timer = realTimingFunctions;\r\n      installed = false;\r\n    };\r\n\r\n    self.withMock = function(closure) {\r\n      this.install();\r\n      try {\r\n        closure();\r\n      } finally {\r\n        this.uninstall();\r\n      }\r\n    };\r\n\r\n    self.mockDate = function(initialDate) {\r\n      mockDate.install(initialDate);\r\n    };\r\n\r\n    self.setTimeout = function(fn, delay, params) {\r\n      if (legacyIE()) {\r\n        if (arguments.length > 2) {\r\n          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n        }\r\n        return timer.setTimeout(fn, delay);\r\n      }\r\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n    };\r\n\r\n    self.setInterval = function(fn, delay, params) {\r\n      if (legacyIE()) {\r\n        if (arguments.length > 2) {\r\n          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n        }\r\n        return timer.setInterval(fn, delay);\r\n      }\r\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n    };\r\n\r\n    self.clearTimeout = function(id) {\r\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n    };\r\n\r\n    self.clearInterval = function(id) {\r\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n    };\r\n\r\n    self.tick = function(millis) {\r\n      if (installed) {\r\n        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });\r\n      } else {\r\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n      }\r\n    };\r\n\r\n    return self;\r\n\r\n    function originalTimingFunctionsIntact() {\r\n      return global.setTimeout === realTimingFunctions.setTimeout &&\r\n        global.clearTimeout === realTimingFunctions.clearTimeout &&\r\n        global.setInterval === realTimingFunctions.setInterval &&\r\n        global.clearInterval === realTimingFunctions.clearInterval;\r\n    }\r\n\r\n    function legacyIE() {\r\n      //if these methods are polyfilled, apply will be present\r\n      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n    }\r\n\r\n    function replace(dest, source) {\r\n      for (var prop in source) {\r\n        dest[prop] = source[prop];\r\n      }\r\n    }\r\n\r\n    function setTimeout(fn, delay) {\r\n      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n    }\r\n\r\n    function clearTimeout(id) {\r\n      return delayedFunctionScheduler.removeFunctionWithId(id);\r\n    }\r\n\r\n    function setInterval(fn, interval) {\r\n      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n    }\r\n\r\n    function clearInterval(id) {\r\n      return delayedFunctionScheduler.removeFunctionWithId(id);\r\n    }\r\n\r\n    function argSlice(argsObj, n) {\r\n      return Array.prototype.slice.call(argsObj, n);\r\n    }\r\n  }\r\n\r\n  return Clock;\r\n};\r\n\r\ngetJasmineRequireObj().DelayedFunctionScheduler = function() {\r\n  function DelayedFunctionScheduler() {\r\n    var self = this;\r\n    var scheduledLookup = [];\r\n    var scheduledFunctions = {};\r\n    var currentTime = 0;\r\n    var delayedFnCount = 0;\r\n\r\n    self.tick = function(millis, tickDate) {\r\n      millis = millis || 0;\r\n      var endTime = currentTime + millis;\r\n\r\n      runScheduledFunctions(endTime, tickDate);\r\n      currentTime = endTime;\r\n    };\r\n\r\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n      var f;\r\n      if (typeof(funcToCall) === 'string') {\r\n        /* jshint evil: true */\r\n        f = function() { return eval(funcToCall); };\r\n        /* jshint evil: false */\r\n      } else {\r\n        f = funcToCall;\r\n      }\r\n\r\n      millis = millis || 0;\r\n      timeoutKey = timeoutKey || ++delayedFnCount;\r\n      runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n      var funcToSchedule = {\r\n        runAtMillis: runAtMillis,\r\n        funcToCall: f,\r\n        recurring: recurring,\r\n        params: params,\r\n        timeoutKey: timeoutKey,\r\n        millis: millis\r\n      };\r\n\r\n      if (runAtMillis in scheduledFunctions) {\r\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n      } else {\r\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n        scheduledLookup.push(runAtMillis);\r\n        scheduledLookup.sort(function (a, b) {\r\n          return a - b;\r\n        });\r\n      }\r\n\r\n      return timeoutKey;\r\n    };\r\n\r\n    self.removeFunctionWithId = function(timeoutKey) {\r\n      for (var runAtMillis in scheduledFunctions) {\r\n        var funcs = scheduledFunctions[runAtMillis];\r\n        var i = indexOfFirstToPass(funcs, function (func) {\r\n          return func.timeoutKey === timeoutKey;\r\n        });\r\n\r\n        if (i > -1) {\r\n          if (funcs.length === 1) {\r\n            delete scheduledFunctions[runAtMillis];\r\n            deleteFromLookup(runAtMillis);\r\n          } else {\r\n            funcs.splice(i, 1);\r\n          }\r\n\r\n          // intervals get rescheduled when executed, so there's never more\r\n          // than a single scheduled function with a given timeoutKey\r\n          break;\r\n        }\r\n      }\r\n    };\r\n\r\n    return self;\r\n\r\n    function indexOfFirstToPass(array, testFn) {\r\n      var index = -1;\r\n\r\n      for (var i = 0; i < array.length; ++i) {\r\n        if (testFn(array[i])) {\r\n          index = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      return index;\r\n    }\r\n\r\n    function deleteFromLookup(key) {\r\n      var value = Number(key);\r\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n        return millis === value;\r\n      });\r\n\r\n      if (i > -1) {\r\n        scheduledLookup.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    function reschedule(scheduledFn) {\r\n      self.scheduleFunction(scheduledFn.funcToCall,\r\n        scheduledFn.millis,\r\n        scheduledFn.params,\r\n        true,\r\n        scheduledFn.timeoutKey,\r\n        scheduledFn.runAtMillis + scheduledFn.millis);\r\n    }\r\n\r\n    function forEachFunction(funcsToRun, callback) {\r\n      for (var i = 0; i < funcsToRun.length; ++i) {\r\n        callback(funcsToRun[i]);\r\n      }\r\n    }\r\n\r\n    function runScheduledFunctions(endTime, tickDate) {\r\n      tickDate = tickDate || function() {};\r\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n        tickDate(endTime - currentTime);\r\n        return;\r\n      }\r\n\r\n      do {\r\n        var newCurrentTime = scheduledLookup.shift();\r\n        tickDate(newCurrentTime - currentTime);\r\n\r\n        currentTime = newCurrentTime;\r\n\r\n        var funcsToRun = scheduledFunctions[currentTime];\r\n        delete scheduledFunctions[currentTime];\r\n\r\n        forEachFunction(funcsToRun, function(funcToRun) {\r\n          if (funcToRun.recurring) {\r\n            reschedule(funcToRun);\r\n          }\r\n        });\r\n\r\n        forEachFunction(funcsToRun, function(funcToRun) {\r\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n        });\r\n      } while (scheduledLookup.length > 0 &&\r\n              // checking first if we're out of time prevents setTimeout(0)\r\n              // scheduled in a funcToRun from forcing an extra iteration\r\n                 currentTime !== endTime  &&\r\n                 scheduledLookup[0] <= endTime);\r\n\r\n      // ran out of functions to call, but still time left on the clock\r\n      if (currentTime !== endTime) {\r\n        tickDate(endTime - currentTime);\r\n      }\r\n    }\r\n  }\r\n\r\n  return DelayedFunctionScheduler;\r\n};\r\n\r\ngetJasmineRequireObj().ExceptionFormatter = function() {\r\n  function ExceptionFormatter() {\r\n    this.message = function(error) {\r\n      var message = '';\r\n\r\n      if (error.name && error.message) {\r\n        message += error.name + ': ' + error.message;\r\n      } else {\r\n        message += error.toString() + ' thrown';\r\n      }\r\n\r\n      if (error.fileName || error.sourceURL) {\r\n        message += ' in ' + (error.fileName || error.sourceURL);\r\n      }\r\n\r\n      if (error.line || error.lineNumber) {\r\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\r\n      }\r\n\r\n      return message;\r\n    };\r\n\r\n    this.stack = function(error) {\r\n      return error ? error.stack : null;\r\n    };\r\n  }\r\n\r\n  return ExceptionFormatter;\r\n};\r\n\r\ngetJasmineRequireObj().Expectation = function() {\r\n\r\n  function Expectation(options) {\r\n    this.util = options.util || { buildFailureMessage: function() {} };\r\n    this.customEqualityTesters = options.customEqualityTesters || [];\r\n    this.actual = options.actual;\r\n    this.addExpectationResult = options.addExpectationResult || function(){};\r\n    this.isNot = options.isNot;\r\n\r\n    var customMatchers = options.customMatchers || {};\r\n    for (var matcherName in customMatchers) {\r\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\r\n    }\r\n  }\r\n\r\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\r\n    return function() {\r\n      var args = Array.prototype.slice.call(arguments, 0),\r\n        expected = args.slice(0),\r\n        message = '';\r\n\r\n      args.unshift(this.actual);\r\n\r\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\r\n          matcherCompare = matcher.compare;\r\n\r\n      function defaultNegativeCompare() {\r\n        var result = matcher.compare.apply(null, args);\r\n        result.pass = !result.pass;\r\n        return result;\r\n      }\r\n\r\n      if (this.isNot) {\r\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\r\n      }\r\n\r\n      var result = matcherCompare.apply(null, args);\r\n\r\n      if (!result.pass) {\r\n        if (!result.message) {\r\n          args.unshift(this.isNot);\r\n          args.unshift(name);\r\n          message = this.util.buildFailureMessage.apply(null, args);\r\n        } else {\r\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\r\n            message = result.message();\r\n          } else {\r\n            message = result.message;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (expected.length == 1) {\r\n        expected = expected[0];\r\n      }\r\n\r\n      // TODO: how many of these params are needed?\r\n      this.addExpectationResult(\r\n        result.pass,\r\n        {\r\n          matcherName: name,\r\n          passed: result.pass,\r\n          message: message,\r\n          actual: this.actual,\r\n          expected: expected // TODO: this may need to be arrayified/sliced\r\n        }\r\n      );\r\n    };\r\n  };\r\n\r\n  Expectation.addCoreMatchers = function(matchers) {\r\n    var prototype = Expectation.prototype;\r\n    for (var matcherName in matchers) {\r\n      var matcher = matchers[matcherName];\r\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\r\n    }\r\n  };\r\n\r\n  Expectation.Factory = function(options) {\r\n    options = options || {};\r\n\r\n    var expect = new Expectation(options);\r\n\r\n    // TODO: this would be nice as its own Object - NegativeExpectation\r\n    // TODO: copy instead of mutate options\r\n    options.isNot = true;\r\n    expect.not = new Expectation(options);\r\n\r\n    return expect;\r\n  };\r\n\r\n  return Expectation;\r\n};\r\n\r\n//TODO: expectation result may make more sense as a presentation of an expectation.\r\ngetJasmineRequireObj().buildExpectationResult = function() {\r\n  function buildExpectationResult(options) {\r\n    var messageFormatter = options.messageFormatter || function() {},\r\n      stackFormatter = options.stackFormatter || function() {};\r\n\r\n    var result = {\r\n      matcherName: options.matcherName,\r\n      message: message(),\r\n      stack: stack(),\r\n      passed: options.passed\r\n    };\r\n\r\n    if(!result.passed) {\r\n      result.expected = options.expected;\r\n      result.actual = options.actual;\r\n    }\r\n\r\n    return result;\r\n\r\n    function message() {\r\n      if (options.passed) {\r\n        return 'Passed.';\r\n      } else if (options.message) {\r\n        return options.message;\r\n      } else if (options.error) {\r\n        return messageFormatter(options.error);\r\n      }\r\n      return '';\r\n    }\r\n\r\n    function stack() {\r\n      if (options.passed) {\r\n        return '';\r\n      }\r\n\r\n      var error = options.error;\r\n      if (!error) {\r\n        try {\r\n          throw new Error(message());\r\n        } catch (e) {\r\n          error = e;\r\n        }\r\n      }\r\n      return stackFormatter(error);\r\n    }\r\n  }\r\n\r\n  return buildExpectationResult;\r\n};\r\n\r\ngetJasmineRequireObj().MockDate = function() {\r\n  function MockDate(global) {\r\n    var self = this;\r\n    var currentTime = 0;\r\n\r\n    if (!global || !global.Date) {\r\n      self.install = function() {};\r\n      self.tick = function() {};\r\n      self.uninstall = function() {};\r\n      return self;\r\n    }\r\n\r\n    var GlobalDate = global.Date;\r\n\r\n    self.install = function(mockDate) {\r\n      if (mockDate instanceof GlobalDate) {\r\n        currentTime = mockDate.getTime();\r\n      } else {\r\n        currentTime = new GlobalDate().getTime();\r\n      }\r\n\r\n      global.Date = FakeDate;\r\n    };\r\n\r\n    self.tick = function(millis) {\r\n      millis = millis || 0;\r\n      currentTime = currentTime + millis;\r\n    };\r\n\r\n    self.uninstall = function() {\r\n      currentTime = 0;\r\n      global.Date = GlobalDate;\r\n    };\r\n\r\n    createDateProperties();\r\n\r\n    return self;\r\n\r\n    function FakeDate() {\r\n      switch(arguments.length) {\r\n        case 0:\r\n          return new GlobalDate(currentTime);\r\n        case 1:\r\n          return new GlobalDate(arguments[0]);\r\n        case 2:\r\n          return new GlobalDate(arguments[0], arguments[1]);\r\n        case 3:\r\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\r\n        case 4:\r\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\r\n        case 5:\r\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\r\n                                arguments[4]);\r\n        case 6:\r\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\r\n                                arguments[4], arguments[5]);\r\n        default:\r\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\r\n                                arguments[4], arguments[5], arguments[6]);\r\n      }\r\n    }\r\n\r\n    function createDateProperties() {\r\n      FakeDate.prototype = GlobalDate.prototype;\r\n\r\n      FakeDate.now = function() {\r\n        if (GlobalDate.now) {\r\n          return currentTime;\r\n        } else {\r\n          throw new Error('Browser does not support Date.now()');\r\n        }\r\n      };\r\n\r\n      FakeDate.toSource = GlobalDate.toSource;\r\n      FakeDate.toString = GlobalDate.toString;\r\n      FakeDate.parse = GlobalDate.parse;\r\n      FakeDate.UTC = GlobalDate.UTC;\r\n    }\r\n\t}\r\n\r\n  return MockDate;\r\n};\r\n\r\ngetJasmineRequireObj().pp = function(j$) {\r\n\r\n  function PrettyPrinter() {\r\n    this.ppNestLevel_ = 0;\r\n    this.seen = [];\r\n  }\r\n\r\n  PrettyPrinter.prototype.format = function(value) {\r\n    this.ppNestLevel_++;\r\n    try {\r\n      if (j$.util.isUndefined(value)) {\r\n        this.emitScalar('undefined');\r\n      } else if (value === null) {\r\n        this.emitScalar('null');\r\n      } else if (value === 0 && 1/value === -Infinity) {\r\n        this.emitScalar('-0');\r\n      } else if (value === j$.getGlobal()) {\r\n        this.emitScalar('<global>');\r\n      } else if (value.jasmineToString) {\r\n        this.emitScalar(value.jasmineToString());\r\n      } else if (typeof value === 'string') {\r\n        this.emitString(value);\r\n      } else if (j$.isSpy(value)) {\r\n        this.emitScalar('spy on ' + value.and.identity());\r\n      } else if (value instanceof RegExp) {\r\n        this.emitScalar(value.toString());\r\n      } else if (typeof value === 'function') {\r\n        this.emitScalar('Function');\r\n      } else if (typeof value.nodeType === 'number') {\r\n        this.emitScalar('HTMLNode');\r\n      } else if (value instanceof Date) {\r\n        this.emitScalar('Date(' + value + ')');\r\n      } else if (value.toString && typeof value === 'object' && !(value instanceof Array) && value.toString !== Object.prototype.toString) {\r\n        this.emitScalar(value.toString());\r\n      } else if (j$.util.arrayContains(this.seen, value)) {\r\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\r\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\r\n        this.seen.push(value);\r\n        if (j$.isArray_(value)) {\r\n          this.emitArray(value);\r\n        } else {\r\n          this.emitObject(value);\r\n        }\r\n        this.seen.pop();\r\n      } else {\r\n        this.emitScalar(value.toString());\r\n      }\r\n    } finally {\r\n      this.ppNestLevel_--;\r\n    }\r\n  };\r\n\r\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\r\n    for (var property in obj) {\r\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\r\n      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\r\n          obj.__lookupGetter__(property) !== null) : false);\r\n    }\r\n  };\r\n\r\n  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\r\n  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\r\n  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\r\n  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\r\n\r\n  function StringPrettyPrinter() {\r\n    PrettyPrinter.call(this);\r\n\r\n    this.string = '';\r\n  }\r\n\r\n  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\r\n\r\n  StringPrettyPrinter.prototype.emitScalar = function(value) {\r\n    this.append(value);\r\n  };\r\n\r\n  StringPrettyPrinter.prototype.emitString = function(value) {\r\n    this.append('\\'' + value + '\\'');\r\n  };\r\n\r\n  StringPrettyPrinter.prototype.emitArray = function(array) {\r\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\r\n      this.append('Array');\r\n      return;\r\n    }\r\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\r\n    this.append('[ ');\r\n    for (var i = 0; i < length; i++) {\r\n      if (i > 0) {\r\n        this.append(', ');\r\n      }\r\n      this.format(array[i]);\r\n    }\r\n    if(array.length > length){\r\n      this.append(', ...');\r\n    }\r\n\r\n    var self = this;\r\n    var first = array.length === 0;\r\n    this.iterateObject(array, function(property, isGetter) {\r\n      if (property.match(/^\\d+$/)) {\r\n        return;\r\n      }\r\n\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        self.append(', ');\r\n      }\r\n\r\n      self.formatProperty(array, property, isGetter);\r\n    });\r\n\r\n    this.append(' ]');\r\n  };\r\n\r\n  StringPrettyPrinter.prototype.emitObject = function(obj) {\r\n    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';\r\n    this.append(constructorName);\r\n\r\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\r\n      return;\r\n    }\r\n\r\n    var self = this;\r\n    this.append('({ ');\r\n    var first = true;\r\n\r\n    this.iterateObject(obj, function(property, isGetter) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        self.append(', ');\r\n      }\r\n\r\n      self.formatProperty(obj, property, isGetter);\r\n    });\r\n\r\n    this.append(' })');\r\n  };\r\n\r\n  StringPrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {\r\n      this.append(property);\r\n      this.append(': ');\r\n      if (isGetter) {\r\n        this.append('<getter>');\r\n      } else {\r\n        this.format(obj[property]);\r\n      }\r\n  };\r\n\r\n  StringPrettyPrinter.prototype.append = function(value) {\r\n    this.string += value;\r\n  };\r\n\r\n  return function(value) {\r\n    var stringPrettyPrinter = new StringPrettyPrinter();\r\n    stringPrettyPrinter.format(value);\r\n    return stringPrettyPrinter.string;\r\n  };\r\n};\r\n\r\ngetJasmineRequireObj().QueueRunner = function(j$) {\r\n\r\n  function once(fn) {\r\n    var called = false;\r\n    return function() {\r\n      if (!called) {\r\n        called = true;\r\n        fn();\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  function QueueRunner(attrs) {\r\n    this.queueableFns = attrs.queueableFns || [];\r\n    this.onComplete = attrs.onComplete || function() {};\r\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n    this.onException = attrs.onException || function() {};\r\n    this.catchException = attrs.catchException || function() { return true; };\r\n    this.userContext = attrs.userContext || {};\r\n    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n    this.fail = attrs.fail || function() {};\r\n  }\r\n\r\n  QueueRunner.prototype.execute = function() {\r\n    this.run(this.queueableFns, 0);\r\n  };\r\n\r\n  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {\r\n    var length = queueableFns.length,\r\n      self = this,\r\n      iterativeIndex;\r\n\r\n\r\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\r\n      var queueableFn = queueableFns[iterativeIndex];\r\n      if (queueableFn.fn.length > 0) {\r\n        attemptAsync(queueableFn);\r\n        return;\r\n      } else {\r\n        attemptSync(queueableFn);\r\n      }\r\n    }\r\n\r\n    var runnerDone = iterativeIndex >= length;\r\n\r\n    if (runnerDone) {\r\n      this.clearStack(this.onComplete);\r\n    }\r\n\r\n    function attemptSync(queueableFn) {\r\n      try {\r\n        queueableFn.fn.call(self.userContext);\r\n      } catch (e) {\r\n        handleException(e, queueableFn);\r\n      }\r\n    }\r\n\r\n    function attemptAsync(queueableFn) {\r\n      var clearTimeout = function () {\r\n          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);\r\n        },\r\n        next = once(function () {\r\n          clearTimeout(timeoutId);\r\n          self.run(queueableFns, iterativeIndex + 1);\r\n        }),\r\n        timeoutId;\r\n\r\n      next.fail = function() {\r\n        self.fail.apply(null, arguments);\r\n        next();\r\n      };\r\n\r\n      if (queueableFn.timeout) {\r\n        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {\r\n          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\r\n          onException(error);\r\n          next();\r\n        }, queueableFn.timeout()]]);\r\n      }\r\n\r\n      try {\r\n        queueableFn.fn.call(self.userContext, next);\r\n      } catch (e) {\r\n        handleException(e, queueableFn);\r\n        next();\r\n      }\r\n    }\r\n\r\n    function onException(e) {\r\n      self.onException(e);\r\n    }\r\n\r\n    function handleException(e, queueableFn) {\r\n      onException(e);\r\n      if (!self.catchException(e)) {\r\n        //TODO: set a var when we catch an exception and\r\n        //use a finally block to close the loop in a nice way..\r\n        throw e;\r\n      }\r\n    }\r\n  };\r\n\r\n  return QueueRunner;\r\n};\r\n\r\ngetJasmineRequireObj().ReportDispatcher = function() {\r\n  function ReportDispatcher(methods) {\r\n\r\n    var dispatchedMethods = methods || [];\r\n\r\n    for (var i = 0; i < dispatchedMethods.length; i++) {\r\n      var method = dispatchedMethods[i];\r\n      this[method] = (function(m) {\r\n        return function() {\r\n          dispatch(m, arguments);\r\n        };\r\n      }(method));\r\n    }\r\n\r\n    var reporters = [];\r\n    var fallbackReporter = null;\r\n\r\n    this.addReporter = function(reporter) {\r\n      reporters.push(reporter);\r\n    };\r\n\r\n    this.provideFallbackReporter = function(reporter) {\r\n      fallbackReporter = reporter;\r\n    };\r\n\r\n    this.clearReporters = function() {\r\n      reporters = [];\r\n    };\r\n\r\n    return this;\r\n\r\n    function dispatch(method, args) {\r\n      if (reporters.length === 0 && fallbackReporter !== null) {\r\n          reporters.push(fallbackReporter);\r\n      }\r\n      for (var i = 0; i < reporters.length; i++) {\r\n        var reporter = reporters[i];\r\n        if (reporter[method]) {\r\n          reporter[method].apply(reporter, args);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return ReportDispatcher;\r\n};\r\n\r\n\r\ngetJasmineRequireObj().SpyRegistry = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\r\n\r\n  function SpyRegistry(options) {\r\n    options = options || {};\r\n    var currentSpies = options.currentSpies || function() { return []; };\r\n\r\n    this.allowRespy = function(allow){\r\n      this.respy = allow;\r\n    };\r\n\r\n    this.spyOn = function(obj, methodName) {\r\n\r\n      if (j$.util.isUndefined(obj)) {\r\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\r\n      }\r\n\r\n      if (j$.util.isUndefined(methodName)) {\r\n        throw new Error(getErrorMsg('No method name supplied'));\r\n      }\r\n\r\n      if (j$.util.isUndefined(obj[methodName])) {\r\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\r\n      }\r\n\r\n      if (obj[methodName] && j$.isSpy(obj[methodName])  ) {\r\n        if ( !!this.respy ){\r\n          return obj[methodName];\r\n        }else {\r\n          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\r\n        }\r\n      }\r\n\r\n      var descriptor;\r\n      try {\r\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\r\n      } catch(e) {\r\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\r\n      }\r\n\r\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\r\n        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\r\n      }\r\n\r\n      var originalMethod = obj[methodName],\r\n        spiedMethod = j$.createSpy(methodName, originalMethod),\r\n        restoreStrategy;\r\n\r\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\r\n        restoreStrategy = function() {\r\n          obj[methodName] = originalMethod;\r\n        };\r\n      } else {\r\n        restoreStrategy = function() {\r\n          if (!delete obj[methodName]) {\r\n            obj[methodName] = originalMethod;\r\n          }\r\n        };\r\n      }\r\n\r\n      currentSpies().push({\r\n        restoreObjectToOriginalState: restoreStrategy\r\n      });\r\n\r\n      obj[methodName] = spiedMethod;\r\n\r\n      return spiedMethod;\r\n    };\r\n\r\n    this.clearSpies = function() {\r\n      var spies = currentSpies();\r\n      for (var i = spies.length - 1; i >= 0; i--) {\r\n        var spyEntry = spies[i];\r\n        spyEntry.restoreObjectToOriginalState();\r\n      }\r\n    };\r\n  }\r\n\r\n  return SpyRegistry;\r\n};\r\n\r\ngetJasmineRequireObj().SpyStrategy = function(j$) {\r\n\r\n  function SpyStrategy(options) {\r\n    options = options || {};\r\n\r\n    var identity = options.name || 'unknown',\r\n        originalFn = options.fn || function() {},\r\n        getSpy = options.getSpy || function() {},\r\n        plan = function() {};\r\n\r\n    this.identity = function() {\r\n      return identity;\r\n    };\r\n\r\n    this.exec = function() {\r\n      return plan.apply(this, arguments);\r\n    };\r\n\r\n    this.callThrough = function() {\r\n      plan = originalFn;\r\n      return getSpy();\r\n    };\r\n\r\n    this.returnValue = function(value) {\r\n      plan = function() {\r\n        return value;\r\n      };\r\n      return getSpy();\r\n    };\r\n\r\n    this.returnValues = function() {\r\n      var values = Array.prototype.slice.call(arguments);\r\n      plan = function () {\r\n        return values.shift();\r\n      };\r\n      return getSpy();\r\n    };\r\n\r\n    this.throwError = function(something) {\r\n      var error = (something instanceof Error) ? something : new Error(something);\r\n      plan = function() {\r\n        throw error;\r\n      };\r\n      return getSpy();\r\n    };\r\n\r\n    this.callFake = function(fn) {\r\n      if(!j$.isFunction_(fn)) {\r\n        throw new Error('Argument passed to callFake should be a function, got ' + fn);\r\n      }\r\n      plan = fn;\r\n      return getSpy();\r\n    };\r\n\r\n    this.stub = function(fn) {\r\n      plan = function() {};\r\n      return getSpy();\r\n    };\r\n  }\r\n\r\n  return SpyStrategy;\r\n};\r\n\r\ngetJasmineRequireObj().Suite = function(j$) {\r\n  function Suite(attrs) {\r\n    this.env = attrs.env;\r\n    this.id = attrs.id;\r\n    this.parentSuite = attrs.parentSuite;\r\n    this.description = attrs.description;\r\n    this.expectationFactory = attrs.expectationFactory;\r\n    this.expectationResultFactory = attrs.expectationResultFactory;\r\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n    this.beforeFns = [];\r\n    this.afterFns = [];\r\n    this.beforeAllFns = [];\r\n    this.afterAllFns = [];\r\n    this.disabled = false;\r\n\r\n    this.children = [];\r\n\r\n    this.result = {\r\n      id: this.id,\r\n      description: this.description,\r\n      fullName: this.getFullName(),\r\n      failedExpectations: []\r\n    };\r\n  }\r\n\r\n  Suite.prototype.expect = function(actual) {\r\n    return this.expectationFactory(actual, this);\r\n  };\r\n\r\n  Suite.prototype.getFullName = function() {\r\n    var fullName = [];\r\n    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n      if (parentSuite.parentSuite) {\r\n        fullName.unshift(parentSuite.description);\r\n      }\r\n    }\r\n    return fullName.join(' ');\r\n  };\r\n\r\n  Suite.prototype.disable = function() {\r\n    this.disabled = true;\r\n  };\r\n\r\n  Suite.prototype.pend = function(message) {\r\n    this.markedPending = true;\r\n  };\r\n\r\n  Suite.prototype.beforeEach = function(fn) {\r\n    this.beforeFns.unshift(fn);\r\n  };\r\n\r\n  Suite.prototype.beforeAll = function(fn) {\r\n    this.beforeAllFns.push(fn);\r\n  };\r\n\r\n  Suite.prototype.afterEach = function(fn) {\r\n    this.afterFns.unshift(fn);\r\n  };\r\n\r\n  Suite.prototype.afterAll = function(fn) {\r\n    this.afterAllFns.push(fn);\r\n  };\r\n\r\n  Suite.prototype.addChild = function(child) {\r\n    this.children.push(child);\r\n  };\r\n\r\n  Suite.prototype.status = function() {\r\n    if (this.disabled) {\r\n      return 'disabled';\r\n    }\r\n\r\n    if (this.markedPending) {\r\n      return 'pending';\r\n    }\r\n\r\n    if (this.result.failedExpectations.length > 0) {\r\n      return 'failed';\r\n    } else {\r\n      return 'finished';\r\n    }\r\n  };\r\n\r\n  Suite.prototype.isExecutable = function() {\r\n    return !this.disabled;\r\n  };\r\n\r\n  Suite.prototype.canBeReentered = function() {\r\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n  };\r\n\r\n  Suite.prototype.getResult = function() {\r\n    this.result.status = this.status();\r\n    return this.result;\r\n  };\r\n\r\n  Suite.prototype.sharedUserContext = function() {\r\n    if (!this.sharedContext) {\r\n      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n    }\r\n\r\n    return this.sharedContext;\r\n  };\r\n\r\n  Suite.prototype.clonedSharedUserContext = function() {\r\n    return clone(this.sharedUserContext());\r\n  };\r\n\r\n  Suite.prototype.onException = function() {\r\n    if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n      return;\r\n    }\r\n\r\n    if(isAfterAll(this.children)) {\r\n      var data = {\r\n        matcherName: '',\r\n        passed: false,\r\n        expected: '',\r\n        actual: '',\r\n        error: arguments[0]\r\n      };\r\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n    } else {\r\n      for (var i = 0; i < this.children.length; i++) {\r\n        var child = this.children[i];\r\n        child.onException.apply(child, arguments);\r\n      }\r\n    }\r\n  };\r\n\r\n  Suite.prototype.addExpectationResult = function () {\r\n    if(isAfterAll(this.children) && isFailure(arguments)){\r\n      var data = arguments[1];\r\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n      if(this.throwOnExpectationFailure) {\r\n        throw new j$.errors.ExpectationFailed();\r\n      }\r\n    } else {\r\n      for (var i = 0; i < this.children.length; i++) {\r\n        var child = this.children[i];\r\n        try {\r\n          child.addExpectationResult.apply(child, arguments);\r\n        } catch(e) {\r\n          // keep going\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function isAfterAll(children) {\r\n    return children && children[0].result.status;\r\n  }\r\n\r\n  function isFailure(args) {\r\n    return !args[0];\r\n  }\r\n\r\n  function clone(obj) {\r\n    var clonedObj = {};\r\n    for (var prop in obj) {\r\n      if (obj.hasOwnProperty(prop)) {\r\n        clonedObj[prop] = obj[prop];\r\n      }\r\n    }\r\n\r\n    return clonedObj;\r\n  }\r\n\r\n  return Suite;\r\n};\r\n\r\nif (typeof window == void 0 && typeof exports == 'object') {\r\n  exports.Suite = jasmineRequire.Suite;\r\n}\r\n\r\ngetJasmineRequireObj().Timer = function() {\r\n  var defaultNow = (function(Date) {\r\n    return function() { return new Date().getTime(); };\r\n  })(Date);\r\n\r\n  function Timer(options) {\r\n    options = options || {};\r\n\r\n    var now = options.now || defaultNow,\r\n      startTime;\r\n\r\n    this.start = function() {\r\n      startTime = now();\r\n    };\r\n\r\n    this.elapsed = function() {\r\n      return now() - startTime;\r\n    };\r\n  }\r\n\r\n  return Timer;\r\n};\r\n\r\ngetJasmineRequireObj().TreeProcessor = function() {\r\n  function TreeProcessor(attrs) {\r\n    var tree = attrs.tree,\r\n        runnableIds = attrs.runnableIds,\r\n        queueRunnerFactory = attrs.queueRunnerFactory,\r\n        nodeStart = attrs.nodeStart || function() {},\r\n        nodeComplete = attrs.nodeComplete || function() {},\r\n        orderChildren = attrs.orderChildren || function(node) { return node.children; },\r\n        stats = { valid: true },\r\n        processed = false,\r\n        defaultMin = Infinity,\r\n        defaultMax = 1 - Infinity;\r\n\r\n    this.processTree = function() {\r\n      processNode(tree, false);\r\n      processed = true;\r\n      return stats;\r\n    };\r\n\r\n    this.execute = function(done) {\r\n      if (!processed) {\r\n        this.processTree();\r\n      }\r\n\r\n      if (!stats.valid) {\r\n        throw 'invalid order';\r\n      }\r\n\r\n      var childFns = wrapChildren(tree, 0);\r\n\r\n      queueRunnerFactory({\r\n        queueableFns: childFns,\r\n        userContext: tree.sharedUserContext(),\r\n        onException: function() {\r\n          tree.onException.apply(tree, arguments);\r\n        },\r\n        onComplete: done\r\n      });\r\n    };\r\n\r\n    function runnableIndex(id) {\r\n      for (var i = 0; i < runnableIds.length; i++) {\r\n        if (runnableIds[i] === id) {\r\n          return i;\r\n        }\r\n      }\r\n    }\r\n\r\n    function processNode(node, parentEnabled) {\r\n      var executableIndex = runnableIndex(node.id);\r\n\r\n      if (executableIndex !== undefined) {\r\n        parentEnabled = true;\r\n      }\r\n\r\n      parentEnabled = parentEnabled && node.isExecutable();\r\n\r\n      if (!node.children) {\r\n        stats[node.id] = {\r\n          executable: parentEnabled && node.isExecutable(),\r\n          segments: [{\r\n            index: 0,\r\n            owner: node,\r\n            nodes: [node],\r\n            min: startingMin(executableIndex),\r\n            max: startingMax(executableIndex)\r\n          }]\r\n        };\r\n      } else {\r\n        var hasExecutableChild = false;\r\n\r\n        var orderedChildren = orderChildren(node);\r\n\r\n        for (var i = 0; i < orderedChildren.length; i++) {\r\n          var child = orderedChildren[i];\r\n\r\n          processNode(child, parentEnabled);\r\n\r\n          if (!stats.valid) {\r\n            return;\r\n          }\r\n\r\n          var childStats = stats[child.id];\r\n\r\n          hasExecutableChild = hasExecutableChild || childStats.executable;\r\n        }\r\n\r\n        stats[node.id] = {\r\n          executable: hasExecutableChild\r\n        };\r\n\r\n        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\r\n\r\n        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\r\n          stats = { valid: false };\r\n        }\r\n      }\r\n    }\r\n\r\n    function startingMin(executableIndex) {\r\n      return executableIndex === undefined ? defaultMin : executableIndex;\r\n    }\r\n\r\n    function startingMax(executableIndex) {\r\n      return executableIndex === undefined ? defaultMax : executableIndex;\r\n    }\r\n\r\n    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\r\n      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\r\n          result = [currentSegment],\r\n          lastMax = defaultMax,\r\n          orderedChildSegments = orderChildSegments(orderedChildren);\r\n\r\n      function isSegmentBoundary(minIndex) {\r\n        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\r\n      }\r\n\r\n      for (var i = 0; i < orderedChildSegments.length; i++) {\r\n        var childSegment = orderedChildSegments[i],\r\n          maxIndex = childSegment.max,\r\n          minIndex = childSegment.min;\r\n\r\n        if (isSegmentBoundary(minIndex)) {\r\n          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\r\n          result.push(currentSegment);\r\n        }\r\n\r\n        currentSegment.nodes.push(childSegment);\r\n        currentSegment.min = Math.min(currentSegment.min, minIndex);\r\n        currentSegment.max = Math.max(currentSegment.max, maxIndex);\r\n        lastMax = maxIndex;\r\n      }\r\n\r\n      nodeStats.segments = result;\r\n    }\r\n\r\n    function orderChildSegments(children) {\r\n      var specifiedOrder = [],\r\n          unspecifiedOrder = [];\r\n\r\n      for (var i = 0; i < children.length; i++) {\r\n        var child = children[i],\r\n            segments = stats[child.id].segments;\r\n\r\n        for (var j = 0; j < segments.length; j++) {\r\n          var seg = segments[j];\r\n\r\n          if (seg.min === defaultMin) {\r\n            unspecifiedOrder.push(seg);\r\n          } else {\r\n            specifiedOrder.push(seg);\r\n          }\r\n        }\r\n      }\r\n\r\n      specifiedOrder.sort(function(a, b) {\r\n        return a.min - b.min;\r\n      });\r\n\r\n      return specifiedOrder.concat(unspecifiedOrder);\r\n    }\r\n\r\n    function executeNode(node, segmentNumber) {\r\n      if (node.children) {\r\n        return {\r\n          fn: function(done) {\r\n            nodeStart(node);\r\n\r\n            queueRunnerFactory({\r\n              onComplete: function() {\r\n                nodeComplete(node, node.getResult());\r\n                done();\r\n              },\r\n              queueableFns: wrapChildren(node, segmentNumber),\r\n              userContext: node.sharedUserContext(),\r\n              onException: function() {\r\n                node.onException.apply(node, arguments);\r\n              }\r\n            });\r\n          }\r\n        };\r\n      } else {\r\n        return {\r\n          fn: function(done) { node.execute(done, stats[node.id].executable); }\r\n        };\r\n      }\r\n    }\r\n\r\n    function wrapChildren(node, segmentNumber) {\r\n      var result = [],\r\n          segmentChildren = stats[node.id].segments[segmentNumber].nodes;\r\n\r\n      for (var i = 0; i < segmentChildren.length; i++) {\r\n        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\r\n      }\r\n\r\n      if (!stats[node.id].executable) {\r\n        return result;\r\n      }\r\n\r\n      return node.beforeAllFns.concat(result).concat(node.afterAllFns);\r\n    }\r\n  }\r\n\r\n  return TreeProcessor;\r\n};\r\n\r\ngetJasmineRequireObj().Any = function(j$) {\r\n\r\n  function Any(expectedObject) {\r\n    if (typeof expectedObject === 'undefined') {\r\n      throw new TypeError(\r\n        'jasmine.any() expects to be passed a constructor function. ' +\r\n        'Please pass one or use jasmine.anything() to match any object.'\r\n      );\r\n    }\r\n    this.expectedObject = expectedObject;\r\n  }\r\n\r\n  Any.prototype.asymmetricMatch = function(other) {\r\n    if (this.expectedObject == String) {\r\n      return typeof other == 'string' || other instanceof String;\r\n    }\r\n\r\n    if (this.expectedObject == Number) {\r\n      return typeof other == 'number' || other instanceof Number;\r\n    }\r\n\r\n    if (this.expectedObject == Function) {\r\n      return typeof other == 'function' || other instanceof Function;\r\n    }\r\n\r\n    if (this.expectedObject == Object) {\r\n      return typeof other == 'object';\r\n    }\r\n\r\n    if (this.expectedObject == Boolean) {\r\n      return typeof other == 'boolean';\r\n    }\r\n\r\n    return other instanceof this.expectedObject;\r\n  };\r\n\r\n  Any.prototype.jasmineToString = function() {\r\n    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\r\n  };\r\n\r\n  return Any;\r\n};\r\n\r\ngetJasmineRequireObj().Anything = function(j$) {\r\n\r\n  function Anything() {}\r\n\r\n  Anything.prototype.asymmetricMatch = function(other) {\r\n    return !j$.util.isUndefined(other) && other !== null;\r\n  };\r\n\r\n  Anything.prototype.jasmineToString = function() {\r\n    return '<jasmine.anything>';\r\n  };\r\n\r\n  return Anything;\r\n};\r\n\r\ngetJasmineRequireObj().ArrayContaining = function(j$) {\r\n  function ArrayContaining(sample) {\r\n    this.sample = sample;\r\n  }\r\n\r\n  ArrayContaining.prototype.asymmetricMatch = function(other) {\r\n    var className = Object.prototype.toString.call(this.sample);\r\n    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \\'' + this.sample + '\\'.'); }\r\n\r\n    for (var i = 0; i < this.sample.length; i++) {\r\n      var item = this.sample[i];\r\n      if (!j$.matchersUtil.contains(other, item)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  ArrayContaining.prototype.jasmineToString = function () {\r\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\r\n  };\r\n\r\n  return ArrayContaining;\r\n};\r\n\r\ngetJasmineRequireObj().ObjectContaining = function(j$) {\r\n\r\n  function ObjectContaining(sample) {\r\n    this.sample = sample;\r\n  }\r\n\r\n  function getPrototype(obj) {\r\n    if (Object.getPrototypeOf) {\r\n      return Object.getPrototypeOf(obj);\r\n    }\r\n\r\n    if (obj.constructor.prototype == obj) {\r\n      return null;\r\n    }\r\n\r\n    return obj.constructor.prototype;\r\n  }\r\n\r\n  function hasProperty(obj, property) {\r\n    if (!obj) {\r\n      return false;\r\n    }\r\n\r\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\r\n      return true;\r\n    }\r\n\r\n    return hasProperty(getPrototype(obj), property);\r\n  }\r\n\r\n  ObjectContaining.prototype.asymmetricMatch = function(other) {\r\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\r\n\r\n    for (var property in this.sample) {\r\n      if (!hasProperty(other, property) ||\r\n          !j$.matchersUtil.equals(this.sample[property], other[property])) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  ObjectContaining.prototype.jasmineToString = function() {\r\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\r\n  };\r\n\r\n  return ObjectContaining;\r\n};\r\n\r\ngetJasmineRequireObj().StringMatching = function(j$) {\r\n\r\n  function StringMatching(expected) {\r\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\r\n      throw new Error('Expected is not a String or a RegExp');\r\n    }\r\n\r\n    this.regexp = new RegExp(expected);\r\n  }\r\n\r\n  StringMatching.prototype.asymmetricMatch = function(other) {\r\n    return this.regexp.test(other);\r\n  };\r\n\r\n  StringMatching.prototype.jasmineToString = function() {\r\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\r\n  };\r\n\r\n  return StringMatching;\r\n};\r\n\r\ngetJasmineRequireObj().errors = function() {\r\n  function ExpectationFailed() {}\r\n\r\n  ExpectationFailed.prototype = new Error();\r\n  ExpectationFailed.prototype.constructor = ExpectationFailed;\r\n\r\n  return {\r\n    ExpectationFailed: ExpectationFailed\r\n  };\r\n};\r\ngetJasmineRequireObj().formatErrorMsg = function() {\r\n  function generateErrorMsg(domain, usage) {\r\n    var usageDefinition = usage ? '\\nUsage: ' + usage : '';\r\n\r\n    return function errorMsg(msg) {\r\n      return domain + ' : ' + msg + usageDefinition;\r\n    };\r\n  }\r\n\r\n  return generateErrorMsg;\r\n};\r\n\r\ngetJasmineRequireObj().matchersUtil = function(j$) {\r\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n  return {\r\n    equals: function(a, b, customTesters) {\r\n      customTesters = customTesters || [];\r\n\r\n      return eq(a, b, [], [], customTesters);\r\n    },\r\n\r\n    contains: function(haystack, needle, customTesters) {\r\n      customTesters = customTesters || [];\r\n\r\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n        (!!haystack && !haystack.indexOf))\r\n      {\r\n        for (var i = 0; i < haystack.length; i++) {\r\n          if (eq(haystack[i], needle, [], [], customTesters)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n\r\n      return !!haystack && haystack.indexOf(needle) >= 0;\r\n    },\r\n\r\n    buildFailureMessage: function() {\r\n      var args = Array.prototype.slice.call(arguments, 0),\r\n        matcherName = args[0],\r\n        isNot = args[1],\r\n        actual = args[2],\r\n        expected = args.slice(3),\r\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n      var message = 'Expected ' +\r\n        j$.pp(actual) +\r\n        (isNot ? ' not ' : ' ') +\r\n        englishyPredicate;\r\n\r\n      if (expected.length > 0) {\r\n        for (var i = 0; i < expected.length; i++) {\r\n          if (i > 0) {\r\n            message += ',';\r\n          }\r\n          message += ' ' + j$.pp(expected[i]);\r\n        }\r\n      }\r\n\r\n      return message + '.';\r\n    }\r\n  };\r\n\r\n  function isAsymmetric(obj) {\r\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n  }\r\n\r\n  function asymmetricMatch(a, b) {\r\n    var asymmetricA = isAsymmetric(a),\r\n        asymmetricB = isAsymmetric(b);\r\n\r\n    if (asymmetricA && asymmetricB) {\r\n      return undefined;\r\n    }\r\n\r\n    if (asymmetricA) {\r\n      return a.asymmetricMatch(b);\r\n    }\r\n\r\n    if (asymmetricB) {\r\n      return b.asymmetricMatch(a);\r\n    }\r\n  }\r\n\r\n  // Equality function lovingly adapted from isEqual in\r\n  //   [Underscore](http://underscorejs.org)\r\n  function eq(a, b, aStack, bStack, customTesters) {\r\n    var result = true;\r\n\r\n    var asymmetricResult = asymmetricMatch(a, b);\r\n    if (!j$.util.isUndefined(asymmetricResult)) {\r\n      return asymmetricResult;\r\n    }\r\n\r\n    for (var i = 0; i < customTesters.length; i++) {\r\n      var customTesterResult = customTesters[i](a, b);\r\n      if (!j$.util.isUndefined(customTesterResult)) {\r\n        return customTesterResult;\r\n      }\r\n    }\r\n\r\n    if (a instanceof Error && b instanceof Error) {\r\n      return a.message == b.message;\r\n    }\r\n\r\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n    // A strict comparison is necessary because `null == undefined`.\r\n    if (a === null || b === null) { return a === b; }\r\n    var className = Object.prototype.toString.call(a);\r\n    if (className != Object.prototype.toString.call(b)) { return false; }\r\n    switch (className) {\r\n      // Strings, numbers, dates, and booleans are compared by value.\r\n      case '[object String]':\r\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n        // equivalent to `new String(\"5\")`.\r\n        return a == String(b);\r\n      case '[object Number]':\r\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n        // other numeric values.\r\n        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n      case '[object Date]':\r\n      case '[object Boolean]':\r\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n        // millisecond representations. Note that invalid dates with millisecond representations\r\n        // of `NaN` are not equivalent.\r\n        return +a == +b;\r\n      // RegExps are compared by their source patterns and flags.\r\n      case '[object RegExp]':\r\n        return a.source == b.source &&\r\n          a.global == b.global &&\r\n          a.multiline == b.multiline &&\r\n          a.ignoreCase == b.ignoreCase;\r\n    }\r\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n    var aIsDomNode = j$.isDomNode(a);\r\n    var bIsDomNode = j$.isDomNode(b);\r\n    if (aIsDomNode && bIsDomNode) {\r\n      // At first try to use DOM3 method isEqualNode\r\n      if (a.isEqualNode) {\r\n        return a.isEqualNode(b);\r\n      }\r\n      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n      var aIsElement = a instanceof Element;\r\n      var bIsElement = b instanceof Element;\r\n      if (aIsElement && bIsElement) {\r\n        return a.outerHTML == b.outerHTML;\r\n      }\r\n      if (aIsElement || bIsElement) {\r\n        return false;\r\n      }\r\n      return a.innerText == b.innerText && a.textContent == b.textContent;\r\n    }\r\n    if (aIsDomNode || bIsDomNode) {\r\n      return false;\r\n    }\r\n\r\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n    var length = aStack.length;\r\n    while (length--) {\r\n      // Linear search. Performance is inversely proportional to the number of\r\n      // unique nested structures.\r\n      if (aStack[length] == a) { return bStack[length] == b; }\r\n    }\r\n    // Add the first object to the stack of traversed objects.\r\n    aStack.push(a);\r\n    bStack.push(b);\r\n    var size = 0;\r\n    // Recursively compare objects and arrays.\r\n    // Compare array lengths to determine if a deep comparison is necessary.\r\n    if (className == '[object Array]') {\r\n      size = a.length;\r\n      if (size !== b.length) {\r\n        return false;\r\n      }\r\n\r\n      while (size--) {\r\n        result = eq(a[size], b[size], aStack, bStack, customTesters);\r\n        if (!result) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n\r\n      // Objects with different constructors are not equivalent, but `Object`s\r\n      // or `Array`s from different frames are.\r\n      var aCtor = a.constructor, bCtor = b.constructor;\r\n      if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&\r\n                               isObjectConstructor(bCtor))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Deep compare objects.\r\n    var aKeys = keys(a, className == '[object Array]'), key;\r\n    size = aKeys.length;\r\n\r\n    // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n    if (keys(b, className == '[object Array]').length !== size) { return false; }\r\n\r\n    while (size--) {\r\n      key = aKeys[size];\r\n      // Deep compare each member\r\n      result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);\r\n\r\n      if (!result) {\r\n        return false;\r\n      }\r\n    }\r\n    // Remove the first object from the stack of traversed objects.\r\n    aStack.pop();\r\n    bStack.pop();\r\n\r\n    return result;\r\n\r\n    function keys(obj, isArray) {\r\n      var allKeys = Object.keys ? Object.keys(obj) :\r\n        (function(o) {\r\n            var keys = [];\r\n            for (var key in o) {\r\n                if (has(o, key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            return keys;\r\n        })(obj);\r\n\r\n      if (!isArray) {\r\n        return allKeys;\r\n      }\r\n\r\n      var extraKeys = [];\r\n      if (allKeys.length === 0) {\r\n          return allKeys;\r\n      }\r\n\r\n      for (var x = 0; x < allKeys.length; x++) {\r\n          if (!allKeys[x].match(/^[0-9]+$/)) {\r\n              extraKeys.push(allKeys[x]);\r\n          }\r\n      }\r\n\r\n      return extraKeys;\r\n    }\r\n  }\r\n\r\n  function has(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n  }\r\n\r\n  function isFunction(obj) {\r\n    return typeof obj === 'function';\r\n  }\r\n\r\n  function isObjectConstructor(ctor) {\r\n    // aCtor instanceof aCtor is true for the Object and Function\r\n    // constructors (since a constructor is-a Function and a function is-a\r\n    // Object). We don't just compare ctor === Object because the constructor\r\n    // might come from a different frame with different globals.\r\n    return isFunction(ctor) && ctor instanceof ctor;\r\n  }\r\n};\r\n\r\ngetJasmineRequireObj().toBe = function() {\r\n  function toBe() {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        return {\r\n          pass: actual === expected\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBe;\r\n};\r\n\r\ngetJasmineRequireObj().toBeCloseTo = function() {\r\n\r\n  function toBeCloseTo() {\r\n    return {\r\n      compare: function(actual, expected, precision) {\r\n        if (precision !== 0) {\r\n          precision = precision || 2;\r\n        }\r\n\r\n        return {\r\n          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeCloseTo;\r\n};\r\n\r\ngetJasmineRequireObj().toBeDefined = function() {\r\n  function toBeDefined() {\r\n    return {\r\n      compare: function(actual) {\r\n        return {\r\n          pass: (void 0 !== actual)\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeDefined;\r\n};\r\n\r\ngetJasmineRequireObj().toBeFalsy = function() {\r\n  function toBeFalsy() {\r\n    return {\r\n      compare: function(actual) {\r\n        return {\r\n          pass: !!!actual\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeFalsy;\r\n};\r\n\r\ngetJasmineRequireObj().toBeGreaterThan = function() {\r\n\r\n  function toBeGreaterThan() {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        return {\r\n          pass: actual > expected\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeGreaterThan;\r\n};\r\n\r\n\r\ngetJasmineRequireObj().toBeGreaterThanOrEqual = function() {\r\n\r\n  function toBeGreaterThanOrEqual() {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        return {\r\n          pass: actual >= expected\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeGreaterThanOrEqual;\r\n};\r\n\r\ngetJasmineRequireObj().toBeLessThan = function() {\r\n  function toBeLessThan() {\r\n    return {\r\n\r\n      compare: function(actual, expected) {\r\n        return {\r\n          pass: actual < expected\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeLessThan;\r\n};\r\ngetJasmineRequireObj().toBeLessThanOrEqual = function() {\r\n  function toBeLessThanOrEqual() {\r\n    return {\r\n\r\n      compare: function(actual, expected) {\r\n        return {\r\n          pass: actual <= expected\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeLessThanOrEqual;\r\n};\r\n\r\ngetJasmineRequireObj().toBeNaN = function(j$) {\r\n\r\n  function toBeNaN() {\r\n    return {\r\n      compare: function(actual) {\r\n        var result = {\r\n          pass: (actual !== actual)\r\n        };\r\n\r\n        if (result.pass) {\r\n          result.message = 'Expected actual not to be NaN.';\r\n        } else {\r\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\r\n        }\r\n\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeNaN;\r\n};\r\n\r\ngetJasmineRequireObj().toBeNull = function() {\r\n\r\n  function toBeNull() {\r\n    return {\r\n      compare: function(actual) {\r\n        return {\r\n          pass: actual === null\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeNull;\r\n};\r\n\r\ngetJasmineRequireObj().toBeTruthy = function() {\r\n\r\n  function toBeTruthy() {\r\n    return {\r\n      compare: function(actual) {\r\n        return {\r\n          pass: !!actual\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeTruthy;\r\n};\r\n\r\ngetJasmineRequireObj().toBeUndefined = function() {\r\n\r\n  function toBeUndefined() {\r\n    return {\r\n      compare: function(actual) {\r\n        return {\r\n          pass: void 0 === actual\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toBeUndefined;\r\n};\r\n\r\ngetJasmineRequireObj().toContain = function() {\r\n  function toContain(util, customEqualityTesters) {\r\n    customEqualityTesters = customEqualityTesters || [];\r\n\r\n    return {\r\n      compare: function(actual, expected) {\r\n\r\n        return {\r\n          pass: util.contains(actual, expected, customEqualityTesters)\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toContain;\r\n};\r\n\r\ngetJasmineRequireObj().toEqual = function() {\r\n\r\n  function toEqual(util, customEqualityTesters) {\r\n    customEqualityTesters = customEqualityTesters || [];\r\n\r\n    return {\r\n      compare: function(actual, expected) {\r\n        var result = {\r\n          pass: false\r\n        };\r\n\r\n        result.pass = util.equals(actual, expected, customEqualityTesters);\r\n\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toEqual;\r\n};\r\n\r\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');\r\n\r\n  function toHaveBeenCalled() {\r\n    return {\r\n      compare: function(actual) {\r\n        var result = {};\r\n\r\n        if (!j$.isSpy(actual)) {\r\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n        }\r\n\r\n        if (arguments.length > 1) {\r\n          throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));\r\n        }\r\n\r\n        result.pass = actual.calls.any();\r\n\r\n        result.message = result.pass ?\r\n          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\r\n          'Expected spy ' + actual.and.identity() + ' to have been called.';\r\n\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toHaveBeenCalled;\r\n};\r\n\r\ngetJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');\r\n\r\n  function toHaveBeenCalledTimes() {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        if (!j$.isSpy(actual)) {\r\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n        }\r\n\r\n        var args = Array.prototype.slice.call(arguments, 0),\r\n          result = { pass: false };\r\n\r\n        if (!j$.isNumber_(expected)){\r\n          throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\r\n        }\r\n\r\n        actual = args[0];\r\n        var calls = actual.calls.count();\r\n        var timesMessage = expected === 1 ? 'once' : expected + ' times';\r\n        result.pass = calls === expected;\r\n        result.message = result.pass ?\r\n          'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\r\n          'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toHaveBeenCalledTimes;\r\n};\r\n\r\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');\r\n\r\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\r\n    return {\r\n      compare: function() {\r\n        var args = Array.prototype.slice.call(arguments, 0),\r\n          actual = args[0],\r\n          expectedArgs = args.slice(1),\r\n          result = { pass: false };\r\n\r\n        if (!j$.isSpy(actual)) {\r\n          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n        }\r\n\r\n        if (!actual.calls.any()) {\r\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\r\n          return result;\r\n        }\r\n\r\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\r\n          result.pass = true;\r\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\r\n        } else {\r\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\r\n        }\r\n\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toHaveBeenCalledWith;\r\n};\r\n\r\ngetJasmineRequireObj().toMatch = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');\r\n\r\n  function toMatch() {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\r\n          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));\r\n        }\r\n\r\n        var regexp = new RegExp(expected);\r\n\r\n        return {\r\n          pass: regexp.test(actual)\r\n        };\r\n      }\r\n    };\r\n  }\r\n\r\n  return toMatch;\r\n};\r\n\r\ngetJasmineRequireObj().toThrow = function(j$) {\r\n\r\n  var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');\r\n\r\n  function toThrow(util) {\r\n    return {\r\n      compare: function(actual, expected) {\r\n        var result = { pass: false },\r\n          threw = false,\r\n          thrown;\r\n\r\n        if (typeof actual != 'function') {\r\n          throw new Error(getErrorMsg('Actual is not a Function'));\r\n        }\r\n\r\n        try {\r\n          actual();\r\n        } catch (e) {\r\n          threw = true;\r\n          thrown = e;\r\n        }\r\n\r\n        if (!threw) {\r\n          result.message = 'Expected function to throw an exception.';\r\n          return result;\r\n        }\r\n\r\n        if (arguments.length == 1) {\r\n          result.pass = true;\r\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\r\n\r\n          return result;\r\n        }\r\n\r\n        if (util.equals(thrown, expected)) {\r\n          result.pass = true;\r\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\r\n        } else {\r\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\r\n        }\r\n\r\n        return result;\r\n      }\r\n    };\r\n  }\r\n\r\n  return toThrow;\r\n};\r\n\r\ngetJasmineRequireObj().toThrowError = function(j$) {\r\n\r\n  var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');\r\n\r\n  function toThrowError () {\r\n    return {\r\n      compare: function(actual) {\r\n        var threw = false,\r\n          pass = {pass: true},\r\n          fail = {pass: false},\r\n          thrown;\r\n\r\n        if (typeof actual != 'function') {\r\n          throw new Error(getErrorMsg('Actual is not a Function'));\r\n        }\r\n\r\n        var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n        try {\r\n          actual();\r\n        } catch (e) {\r\n          threw = true;\r\n          thrown = e;\r\n        }\r\n\r\n        if (!threw) {\r\n          fail.message = 'Expected function to throw an Error.';\r\n          return fail;\r\n        }\r\n\r\n        if (!(thrown instanceof Error)) {\r\n          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n          return fail;\r\n        }\r\n\r\n        if (errorMatcher.hasNoSpecifics()) {\r\n          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n          return pass;\r\n        }\r\n\r\n        if (errorMatcher.matches(thrown)) {\r\n          pass.message = function() {\r\n            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n          };\r\n          return pass;\r\n        } else {\r\n          fail.message = function() {\r\n            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n          };\r\n          return fail;\r\n        }\r\n      }\r\n    };\r\n\r\n    function getMatcher() {\r\n      var expected = null,\r\n          errorType = null;\r\n\r\n      if (arguments.length == 2) {\r\n        expected = arguments[1];\r\n        if (isAnErrorType(expected)) {\r\n          errorType = expected;\r\n          expected = null;\r\n        }\r\n      } else if (arguments.length > 2) {\r\n        errorType = arguments[1];\r\n        expected = arguments[2];\r\n        if (!isAnErrorType(errorType)) {\r\n          throw new Error(getErrorMsg('Expected error type is not an Error.'));\r\n        }\r\n      }\r\n\r\n      if (expected && !isStringOrRegExp(expected)) {\r\n        if (errorType) {\r\n          throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));\r\n        } else {\r\n          throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));\r\n        }\r\n      }\r\n\r\n      function messageMatch(message) {\r\n        if (typeof expected == 'string') {\r\n          return expected == message;\r\n        } else {\r\n          return expected.test(message);\r\n        }\r\n      }\r\n\r\n      return {\r\n        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n        thrownDescription: function(thrown) {\r\n          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n              thrownMessage = '';\r\n\r\n          if (expected) {\r\n            thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n          }\r\n\r\n          return thrownName + thrownMessage;\r\n        },\r\n        messageDescription: function() {\r\n          if (expected === null) {\r\n            return '';\r\n          } else if (expected instanceof RegExp) {\r\n            return ' with a message matching ' + j$.pp(expected);\r\n          } else {\r\n            return ' with message ' + j$.pp(expected);\r\n          }\r\n        },\r\n        hasNoSpecifics: function() {\r\n          return expected === null && errorType === null;\r\n        },\r\n        matches: function(error) {\r\n          return (errorType === null || error instanceof errorType) &&\r\n            (expected === null || messageMatch(error.message));\r\n        }\r\n      };\r\n    }\r\n\r\n    function isStringOrRegExp(potential) {\r\n      return potential instanceof RegExp || (typeof potential == 'string');\r\n    }\r\n\r\n    function isAnErrorType(type) {\r\n      if (typeof type !== 'function') {\r\n        return false;\r\n      }\r\n\r\n      var Surrogate = function() {};\r\n      Surrogate.prototype = type.prototype;\r\n      return (new Surrogate()) instanceof Error;\r\n    }\r\n  }\r\n\r\n  return toThrowError;\r\n};\r\n\r\ngetJasmineRequireObj().interface = function(jasmine, env) {\r\n  var jasmineInterface = {\r\n    describe: function(description, specDefinitions) {\r\n      return env.describe(description, specDefinitions);\r\n    },\r\n\r\n    xdescribe: function(description, specDefinitions) {\r\n      return env.xdescribe(description, specDefinitions);\r\n    },\r\n\r\n    fdescribe: function(description, specDefinitions) {\r\n      return env.fdescribe(description, specDefinitions);\r\n    },\r\n\r\n    it: function() {\r\n      return env.it.apply(env, arguments);\r\n    },\r\n\r\n    xit: function() {\r\n      return env.xit.apply(env, arguments);\r\n    },\r\n\r\n    fit: function() {\r\n      return env.fit.apply(env, arguments);\r\n    },\r\n\r\n    beforeEach: function() {\r\n      return env.beforeEach.apply(env, arguments);\r\n    },\r\n\r\n    afterEach: function() {\r\n      return env.afterEach.apply(env, arguments);\r\n    },\r\n\r\n    beforeAll: function() {\r\n      return env.beforeAll.apply(env, arguments);\r\n    },\r\n\r\n    afterAll: function() {\r\n      return env.afterAll.apply(env, arguments);\r\n    },\r\n\r\n    expect: function(actual) {\r\n      return env.expect(actual);\r\n    },\r\n\r\n    pending: function() {\r\n      return env.pending.apply(env, arguments);\r\n    },\r\n\r\n    fail: function() {\r\n      return env.fail.apply(env, arguments);\r\n    },\r\n\r\n    spyOn: function(obj, methodName) {\r\n      return env.spyOn(obj, methodName);\r\n    },\r\n\r\n    jsApiReporter: new jasmine.JsApiReporter({\r\n      timer: new jasmine.Timer()\r\n    }),\r\n\r\n    jasmine: jasmine\r\n  };\r\n\r\n  jasmine.addCustomEqualityTester = function(tester) {\r\n    env.addCustomEqualityTester(tester);\r\n  };\r\n\r\n  jasmine.addMatchers = function(matchers) {\r\n    return env.addMatchers(matchers);\r\n  };\r\n\r\n  jasmine.clock = function() {\r\n    return env.clock;\r\n  };\r\n\r\n  return jasmineInterface;\r\n};\r\n\r\ngetJasmineRequireObj().version = function() {\r\n  return '2.5.2';\r\n};\r\n"}